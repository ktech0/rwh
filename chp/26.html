<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>第26章 高级库设计：构建一个布隆过滤器 &#8212; Real World Haskell 中文版</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="第 27 章：Socket 和 Syslog" href="27.html" />
    <link rel="prev" title="第 25 章：性能剖析与优化" href="25.html" /> 
  </head><body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <section id="id1">
<h1>第26章 高级库设计：构建一个布隆过滤器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<section id="id2">
<h2>布隆过滤器介绍<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是空间利用的高效性。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询的某个元素存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前没有插入过的元素，那么布隆过滤器可能会返回错误的结果，即声称它是存在的。</p>
<p>对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如 BitTorrent），使得一些交互式会话（比如 <code class="docutils literal notranslate"><span class="pre">ssh</span></code> 或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在 10000 个批量数据包中误判其中的 1 个为交互式数据包且没有截止，也不会造成任何问题。</p>
<p>布隆过滤器吸引人的地方在于它的空间效率。举个例子，假设现在有一个包含一百万个单词的词典，我们想基于这个词典构建一个拼写检查器，若使用集合数据结构则可能会消耗 20MB 的空间。相比之下，布隆过滤器会消耗大约 0.5MB，代价是漏掉大约 1% 拼错的单词。</p>
<p>布隆过滤器的内部非常简单。它由一个位数组（bit array）和少数哈希函数组成。我们使用 k 表示哈希函数的数量。向布隆过滤器中插入数据时，先用哈希函数为数据计算出 k 个哈希值，然后在位数组中将这些位设置为 1。如果我们想要看看某个数据是否存在，那么就为这个数据计算出 k 个哈希值，然后检查位数组中这些哈希值的位是否都为 1。</p>
<p>下面通过一个例子理解整个过程。现在我们想向布隆过滤器中插入字符串 <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;bar&quot;</span></code> ，这个布隆过滤器有 8 位宽，并且我们有两个哈希函数：</p>
<ol class="arabic simple">
<li><p>假设用两个哈希函数分别计算 <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 的哈希值，得到 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">6</span></code></p></li>
<li><p>在位数组中置位 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">6</span></code></p></li>
<li><p>同样用 1 中的两个哈希函数计算 <code class="docutils literal notranslate"><span class="pre">&quot;bar&quot;</span></code> 的哈希值，得到 <code class="docutils literal notranslate"><span class="pre">6</span></code> 和 <code class="docutils literal notranslate"><span class="pre">3</span></code></p></li>
<li><p>在位数组中置位 <code class="docutils literal notranslate"><span class="pre">6</span></code> 和 <code class="docutils literal notranslate"><span class="pre">3</span></code></p></li>
</ol>
<p>这个例子解释了为什么我们不能从布隆过滤器中移除一个元素：插入 <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;bar&quot;</span></code> 都会导致位数组中的第 <code class="docutils literal notranslate"><span class="pre">6</span></code> 位被置位。</p>
<p>假设我们现在想要查询布隆过滤器中 <code class="docutils literal notranslate"><span class="pre">&quot;quux&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;baz&quot;</span></code> 是否存在：</p>
<ol class="arabic simple">
<li><p>用和之前相同的两个哈希函数计算 <code class="docutils literal notranslate"><span class="pre">&quot;quux&quot;</span></code> 的哈希值，得到 <code class="docutils literal notranslate"><span class="pre">4</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>检查位数组中的位 <code class="docutils literal notranslate"><span class="pre">4</span></code>，位 <code class="docutils literal notranslate"><span class="pre">4</span></code> 没有被置位，所以 <code class="docutils literal notranslate"><span class="pre">&quot;quux&quot;</span></code> 不可能存在，我们不需要检查位 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>计算 <code class="docutils literal notranslate"><span class="pre">“baz”</span></code> 的两个哈希值，得到 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">3</span></code></p></li>
<li><p>检查位数组中的位 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，位 <code class="docutils literal notranslate"><span class="pre">1</span></code> 被置位；同样，位 <code class="docutils literal notranslate"><span class="pre">3</span></code> 也被置位。所以我们认为 <code class="docutils literal notranslate"><span class="pre">&quot;baz&quot;</span></code> 存在。但是实际上 <code class="docutils literal notranslate"><span class="pre">&quot;bar&quot;</span></code> 并不存在，这里我们得到了一个误判。</p></li>
</ol>
<p>如果你想了解布隆过滤器的一些使用案例，请参阅 <a class="reference internal" href="#broder02" id="id3"><span>[Broder02]</span></a></p>
</section>
<section id="id4">
<h2>使用场景与封装设计<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>不是所有布隆过滤器的使用需求都完全相同。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对于其他应用，我们可能需要在创建布隆过滤器之后持续更新。我们通过把可变和不可变的 API 放在不同的模块中来对它们实施分离，其中 <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 用于实现不可变的布隆过滤器，而 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Mutable</span></code> 则用于实现可变的布隆过滤器。</p>
<p>我们将可变与不可变的API分离，通过把他们放在不同的模块中： <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 用于不可变的代码，<code class="docutils literal notranslate"><span class="pre">BloomFilter.Mutable</span></code> 用于可变代码。</p>
<p>另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。</p>
<p>最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[Word32]</span></code> 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。</p>
</section>
<section id="id5">
<h2>基本设计<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>跟前面介绍布隆过滤器实现原理时提到的数据结构一样，我们的 Haskell 版布隆过滤器也会用到一个位数组和一个能够计算出多个哈希值的函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Internal.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Internal</span>
    <span class="p">(</span>
      <span class="kt">Bloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">,</span> <span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Array.ST</span> <span class="p">(</span><span class="kt">STUArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.Unboxed</span> <span class="p">(</span><span class="kt">UArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">B</span> <span class="p">{</span>
      <span class="n">blmHash</span>  <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>
    <span class="p">,</span> <span class="n">blmArray</span> <span class="ow">::</span> <span class="kt">UArray</span> <span class="kt">Word32</span> <span class="kt">Bool</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>因为 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Internal</span></code> 模块纯粹是为了控制名称的可见性而存在的，所以在创建 Cabal 包时，我们将不会导出这个模块。我们把 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Internal</span></code> 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块 API 相关的类型。</p>
<section id="bottom">
<h3>拆箱，提升和bottom<a class="headerlink" href="#bottom" title="Permalink to this headline">¶</a></h3>
<p>与其他 Haskell 的数组不同， <code class="docutils literal notranslate"><span class="pre">UArray</span></code> 包含未装箱的值。</p>
<p>对于一个常规的 Haskell 类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值 <code class="docutils literal notranslate"><span class="pre">⊥</span></code> ，发音为（有时候也写作） “bottom”。值 <code class="docutils literal notranslate"><span class="pre">⊥</span></code> 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 <code class="docutils literal notranslate"><span class="pre">error</span></code> 应用，或者特殊值 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 。</p>
<p>一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">&quot;eek!&quot;</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 来代替常规表达式。</p>
<p>存储形式程序和 bottom 的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 <code class="docutils literal notranslate"><span class="pre">Word32</span></code> 类型。这种类型的值是全 32 位宽的，所以在 32 位系统上，没有办法直接用 32 位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 <code class="docutils literal notranslate"><span class="pre">⊥</span></code> 。</p>
<p>一个未装箱的值没有这种间接性。通过未装箱可以获得性能，但是牺牲了表示形式程序或者 bottom 的能力。因为未装箱的数组可以比常规 Haskell 的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。</p>
<p>GHC 通过将 8 个数组元素组装成 1 个字节，实现了一种 Bool 类型的 UArray 数组，这种数组非常适合我们的需求。</p>
</section>
</section>
<section id="st-monad">
<h2>ST monad<a class="headerlink" href="#st-monad" title="Permalink to this headline">¶</a></h2>
<p>正如前面的 <a class="reference internal" href="12.html#modifying-array-elements"><span class="std std-ref">修改数组元素</span></a> 部分所说，因为修改一个不可变数组需要对整个数组进行复制，所以这种修改的代价是非常高的。即使使用 <code class="docutils literal notranslate"><span class="pre">UArray</span></code> ，这一问题仍然会存在。那么我们如何才能将复制不可变数组的代价降低至我们可以承受的水平呢？</p>
<p>在指令式语言中，我们可以简单地原地修改数组元素，并且在 Haskell 里面也可以这样做。</p>
<p>Haskell 提供了一个特殊的 Monad，叫做 <code class="docutils literal notranslate"><span class="pre">ST</span></code> <a class="footnote-reference brackets" href="#id22" id="id6">58</a> <em>（State Transformer）</em> 。 <code class="docutils literal notranslate"><span class="pre">ST</span></code> 允许我们安全地工作在可变状态下。与 <code class="docutils literal notranslate"><span class="pre">State</span></code> Monad 相比，<code class="docutils literal notranslate"><span class="pre">ST</span></code> Monad 有一些额外的强大功能。</p>
<ul class="simple">
<li><p>解冻一个不可变数组并得到一个可变数组，接着原地对可变数组进行修改，然后在修改完成之后冻结出一个新的不可变数组。</p></li>
<li><p>通过 <em>可变引用（mutable references）</em> 可以构建出一种数据结构，这种数据结构允许用户像命令式语言一样随时对其进行修改。对于那些尚未找到高效纯函数替代的命令式数据结构和算法来说，这个功能尤为重要。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">IO</span></code> Monad 同样提供了这些功能。两者的主要区别在于， <code class="docutils literal notranslate"><span class="pre">ST</span></code> Monad 是为了让用户能够从 Monad 中回退到纯 Haskell 代码中而设计的。和大部分 Haskell Monad（当然除了 <code class="docutils literal notranslate"><span class="pre">IO</span></code> ）一样，我们通过执行函数 <code class="docutils literal notranslate"><span class="pre">runST</span></code> 进入 <code class="docutils literal notranslate"><span class="pre">ST</span></code> Monad，然后通过从 <code class="docutils literal notranslate"><span class="pre">runST</span></code> 中 return 来退出。</p>
<p>当我们应用一个 Monad 的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 <code class="docutils literal notranslate"><span class="pre">runST</span></code> 。为了达到这种可重复性（repeatablility），<code class="docutils literal notranslate"><span class="pre">ST</span></code> Monad比 <code class="docutils literal notranslate"><span class="pre">IO</span></code> Monad 更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 <code class="docutils literal notranslate"><span class="pre">runST</span></code> 的调用方。在返回数据之前，可变数组必须被冻结（frozen）为不可变数组，并且可变引用不可以逃逸。</p>
</section>
<section id="api">
<h2>设计一个合格的输入API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>我们需要讨论一下用来处理布隆过滤器的公开接口。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Mutable</span>
    <span class="p">(</span>
      <span class="kt">MutBloom</span>
    <span class="p">,</span> <span class="nf">elem</span>
    <span class="p">,</span> <span class="nf">notElem</span>
    <span class="p">,</span> <span class="nf">insert</span>
    <span class="p">,</span> <span class="nf">length</span>
    <span class="p">,</span> <span class="nf">new</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">liftM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.ST</span> <span class="p">(</span><span class="kt">ST</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.MArray</span> <span class="p">(</span><span class="nf">getBounds</span><span class="p">,</span> <span class="nf">newArray</span><span class="p">,</span> <span class="nf">readArray</span><span class="p">,</span> <span class="nf">writeArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">elem</span><span class="p">,</span> <span class="nf">length</span><span class="p">,</span> <span class="nf">notElem</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Internal</span> <span class="p">(</span><span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<p>在我们导出的函数当中，有几个函数和 Prelude 导出的函数具有相同的名称。这么做是经过考虑的：我们希望用户使用限制名称导入我们的模块，这减轻了用户记忆的负担，因为他们对 Prelude 中的 <code class="docutils literal notranslate"><span class="pre">elem</span></code> ，<code class="docutils literal notranslate"><span class="pre">notElem</span></code> 和 <code class="docutils literal notranslate"><span class="pre">length</span></code> 函数已经相当熟悉了。</p>
<p>在导入这种风格的模块时，我们通常会使用单个字母来作为前缀。例如，用户在代码中使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">qualified</span> <span class="pre">BloomFilter.Mutable</span> <span class="pre">as</span> <span class="pre">M</span></code> 导入模块，此时用户可以将导入模块中的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 写为 <code class="docutils literal notranslate"><span class="pre">M.length</span></code> ，这保持了代码的紧凑型和可读性。</p>
<p>我们也可以不使用限制名称导入模块，但这样一来的话，我们就需要通过 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Prelude</span> <span class="pre">hiding</span> <span class="pre">(length)</span></code> 来隐藏 Prelude 与模块相冲突的函数。我们不建议使用这种做法，因为它使读者容易忽视代码中的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 并非 Prelude 模块的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 。</p>
<p>当然，我们在上面定义的模块头中违背了这个规则：我们导入了 Prelude 并且隐藏了它的一些函数名。这是因为我们在模块中定义了自己的函数 <code class="docutils literal notranslate"><span class="pre">length</span></code> ，如果不先隐藏 Prelude 包中的同名函数，编译器将无法确定它该导出我们自定义的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 还是 Prelude 中的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 。</p>
<p>虽然导出完全限定名称 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Mutable.length</span></code> 能够消除歧义，但它看起来更丑陋。这个决定对使用模块的用户没有影响，它仅仅针对我们自己 —— 黑盒的设计者，所以这里一般不会导致混淆。</p>
</section>
<section id="id7">
<h2>创建一个可变的布隆过滤器<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>我们将可变布隆过滤器和不可变的 <code class="docutils literal notranslate"><span class="pre">Bloom</span></code> 类型均声明在 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Internal</span></code> 模块中。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Internal.hs</span>
<span class="kr">data</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MB</span> <span class="p">{</span>
          <span class="n">mutHash</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>
        <span class="p">,</span> <span class="n">mutArray</span> <span class="ow">::</span> <span class="kt">STUArray</span> <span class="n">s</span> <span class="kt">Word32</span> <span class="kt">Bool</span>
        <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 类型提供了可以在 <code class="docutils literal notranslate"><span class="pre">ST</span></code> monad 中使用的可变数组，我们可以使用 <code class="docutils literal notranslate"><span class="pre">newArray</span></code> 函数创建一个 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 。下面的 <code class="docutils literal notranslate"><span class="pre">new</span></code> 函数属于 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Mutable</span></code> 模块（译注：此处应为 <code class="docutils literal notranslate"><span class="pre">module</span></code> ，原著中此处为 <code class="docutils literal notranslate"><span class="pre">function</span></code> ）。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">new</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">new</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="ow">=</span> <span class="kt">MB</span> <span class="n">hash</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">newArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numBits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kt">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 的大多数方法实际上是 <code class="docutils literal notranslate"><span class="pre">MArray</span></code> 类型类的实现，这个类型类在 <code class="docutils literal notranslate"><span class="pre">Data.Array.MArray</span></code> 模块中定义。</p>
<p>有两个因素导致我们自己定义的 <code class="docutils literal notranslate"><span class="pre">length</span></code> 函数略显复杂：函数依赖于位数组对自己边界的记录，且 <code class="docutils literal notranslate"><span class="pre">MArray</span></code> 实例的 <code class="docutils literal notranslate"><span class="pre">getBounds</span></code> 函数有一个 monadic 类型。此外最终的结果还需要加 1，因为数组的上限比实际长度小 1。</p>
<p>布隆过滤器在添加元素时，需要将哈希函数计算出的所有位置位。 <code class="docutils literal notranslate"><span class="pre">mod</span></code> 函数确保了所有计算出的哈希值都限制在位数组范围之内，并将计算位数组偏移量的代码独立为一个函数。（译注：这里使用 <code class="docutils literal notranslate"><span class="pre">mod</span></code> 函数最好保证散列的范围是取模的倍数，否则使用 <code class="docutils literal notranslate"><span class="pre">mod</span></code> 会使散列结果倾向于某种概率分布。由于布隆过滤器和散列通常基于概率，因此应当避免概率分布过分偏离平均）</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">insert</span> <span class="ow">::</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">insert</span> <span class="n">filt</span> <span class="n">elt</span> <span class="ow">=</span> <span class="n">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="o">&gt;&gt;=</span>
                                  <span class="n">mapM_</span> <span class="p">(</span><span class="nf">\</span><span class="n">bit</span> <span class="ow">-&gt;</span> <span class="n">writeArray</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">filt</span><span class="p">)</span> <span class="n">bit</span> <span class="kt">True</span><span class="p">)</span>

<span class="nf">indices</span> <span class="ow">::</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">modulus</span> <span class="ow">&lt;-</span> <span class="n">length</span> <span class="n">filt</span>
  <span class="n">return</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="n">modulus</span><span class="p">)</span> <span class="p">(</span><span class="n">mutHash</span> <span class="n">filt</span> <span class="n">elt</span><span class="p">)</span>
</pre></div>
</div>
<p>判断一个元素是否属于布隆过滤器的成员非常简单：如果根据元素计算出的哈希值对应的每一位都已经被置位，则可以认为这个元素已经位于布隆过滤器中。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">elem</span><span class="p">,</span> <span class="n">notElem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="kt">Bool</span>

<span class="nf">elem</span> <span class="n">elt</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="o">&gt;&gt;=</span>
                                <span class="n">allM</span> <span class="p">(</span><span class="n">readArray</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">filt</span><span class="p">))</span>

<span class="nf">notElem</span> <span class="n">elt</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">elem</span> <span class="n">elt</span> <span class="n">filt</span>
</pre></div>
</div>
<p>我们需要再编写一个简单的支持函数：monadic 版本的 <code class="docutils literal notranslate"><span class="pre">all</span></code> ，这里将其命名为 <code class="docutils literal notranslate"><span class="pre">allM</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">allM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span>
<span class="nf">allM</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ok</span> <span class="ow">&lt;-</span> <span class="n">p</span> <span class="n">x</span>
  <span class="kr">if</span> <span class="n">ok</span>
        <span class="kr">then</span> <span class="n">allM</span> <span class="n">p</span> <span class="n">xs</span>
        <span class="kr">else</span> <span class="n">return</span> <span class="kt">False</span>
<span class="nf">allM</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">True</span>
</pre></div>
</div>
</section>
<section id="id8">
<h2>不可变的 API<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>我们为可变布隆过滤器保留的接口与不可变布隆过滤器的 API 拥有相同的结构：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch26/BloomFilter.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter</span>
        <span class="p">(</span>
          <span class="kt">Bloom</span>
        <span class="p">,</span> <span class="nf">length</span>
        <span class="p">,</span> <span class="nf">elem</span>
        <span class="p">,</span> <span class="nf">notElem</span>
        <span class="p">,</span> <span class="nf">fromList</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Internal</span>
<span class="kr">import</span> <span class="nn">BloomFilter.Mutable</span> <span class="p">(</span><span class="nf">insert</span><span class="p">,</span> <span class="nf">new</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.ST</span> <span class="p">(</span><span class="nf">runSTUArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.IArray</span> <span class="p">((</span><span class="o">!</span><span class="p">),</span> <span class="nf">bounds</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">elem</span><span class="p">,</span> <span class="nf">length</span><span class="p">,</span> <span class="nf">notElem</span><span class="p">)</span>

<span class="nf">length</span> <span class="ow">::</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">length</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">.</span> <span class="n">len</span>

<span class="nf">len</span> <span class="ow">::</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span>
<span class="nf">len</span> <span class="ow">=</span> <span class="n">succ</span> <span class="o">.</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">bounds</span> <span class="o">.</span> <span class="n">blmArray</span>

<span class="nf">elem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elt</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span>   <span class="ow">=</span> <span class="n">all</span> <span class="n">test</span> <span class="p">(</span><span class="n">blmHash</span> <span class="n">filt</span> <span class="n">elt</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">test</span> <span class="n">hash</span> <span class="ow">=</span> <span class="n">blmArray</span> <span class="n">filt</span> <span class="o">!</span> <span class="p">(</span><span class="n">hash</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">len</span> <span class="n">filt</span><span class="p">)</span>

<span class="nf">notElem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elt</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">elt</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span><span class="p">)</span>
</pre></div>
</div>
<p>我们还提供了一个易于使用的方法，用户可以通过 <code class="docutils literal notranslate"><span class="pre">fromList</span></code> 函数创建不可变的布隆过滤器。这个函数对用户隐藏了 <code class="docutils literal notranslate"><span class="pre">ST</span></code> monad，因此他们只能看到不可变类型。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch26/BloomFilter.hs</span>
<span class="nf">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>    <span class="c1">-- family of hash functions to use</span>
                 <span class="ow">-&gt;</span> <span class="kt">Word32</span>             <span class="c1">-- number of bits in filter</span>
                 <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>                <span class="c1">-- values to populate with</span>
                 <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span>
<span class="nf">fromList</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="kt">B</span> <span class="n">hash</span> <span class="o">.</span> <span class="n">runSTUArray</span> <span class="o">$</span>
          <span class="kr">do</span> <span class="n">mb</span> <span class="ow">&lt;-</span> <span class="n">new</span> <span class="n">hash</span> <span class="n">numBits</span>
                 <span class="n">mapM_</span> <span class="p">(</span><span class="n">insert</span> <span class="n">mb</span><span class="p">)</span> <span class="n">values</span>
                 <span class="n">return</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">mb</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在 <strong>GHC</strong> 7.x 中无法通过编译，可以作如下修改来通过编译。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fromList</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="p">(</span><span class="kt">B</span> <span class="n">hash</span> <span class="o">.</span> <span class="n">runSTUArray</span><span class="p">)</span> <span class="p">(</span><span class="n">new</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">mb</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">mapM_</span> <span class="p">(</span><span class="n">insert</span> <span class="n">mb</span><span class="p">)</span> <span class="n">values</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">mb</span><span class="p">))</span>
</pre></div>
</div>
<p>]</p>
<p><code class="docutils literal notranslate"><span class="pre">fromList</span></code> 函数的关键在于 <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 。前面提过，为了从 <code class="docutils literal notranslate"><span class="pre">ST</span></code> monad 返回一个不可变数组，我们必须冻结一个可变数组，而 <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 函数将执行和冻结相结合。给定一个返回 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 的动作， <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 会使用 <code class="docutils literal notranslate"><span class="pre">runST</span></code> 执行这个动作，之后冻结返回的 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 并将结果作为 <code class="docutils literal notranslate"><span class="pre">UArray</span></code> 返回。</p>
<p><code class="docutils literal notranslate"><span class="pre">MArray</span></code> 类型类同样提供了一个可用的冻结函数，不过 <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 更方便，也更有效。这是因为冻结必须将底层数据从 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 复制到新的 <code class="docutils literal notranslate"><span class="pre">UArray</span></code> 以确保对 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 的后续修改不会影响 <code class="docutils literal notranslate"><span class="pre">UArray</span></code> 。因为类型系统的存在， <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 可以在创建 <code class="docutils literal notranslate"><span class="pre">UArray</span></code> 的同时保证 <code class="docutils literal notranslate"><span class="pre">STUArray</span></code> 不能被访问。因此 <code class="docutils literal notranslate"><span class="pre">runSTUArray</span></code> 无需复制也可以共享两个数组之间的底层内容。</p>
</section>
<section id="id9">
<h2>创建友好的接口<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>在创建了布隆过滤器之后，我们就可以直接使用上面提到的不可变布隆过滤器 API 。需要注意的是， <code class="docutils literal notranslate"><span class="pre">fromList</span></code> 函数还遗留了一些重要的决策没有完成。我们仍然要选择一个合适的哈希函数，并确定布隆过滤器的容量。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="nf">easyList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">)</span>
                 <span class="ow">=&gt;</span> <span class="kt">Double</span>        <span class="c1">-- false positive rate (between 0 and 1)</span>
                 <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>           <span class="c1">-- values to populate the filter with</span>
                 <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="kt">Bloom</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>这里有一种更 “友好” 的方式创建布隆过滤器：这种方式将计算哈希值的任务交给了 <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> 类型类，并且允许我们将可容忍的错误率作为参数配置布隆过滤器。它还可以根据容错率和输入列表中的元素数量为我们自动选择合适的过滤器大小。</p>
<p>当然，这种方式不是始终可用的。例如，它可能在输入列表的长度过长时失败。但是这种方法的简便性比起我们之前提供的其他接口都要更胜一筹：它使得接口的用户能够对布隆过滤器的整个创建过程进行一系列控制，并将原来彻头彻尾的命令式接口变成了完完全全的声明式接口。</p>
<section id="id10">
<h3>导出更方便的名称<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在模块的导出列表中，我们从基本的 <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 模块中重新导出了一些名称。这允许临时用户只导入 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Easy</span></code> 模块，并访问他们可能需要的所有类型和功能。</p>
<p>你可能会好奇，同时导入一个被 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Easy</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 二者均导出的名称会带来什么后果。我们知道，如果不使用 <code class="docutils literal notranslate"><span class="pre">qualified</span></code> 导入 <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 并调用 <code class="docutils literal notranslate"><span class="pre">length</span></code> 函数，GHC 会发出一个有关歧义的错误，因为 <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> 中也包含一个同名函数。</p>
<p>Haskell 标准的实现要能够分辨出指向同一个 “事物” 的多个不同名称。例如， <code class="docutils literal notranslate"><span class="pre">BloomFilter</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Easy</span></code> 均导出了 <code class="docutils literal notranslate"><span class="pre">Bloom</span></code> 类型，如果我们同时导入了这两个模块并使用 <code class="docutils literal notranslate"><span class="pre">Bloom</span></code> ，GHC 将能够发现这两个模块导出的 <code class="docutils literal notranslate"><span class="pre">Bloom</span></code> 相同，并且不会报告歧义。</p>
</section>
<section id="id11">
<h3>哈希值<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>一个布隆过滤器的性能取决于快速、高质量的哈希函数，然而编写一个兼具这两种属性的哈希函数非常困难。</p>
<p>幸运的是，一个名为 Bob Jenkins 的开发人员编写了一些具有这些属性的哈希函数，并公开了代码（网址为 <a class="reference external" href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a> <a class="footnote-reference brackets" href="#id23" id="id12">59</a>）。这些哈希函数使用 C 语言编写，可以通过 FFI 创建它们的绑定。在该网站上，我们需要的特定源文件名为 <code class="docutils literal notranslate"><span class="pre">lookup3.c</span></code> ，在本地创建一个 <code class="docutils literal notranslate"><span class="pre">cbits</span></code> 目录并将这个文件下载到该目录。</p>
<p>还剩下最后一个难题没有解决：我们可能经常需要七个、十个，甚至更多个散列函数，但又不想把这些不同功能的哈希函数混杂到一起。幸运的是，在实际应用中我们多数情况下只需要两个哈希函数，下面很快就会讲到如何实现。Jenkins 的散列库包含两个函数 <code class="docutils literal notranslate"><span class="pre">hashword2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">hashlittle2</span></code> ，它们计算两个哈希值。这里有一个 C 语言的头文件，它描述了这两个函数的 API，我们将它保存为 <code class="docutils literal notranslate"><span class="pre">cbits/lookup3.h</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">save</span> <span class="n">this</span> <span class="n">file</span> <span class="n">as</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">h</span> <span class="o">*/</span>

<span class="o">#</span><span class="n">ifndef</span> <span class="n">_lookup3_h</span>
<span class="o">#</span><span class="n">define</span> <span class="n">_lookup3_h</span>

<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdint</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">types</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>

<span class="o">/*</span> <span class="n">only</span> <span class="n">accepts</span> <span class="n">uint32_t</span> <span class="n">aligned</span> <span class="n">arrays</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="o">*/</span>
<span class="nf">void</span> <span class="n">hashword2</span><span class="p">(</span><span class="n">const</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>  <span class="o">/*</span> <span class="n">array</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="o">*/</span>
                   <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span>            <span class="o">/*</span> <span class="n">number</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="n">values</span> <span class="o">*/</span>
                   <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>             <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed1</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash1</span> <span class="o">*/</span>
                   <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pb</span><span class="p">);</span>            <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed2</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash2</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">handles</span> <span class="n">arbitrarily</span> <span class="n">aligned</span> <span class="n">arrays</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
<span class="nf">void</span> <span class="n">hashlittle2</span><span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>   <span class="o">/*</span> <span class="n">array</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
                 <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span>     <span class="o">/*</span> <span class="n">number</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
                 <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>      <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed1</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash1</span> <span class="o">*/</span>
                 <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pb</span><span class="p">);</span>     <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed2</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash2</span> <span class="o">*/</span>

<span class="o">#</span><span class="n">endif</span> <span class="o">/*</span> <span class="n">_lookup3_h</span> <span class="o">*/</span>
</pre></div>
</div>
<p>“盐” 是在计算哈希值时加入的干扰值。如果我们用某哈希函数求一个值的散列，并分别加入两个不同的盐，那么将会计算出两个不同的结果。因为即使是同一个哈希函数，接收了两个不同的盐值后，计算结果也会相去甚远。</p>
<p>下面的代码是对这两个函数的绑定：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="cm">{-# LANGUAGE BangPatterns, ForeignFunctionInterface #-}</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Hash</span>
        <span class="p">(</span>
          <span class="kt">Hashable</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
        <span class="p">,</span> <span class="nf">hash</span>
        <span class="p">,</span> <span class="nf">doubleHash</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Bits</span> <span class="p">((</span><span class="o">.&amp;.</span><span class="p">),</span> <span class="nf">shiftR</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Marshal.Array</span> <span class="p">(</span><span class="nf">withArrayLen</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">foldM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">,</span> <span class="kt">Word64</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.C.Types</span> <span class="p">(</span><span class="kt">CSize</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Marshal.Utils</span> <span class="p">(</span><span class="nf">with</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Ptr</span> <span class="p">(</span><span class="kt">Ptr</span><span class="p">,</span> <span class="nf">castPtr</span><span class="p">,</span> <span class="nf">plusPtr</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Storable</span> <span class="p">(</span><span class="kt">Storable</span><span class="p">,</span> <span class="nf">peek</span><span class="p">,</span> <span class="nf">sizeOf</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">Strict</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">Lazy</span>
<span class="kr">import</span> <span class="nn">System.IO.Unsafe</span> <span class="p">(</span><span class="nf">unsafePerformIO</span><span class="p">)</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">unsafe</span> <span class="s">&quot;lookup3.h hashword2&quot;</span> <span class="n">hashWord2</span>
        <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">CSize</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">unsafe</span> <span class="s">&quot;lookup3.h hashlittle2&quot;</span> <span class="n">hashLittle2</span>
        <span class="ow">::</span> <span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CSize</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在 <strong>GHC</strong> 7.6 后无法通过编译，解决方法是将 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize)</span></code> 修改为 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize(..))</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize(CSize))</span></code> 。]</p>
<p>函数的定义可以查看我们刚刚创建的 <code class="docutils literal notranslate"><span class="pre">lookup3.h</span></code> 。</p>
<p>出于对效率和便捷的考虑，我们将 Jenkins 散列函数所需的 32 位盐值和计算出的散列值组成单个 64 位值：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashIO</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="n">a</span>    <span class="c1">-- value to hash</span>
           <span class="ow">-&gt;</span> <span class="kt">CSize</span>    <span class="c1">-- number of bytes</span>
           <span class="ow">-&gt;</span> <span class="kt">Word64</span>   <span class="c1">-- salt</span>
           <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashIO</span> <span class="n">ptr</span> <span class="n">bytes</span> <span class="n">salt</span> <span class="ow">=</span>
        <span class="n">with</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">salt</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">sp</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
          <span class="kr">let</span> <span class="n">p1</span> <span class="ow">=</span> <span class="n">castPtr</span> <span class="n">sp</span>
                  <span class="n">p2</span> <span class="ow">=</span> <span class="n">castPtr</span> <span class="n">sp</span> <span class="p">`</span><span class="n">plusPtr</span><span class="p">`</span> <span class="mi">4</span>
          <span class="n">go</span> <span class="n">p1</span> <span class="n">p2</span>
          <span class="n">peek</span> <span class="n">sp</span>
  <span class="kr">where</span> <span class="n">go</span> <span class="n">p1</span> <span class="n">p2</span>
                  <span class="o">|</span> <span class="n">bytes</span> <span class="o">.&amp;.</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">hashWord2</span> <span class="p">(</span><span class="n">castPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="n">words</span> <span class="n">p1</span> <span class="n">p2</span>
                  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="n">hashLittle2</span> <span class="n">ptr</span> <span class="n">bytes</span> <span class="n">p1</span> <span class="n">p2</span>
                <span class="n">words</span> <span class="ow">=</span> <span class="n">bytes</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span>
</pre></div>
</div>
<p>[Forec 译注： <code class="docutils literal notranslate"><span class="pre">with</span></code> 在下面的段落中会有解释， <code class="docutils literal notranslate"><span class="pre">castPtr</span></code> 没有介绍过，你可以在
<a class="reference external" href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with">http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with</a> 查看 <code class="docutils literal notranslate"><span class="pre">with</span></code> 的文档，在
<a class="reference external" href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html#v:castPtr">http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html#v:castPtr</a> 查看 <code class="docutils literal notranslate"><span class="pre">castPtr</span></code> 的文档。此外，这里使用 <code class="docutils literal notranslate"><span class="pre">castPtr</span></code> 并对 <code class="docutils literal notranslate"><span class="pre">p1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">p2</span></code> 使用类型推断虽然简短了代码，但也降低了代码的可读性。]</p>
<p>上面的代码如果没有明确的类型来描述其功能，那么可能看起来就不是很清晰。 <code class="docutils literal notranslate"><span class="pre">with</span></code> 函数在 C 程序的堆栈段中为盐值分配了空间，并存储了当前的盐值，所以 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">Word64</span></code> 。指针 <code class="docutils literal notranslate"><span class="pre">p1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">p2</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">Word32</span></code> ； <code class="docutils literal notranslate"><span class="pre">p1</span></code> 指向了 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 的低位字， <code class="docutils literal notranslate"><span class="pre">p2</span></code> 指向了 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 的高位字。这就是我们将一个 <code class="docutils literal notranslate"><span class="pre">Word64</span></code> 的盐值切分为两个 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">Word32</span></code> 参数的方法。</p>
<p>因为所有的数据指针均来自 Haskell 堆，所以它们会在一个能够安全传递给 <code class="docutils literal notranslate"><span class="pre">hashWord2</span></code> （只接受 32 位对齐地址）或者 <code class="docutils literal notranslate"><span class="pre">hashLittle2</span></code> 的地址上对齐。由于 <code class="docutils literal notranslate"><span class="pre">hashWord2</span></code> 是两个哈希函数中较快的，所以我们会在数据为 4 字节的倍数时调用 <code class="docutils literal notranslate"><span class="pre">hashWord2</span></code> ，否则调用 <code class="docutils literal notranslate"><span class="pre">hashLittle2</span></code> 。 [Forec 译注：这里原著拼写错误，将 <code class="docutils literal notranslate"><span class="pre">hashWord2</span></code> 误拼写为 <code class="docutils literal notranslate"><span class="pre">hashWord32</span></code> ]</p>
<p>C 语言编写的哈希函数会将计算出的哈希值写入 <code class="docutils literal notranslate"><span class="pre">p1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">p2</span></code> 指向的地址，我们可以通过 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 直接检索计算结果。</p>
<p>使用这个模块的客户不应当被低级细节困扰，所以我们通过类型类来提供一个干净、高级的接口：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="kr">class</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="ow">::</span> <span class="kt">Word64</span>        <span class="c1">-- ^ salt</span>
                         <span class="ow">-&gt;</span> <span class="n">a</span>             <span class="c1">-- ^ value to hash</span>
                         <span class="ow">-&gt;</span> <span class="kt">Word64</span>

<span class="nf">hash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hash</span> <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x106fc397cf62f64d3</span>
</pre></div>
</div>
<p>我们还为这个类型类提供了一些实用的实现。要计算基本类型的哈希值，必须先编写一点样板代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashStorable</span> <span class="ow">::</span> <span class="kt">Storable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hashStorable</span> <span class="n">salt</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">.</span> <span class="n">with</span> <span class="n">k</span> <span class="o">$</span> <span class="nf">\</span><span class="n">ptr</span> <span class="ow">-&gt;</span>
                                          <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sizeOf</span> <span class="n">k</span><span class="p">))</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Char</span>   <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Int</span>    <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Double</span> <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
</pre></div>
</div>
<p>下面的代码使用 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 类型类将声明减少到一个：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="kr">instance</span> <span class="kt">Storable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
</pre></div>
</div>
<p>[Forec 译注：上面使用 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 的代码需要添加 <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">UndecidableInstances</span> <span class="pre">#-}</span></code> 两个编译选项后才能通过编译。 ]</p>
<p>不幸的是，Haskell 不允许编写这种形式的实例，因为它们会使类型系统无法判定：编译器的类型检查器可能会陷入无限循环中。对不可确定类型的限制使我们必须单独列出声明，但它对于上面的定义并不会造成什么影响。[Forec 译注：上面的例子中如果存在 <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Hashable</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Storable</span> <span class="pre">a</span></code> 这样的代码（虽然这样的代码没什么意义），则编译器会陷入循环。但如果程序开发者能够保证这种情况不会发生，则可以开启编译选项并使用这一扩展功能。]</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Storable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashList</span> <span class="n">salt</span> <span class="n">xs</span> <span class="ow">=</span>
        <span class="n">withArrayLen</span> <span class="n">xs</span> <span class="o">$</span> <span class="nf">\</span><span class="n">len</span> <span class="n">ptr</span> <span class="ow">-&gt;</span>
          <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="n">sizeOf</span> <span class="n">x</span><span class="p">))</span> <span class="n">salt</span>
  <span class="kr">where</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">head</span> <span class="n">xs</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Storable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="n">hashList</span> <span class="n">salt</span> <span class="n">xs</span>
</pre></div>
</div>
<p>编译器会接受这个实例，因而我们能够对多种列表类型计算哈希值 <a class="footnote-reference brackets" href="#id24" id="id13">60</a> 。最重要的是，由于 <code class="docutils literal notranslate"><span class="pre">Char</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 的一个实例，所以 <code class="docutils literal notranslate"><span class="pre">String</span></code> 类型的哈希值同样可以被计算。</p>
<p>利用函数组合可以计算元组的哈希值：在组合管道的一端取盐，并将元组中每个元素的散列结果作为计算该元组中下一个元素使用的盐值。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hash2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hash2</span> <span class="n">k</span> <span class="n">salt</span> <span class="ow">=</span> <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">k</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">hash2</span> <span class="n">b</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">a</span> <span class="o">$</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="n">hash2</span> <span class="n">c</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">b</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">a</span> <span class="o">$</span> <span class="n">salt</span>
</pre></div>
</div>
<p>要计算 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型的哈希值，我们可以编写一个直接插入到 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型内部的特殊实例，其效率非常出色：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashByteString</span> <span class="ow">::</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashByteString</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">useAsCStringLen</span> <span class="n">bs</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="ow">-&gt;</span>
                                                 <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="n">hashByteString</span> <span class="n">salt</span> <span class="n">bs</span>

<span class="nf">rechunk</span> <span class="ow">::</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span>
<span class="nf">rechunk</span> <span class="n">s</span>
        <span class="o">|</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">null</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">[]</span>
        <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">pre</span><span class="p">,</span><span class="n">suf</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">splitAt</span> <span class="n">chunkSize</span> <span class="n">s</span>
                                        <span class="kr">in</span>  <span class="n">repack</span> <span class="n">pre</span> <span class="kt">:</span> <span class="n">rechunk</span> <span class="n">suf</span>
        <span class="kr">where</span> <span class="n">repack</span>    <span class="ow">=</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">concat</span> <span class="o">.</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">toChunks</span>
                  <span class="n">chunkSize</span> <span class="ow">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span>
                                           <span class="n">foldM</span> <span class="n">hashByteString</span> <span class="n">salt</span> <span class="p">(</span><span class="n">rechunk</span> <span class="n">bs</span><span class="p">)</span>
</pre></div>
</div>
<p>由于惰性的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型是由一系列块表示的，我们必须留意块之间的边界。举个例子，字符串 <code class="docutils literal notranslate"><span class="pre">foobar</span></code> 可以通过五种不同方式表示，如 <code class="docutils literal notranslate"><span class="pre">[&quot;foob&quot;,</span> <span class="pre">&quot;ar&quot;]</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">[&quot;fo&quot;,</span> <span class="pre">&quot;obar&quot;]</span></code> 。这一点对于多数用户不可见，但我们直接使用了底层的块。 <code class="docutils literal notranslate"><span class="pre">rechunck</span></code> 函数能够确保传递给 C 语言代码的块大小统一为 64 KB，所以无论原始边界在哪里，计算出的哈希值都是一致的。</p>
</section>
<section id="id14">
<h3>将两个哈希值转换为多个<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>正如前面所述，我们需要两个以上的哈希函数才能有效地使用布隆过滤器。双重哈希技术能够组合 Jenkins 哈希函数计算出的两个值，并产生更多的哈希值。使用双重哈希技术产生的多个哈希值足够满足我们的需要，并且比计算多个不同的哈希值更容易。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">doubleHash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">doubleHash</span> <span class="n">numHashes</span> <span class="n">value</span> <span class="ow">=</span> <span class="p">[</span><span class="n">h1</span> <span class="o">+</span> <span class="n">h2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">num</span><span class="p">]]</span>
        <span class="kr">where</span> <span class="n">h</span>   <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x9150a946c4a8966e</span> <span class="n">value</span>
                  <span class="n">h1</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">h</span> <span class="p">`</span><span class="n">shiftR</span><span class="p">`</span> <span class="mi">32</span><span class="p">)</span> <span class="o">.&amp;.</span> <span class="n">maxBound</span>
                  <span class="n">h2</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">h</span>
                  <span class="n">num</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">numHashes</span>
</pre></div>
</div>
<p>[Forec 译注：上面代码中的 <code class="docutils literal notranslate"><span class="pre">maxBound</span></code> 可以通过在 GHCI 中执行 <code class="docutils literal notranslate"><span class="pre">maxBound::Word32</span></code> 查看，结果为 4294967295。]</p>
</section>
<section id="id15">
<h3>实现简单的创建函数<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">BloomFilter.Easy</span></code> 模块中，我们使用新的 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 函数来定义之前已经定义过类型的 <code class="docutils literal notranslate"><span class="pre">easyList</span></code> 函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Easy</span>
        <span class="p">(</span>
          <span class="nf">suggestSizing</span>
        <span class="p">,</span> <span class="nf">sizings</span>
        <span class="p">,</span> <span class="nf">easyList</span>

        <span class="c1">-- re-export useful names from BloomFilter</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="kt">Bloom</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">length</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">elem</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">notElem</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Hash</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="nf">doubleHash</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">genericLength</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">catMaybes</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">BloomFilter</span> <span class="k">as</span> <span class="n">B</span>

<span class="nf">easyList</span> <span class="n">errRate</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="kr">case</span> <span class="n">suggestSizing</span> <span class="p">(</span><span class="n">genericLength</span> <span class="n">values</span><span class="p">)</span> <span class="n">errRate</span> <span class="kr">of</span>
          <span class="kt">Left</span> <span class="n">err</span>            <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
          <span class="kt">Right</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="n">filt</span>
                <span class="kr">where</span> <span class="n">filt</span> <span class="ow">=</span> <span class="kt">B</span><span class="o">.</span><span class="n">fromList</span> <span class="p">(</span><span class="n">doubleHash</span> <span class="n">hashes</span><span class="p">)</span> <span class="n">bits</span> <span class="n">values</span>
</pre></div>
</div>
<p>上面的代码依赖于一个 <code class="docutils literal notranslate"><span class="pre">suggestSizing</span></code> 函数，这个函数能够根据用户要求的错误率和期望滤波器包含元素的最大数量来估计滤波器的大小以及要计算的哈希值数量：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="nf">suggestSizing</span>
        <span class="ow">::</span> <span class="kt">Integer</span>       <span class="c1">-- expected maximum capacity</span>
        <span class="ow">-&gt;</span> <span class="kt">Double</span>        <span class="c1">-- desired false positive rate</span>
        <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span> <span class="c1">-- (filter size, number of hashes)</span>
<span class="nf">suggestSizing</span> <span class="n">capacity</span> <span class="n">errRate</span>
        <span class="o">|</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span>                <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;capacity too small&quot;</span>
        <span class="o">|</span> <span class="n">errRate</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">errRate</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;invalid error rate&quot;</span>
        <span class="o">|</span> <span class="n">null</span> <span class="n">saneSizes</span>               <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;capacity too large&quot;</span>
        <span class="o">|</span> <span class="n">otherwise</span>                    <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">minimum</span> <span class="n">saneSizes</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">saneSizes</span> <span class="ow">=</span> <span class="n">catMaybes</span> <span class="o">.</span> <span class="n">map</span> <span class="n">sanitize</span> <span class="o">$</span> <span class="n">sizings</span> <span class="n">capacity</span> <span class="n">errRate</span>
                <span class="n">sanitize</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span>
                  <span class="o">|</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">maxWord32</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">Nothing</span>
                  <span class="o">|</span> <span class="n">otherwise</span>            <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">ceiling</span> <span class="n">bits</span><span class="p">,</span> <span class="n">truncate</span> <span class="n">hashes</span><span class="p">)</span>
                  <span class="kr">where</span> <span class="n">maxWord32</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Word32</span><span class="p">)</span>

<span class="nf">sizings</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span>
<span class="nf">sizings</span> <span class="n">capacity</span> <span class="n">errRate</span> <span class="ow">=</span>
        <span class="p">[(((</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">cap</span> <span class="o">/</span> <span class="n">log</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">errRate</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">k</span><span class="p">)))),</span> <span class="n">k</span><span class="p">)</span> <span class="o">|</span> <span class="n">k</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">50</span><span class="p">]]</span>
  <span class="kr">where</span> <span class="n">cap</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">capacity</span>
</pre></div>
</div>
<p>[Forec 译注：关于上面代码中 <code class="docutils literal notranslate"><span class="pre">errRate</span></code> 的推导，可以参考维基百科上布隆过滤器的词条 <a class="reference external" href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a> 。根据维基百科，有式 <code class="docutils literal notranslate"><span class="pre">errRate</span> <span class="pre">=</span> <span class="pre">(1-e^(-k*cap/size))^k</span></code> ，因为 <code class="docutils literal notranslate"><span class="pre">suggestSizing</span></code> 函数接受 <code class="docutils literal notranslate"><span class="pre">k</span></code> 、 <code class="docutils literal notranslate"><span class="pre">cap</span></code> 和 <code class="docutils literal notranslate"><span class="pre">errRate</span></code> ，我们可以重新整理方程，并得到 <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">-k*cap/log(1</span> <span class="pre">-</span> <span class="pre">errRate^(1/k))</span></code> ，这就是代码中使用的公式。]</p>
<p>我们对参数做了一定的规范。例如， <code class="docutils literal notranslate"><span class="pre">sizings</span></code> 函数虽然受到数组大小和哈希值数量的影响，但它并不验证这两个值。由于使用了 32 位哈希值，我们必须过滤掉太大的数组。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">suggestSizing</span></code> 函数中，我们仅仅尝试最小化位数组的大小，而不考虑哈希值的数量。现在让我们通过 GHCI 交互地探索一下数组大小和哈希值数量的关系，并解释这种做法的缘由：</p>
<p>假设要将一千万个元素插入布隆过滤器中，并希望误报率不超过 0.1 %。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>ghci&gt; let kbytes (bits,hashes) = (ceiling bits `div` 8192, hashes)
ghci&gt; :m +BloomFilter.Easy Data.List
Could not find module `BloomFilter.Easy&#39;:
  Use -v to see a list of the files searched for.
ghci&gt; mapM_ (print . kbytes) . take 10 . sort $ sizings 10000000 0.001

(17550,10.0)
(17601,11.0)
(17608,9.0)
(17727,12.0)
(17831,8.0)
(17905,13.0)
(18122,14.0)
(18320,7.0)
(18368,15.0)
(18635,16.0)
</pre></div>
</div>
<p>[Forec 译注：上面交互式代码在原著中是有误的，原著没有纠正这一错误，上面的结果由译者修改后计算。要想得到上面的结果，可以参考如下步骤：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">cd</span> <span class="n">cbits</span>
<span class="o">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">fPIC</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">o</span>
<span class="o">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">shared</span> <span class="o">-</span><span class="kt">Wl</span><span class="p">,</span><span class="o">-</span><span class="n">soname</span><span class="p">,</span><span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mi">1</span> <span class="o">-</span><span class="n">o</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">1</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">o</span>
<span class="o">$</span> <span class="n">ln</span> <span class="o">-</span><span class="n">s</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">1</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span>
<span class="o">$</span> <span class="n">cd</span> <span class="o">..</span>
<span class="o">$</span> <span class="n">ghci</span> <span class="o">-</span><span class="kt">L</span><span class="o">./</span><span class="n">cbits</span> <span class="o">-</span><span class="n">llookup3</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">kb</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">ceiling</span> <span class="n">bits</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">8192</span><span class="p">,</span> <span class="n">hashes</span><span class="p">)</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">&gt;</span> <span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">.</span> <span class="n">kb</span><span class="p">)</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="n">sizings</span> <span class="mi">10000000</span> <span class="mf">0.001</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">array</span><span class="o">-</span><span class="mf">0.4</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.9</span><span class="o">.</span><span class="mf">2.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="mi">17550</span><span class="p">,</span><span class="mf">10.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17601</span><span class="p">,</span><span class="mf">11.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17608</span><span class="p">,</span><span class="mf">9.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17727</span><span class="p">,</span><span class="mf">12.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17831</span><span class="p">,</span><span class="mf">8.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17905</span><span class="p">,</span><span class="mf">13.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18122</span><span class="p">,</span><span class="mf">14.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18320</span><span class="p">,</span><span class="mf">7.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18368</span><span class="p">,</span><span class="mf">15.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18635</span><span class="p">,</span><span class="mf">16.0</span><span class="p">)</span>
</pre></div>
</div>
<p>]</p>
<p>通过计算 10 个哈希值，我们得到了一个非常紧凑的表（刚好超过 17 KB）。如果真的对数据进行反复的散列，则哈希值的数量可以减少到 7 个，空间消耗可以减少到 5%。因为 Jenkins 的哈希函数在一轮计算中得到两个哈希值，并通过双重哈希产生额外的哈希值，因此我们计算额外哈希值的成本非常小，所以选择最小的表大小。</p>
<p>如果将最高可容忍误报率增加十倍，变为 1%，则所需的空间和哈希值数量都会下降，尽管下降的幅度不太容易预测。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">.</span> <span class="n">kbytes</span><span class="p">)</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="n">sizings</span> <span class="mi">10000000</span> <span class="mf">0.01</span>
<span class="p">(</span><span class="mi">11710</span><span class="p">,</span><span class="mf">7.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">11739</span><span class="p">,</span><span class="mf">6.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">11818</span><span class="p">,</span><span class="mf">8.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12006</span><span class="p">,</span><span class="mf">9.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12022</span><span class="p">,</span><span class="mf">5.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12245</span><span class="p">,</span><span class="mf">10.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12517</span><span class="p">,</span><span class="mf">11.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12810</span><span class="p">,</span><span class="mf">12.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12845</span><span class="p">,</span><span class="mf">4.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">13118</span><span class="p">,</span><span class="mf">13.0</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在原著中同样有误，计算结果由译者修改后给出，步骤同上。]</p>
</section>
</section>
<section id="cabal">
<h2>创建一个 Cabal 包<a class="headerlink" href="#cabal" title="Permalink to this headline">¶</a></h2>
<p>至此我们已经创建了一个不算太复杂的库，它包括四个公共模块和一个内部模块。现在创建一个 <code class="docutils literal notranslate"><span class="pre">rwh-bloomfilter.cabal</span></code> 文件，将这个库打包成容易发布的格式。</p>
<p>Cabal 允许我们在一个包中描述几个库的信息。 <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> 文件的头部包含了所有库通用的信息，后面跟着各个库不同的部分。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Name:</span>               <span class="n">rwh</span><span class="o">-</span><span class="n">bloomfilter</span>
<span class="kt">Version:</span>            <span class="mf">0.1</span>
<span class="kt">License:</span>            <span class="kt">BSD3</span>
<span class="kt">License</span><span class="o">-</span><span class="kt">File:</span>       <span class="kt">License</span><span class="o">.</span><span class="n">txt</span>
<span class="kt">Category:</span>           <span class="kt">Data</span>
<span class="kt">Stability:</span>          <span class="n">experimental</span>
<span class="kt">Build</span><span class="o">-</span><span class="kt">Type:</span>         <span class="kt">Simple</span>
</pre></div>
</div>
<p>由于 C 语言代码 <code class="docutils literal notranslate"><span class="pre">lookup3.c</span></code> 和库捆绑在一起，所以我们要将这个 C 语言源文件的信息告知 Cabal。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Extra</span><span class="o">-</span><span class="kt">Source</span><span class="o">-</span><span class="kt">Files:</span> <span class="n">cbits</span><span class="o">/</span><span class="n">lookup3</span><span class="o">.</span><span class="n">c</span> <span class="n">cbits</span><span class="o">/</span><span class="n">lookup3</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Extra-Source-Files</span></code> 指令对包的构建没有影响：它仅仅在我们运行 <code class="docutils literal notranslate"><span class="pre">runhaskell</span> <span class="pre">Setup</span> <span class="pre">sdist</span></code> 时指导 Cabal 绑定一些额外的文件，这条指令将创建一个用于发布的源码包。</p>
<section id="id16">
<h3>处理不同的构建设置<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>在 2007 年以前，Haskell 标准库被组织在少数几个规模较大的包中，其中最大的一个被命名为 <code class="docutils literal notranslate"><span class="pre">base</span></code> 。这个包将许多互不相关的库绑定到一起，因此 Haskell 社区将 <code class="docutils literal notranslate"><span class="pre">base</span></code> 包拆分成了几个模块化程度更高的库。</p>
<p>Cabal 包需要指明自己构建时依赖的其它包，这些信息帮助 Cabal 的命令行接口在必要的情况下自动下载并构建包的依赖。我们希望，不管用户使用的 GHC 版本是否具备 <code class="docutils literal notranslate"><span class="pre">base</span></code> 和其它包的现代布局，我们的代码都能尽量兼容。举个例子，我们的代码要能够在 <code class="docutils literal notranslate"><span class="pre">array</span></code> 包存在的时候说明自己依赖它，否则就只能依赖 <code class="docutils literal notranslate"><span class="pre">base</span></code> 包。</p>
<p>Cabal 提供了一个通用的配置功能，它允许我们选择性地启用一个 <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> 文件的某些部分。构建的配置信息由布尔类型的标识控制，标识为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">flag</span></code> 之后的文本，而标识为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时则使用跟在 <code class="docutils literal notranslate"><span class="pre">else</span></code> 之后的文本。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Cabal</span><span class="o">-</span><span class="kt">Version:</span>      <span class="o">&gt;=</span> <span class="mf">1.2</span>

<span class="kt">Flag</span> <span class="n">split</span><span class="o">-</span><span class="n">base</span>
  <span class="kt">Description:</span> <span class="kt">Has</span> <span class="n">the</span> <span class="n">base</span> <span class="n">package</span> <span class="n">been</span> <span class="n">split</span> <span class="n">up</span><span class="o">?</span>
  <span class="kt">Default:</span> <span class="kt">True</span>

<span class="kt">Flag</span> <span class="n">bytestring</span><span class="o">-</span><span class="kr">in</span><span class="o">-</span><span class="n">base</span>
  <span class="kt">Description:</span> <span class="kt">Is</span> <span class="kt">ByteString</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">base</span> <span class="n">or</span> <span class="n">bytestring</span> <span class="n">package</span><span class="o">?</span>
  <span class="kt">Default:</span> <span class="kt">False</span>
</pre></div>
</div>
<ul class="simple">
<li><p>配置功能在 Cabal 的 1.2 版本中引入，因此指定 Cabal 版本不能低于 1.2。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">split-base</span></code> 标识的含义不言而喻。[Forec 译注：该标识表示 <code class="docutils literal notranslate"><span class="pre">base</span></code> 包是否被划分]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bytestring-in-base</span></code> 标识源于一段更为曲折的历史：<code class="docutils literal notranslate"><span class="pre">bytestring</span></code> 包在创建之初是和 GHC 6.4 捆绑的，并且它始终独立于 <code class="docutils literal notranslate"><span class="pre">base</span></code> 包；在 GHC 6.6 中，它被合并到了 <code class="docutils literal notranslate"><span class="pre">base</span></code> 包中；到了 GHC 6.8.1 版本，它又再次被独立出去。</p></li>
<li><p>上面这些标识对构建包的开发者来说通常是不可见的，因为 Cabal 会自动处理它们。在我们进行下一步分析前，了解它们能够帮助理解 <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> 文件中 <code class="docutils literal notranslate"><span class="pre">Library</span></code> 部分开头的内容。</p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Library</span>
  <span class="kr">if</span> <span class="n">flag</span><span class="p">(</span><span class="n">bytestring</span><span class="o">-</span><span class="kr">in</span><span class="o">-</span><span class="n">base</span><span class="p">)</span>
        <span class="c1">-- bytestring was in base-2.0 and 2.1.1</span>
        <span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="o">&lt;</span> <span class="mf">2.2</span>
  <span class="kr">else</span>
        <span class="c1">-- in base 1.0 and 3.0, bytestring is a separate package</span>
        <span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="o">||</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bytestring</span> <span class="o">&gt;=</span> <span class="mf">0.9</span>

  <span class="kr">if</span> <span class="n">flag</span><span class="p">(</span><span class="n">split</span><span class="o">-</span><span class="n">base</span><span class="p">)</span>
        <span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">array</span>
  <span class="kr">else</span>
        <span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="mf">3.0</span>
</pre></div>
</div>
<p>Cabal 使用标识的默认值来创建包描述（该标识的默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ）。如果当前的配置能够构建成功（比如所有需要的包版本都可用）则这个配置将被采用，否则 Cabal 将尝试多种方式组合标识，直到它寻找到一个能够构建成功的配置，又或者所有备选的配置都无法生效为止。</p>
<p>例如，如果我们将 <code class="docutils literal notranslate"><span class="pre">split-base</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytestring-in-base</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，Cabal 会选择以下的包依赖项：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="o">&lt;</span> <span class="mf">2.2</span>
<span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">array</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">base</span></code> 包的版本无法同时又高于 3.0 又低于 2.2，所以 Cabal 出于一致性考虑会拒绝这个配置。对于现代版本的 GHC，在几次尝试后，它将产生如下配置：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in base 1.0 and 3.0, bytestring is a separate package</span>
<span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="o">||</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bytestring</span> <span class="o">&gt;=</span> <span class="mf">0.9</span>
<span class="kt">Build</span><span class="o">-</span><span class="kt">Depends:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">array</span>
</pre></div>
</div>
<p>在运行 <code class="docutils literal notranslate"><span class="pre">runhaskell</span> <span class="pre">Setup</span> <span class="pre">configure</span></code> 时，我们可以使用 <code class="docutils literal notranslate"><span class="pre">--flag</span></code> 选项手动指定各标识的值，虽然实际中很少需要这么做。</p>
</section>
<section id="c">
<h3>编译选项和针对 C 的接口<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>下面让我们继续分析 <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> 文件，并完成与 Haskell 相关的剩余细节。如果在构建过程中启用分析，我们希望所有的顶级函数都显示在分析的输出中。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GHC</span><span class="o">-</span><span class="kt">Prof</span><span class="o">-</span><span class="kt">Options:</span> <span class="o">-</span><span class="n">auto</span><span class="o">-</span><span class="n">all</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Other-Modules</span></code> 属性列出了库中私有的 Haskell 模块，这些模块对使用此包的代码不可见。</p>
<p>在 GHC 构建这个包时，Cabal 会将 <code class="docutils literal notranslate"><span class="pre">GHC-Options</span></code> 属性中的选项传递给编译器。</p>
<p><code class="docutils literal notranslate"><span class="pre">-O2</span></code> 选项使 GHC 尽可能地优化我们的代码。不加以优化编译出的代码效率很低，所以在编译生产代码时应当始终使用 <code class="docutils literal notranslate"><span class="pre">-O2</span></code> 选项。</p>
<p>为了写出更清晰的代码，我们通常添加 <code class="docutils literal notranslate"><span class="pre">-Wall</span></code> 选项，这个选项会启用 GHC 的所有警告。这将导致 GHC 在遇到潜在问题（例如重叠的模式匹配、未使用的函数参数等其它潜在障碍）时提出警告。尽管忽略这些警告一般是安全的，但我们应该尽量完善代码以消除它们。这一点小小的努力，将催生更容易阅读和维护的代码。</p>
<p>普通情况下 GHC 会直接生成汇编语言代码，而在使用 <code class="docutils literal notranslate"><span class="pre">-fvia-C</span></code> 编译时，GHC 会生成 C 语言代码并使用系统的 C 编译器来编译它。这会减慢编译速度，但有时 C 编译器能够进一步改善 GHC 优化的代码，所以这也是值得的。</p>
<p>我们这里提到 <code class="docutils literal notranslate"><span class="pre">-fiva-C</span></code> 主要是为了展示如何使用它编译。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">C</span><span class="o">-</span><span class="kt">Sources:</span>        <span class="n">cbits</span><span class="o">/</span><span class="n">lookup3</span><span class="o">.</span><span class="n">c</span>
<span class="kt">CC</span><span class="o">-</span><span class="kt">Options:</span>       <span class="o">-</span><span class="kt">O3</span>
<span class="kt">Include</span><span class="o">-</span><span class="kt">Dirs:</span>     <span class="n">cbits</span>
<span class="kt">Includes:</span>         <span class="n">lookup3</span><span class="o">.</span><span class="n">h</span>
<span class="kt">Install</span><span class="o">-</span><span class="kt">Includes:</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">C-Sources</span></code> 属性，我们只需要列出必须编译到库中的文件。 <code class="docutils literal notranslate"><span class="pre">CC-Options</span></code> 属性包含了提供给 C 编译器的选项（其中选项 <code class="docutils literal notranslate"><span class="pre">-O3</span></code> 用于指定最高级别的优化）。因为对 Jenkins 散列函数的 FFI 绑定引用了 <code class="docutils literal notranslate"><span class="pre">lookup3.h</span></code> 头文件，我们需要告诉 Cabal 在哪里可以找到该头文件。<code class="docutils literal notranslate"><span class="pre">Install-Includes</span></code> 用来告诉 Cabal 安装这个头文件，否则在构建时客户端代码将无法找到头文件。</p>
<p>[Forec 译注：遗憾的是，在较新版本的 GHC 中 <code class="docutils literal notranslate"><span class="pre">-fvia-C</span></code> 不会产生任何作用，并且它将在未来的 GHC 发布中被移除。所以本节关于 <code class="docutils literal notranslate"><span class="pre">-fvia-C</span></code> 选项的介绍已经成为历史了。]</p>
</section>
</section>
<section id="quickcheck">
<h2>用 QuickCheck 测试<a class="headerlink" href="#quickcheck" title="Permalink to this headline">¶</a></h2>
<p>在进一步考虑性能之前，我们要确保布隆过滤器的正确性。使用 QuickCheck 可以轻松测试一些基本的属性。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="cm">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Hash</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word8</span><span class="p">,</span> <span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Random</span> <span class="p">(</span><span class="kt">Random</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="kt">RandomGen</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Test.QuickCheck</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">BloomFilter.Easy</span> <span class="k">as</span> <span class="n">B</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">Strict</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">Lazy</span>
</pre></div>
</div>
<p>普通的 <code class="docutils literal notranslate"><span class="pre">quickCheck</span></code> 函数对布隆过滤器属性的测试帮助不大，因为它产生的 100 个测试输入样例无法完整覆盖布隆过滤器的功能。这里我们编写自己的测试函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">handyCheck</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handyCheck</span> <span class="n">limit</span> <span class="ow">=</span> <span class="n">check</span> <span class="n">defaultConfig</span> <span class="p">{</span>
                                         <span class="n">configMaxTest</span> <span class="ow">=</span> <span class="n">limit</span>
                                   <span class="p">,</span> <span class="n">configEvery</span>   <span class="ow">=</span> <span class="nf">\</span><span class="kr">_</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;&quot;</span>
                                   <span class="p">}</span>
</pre></div>
</div>
<p>[Forec 译注：在较新版本的 QuickCheck 中，上面的代码应该写成：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handyCheck</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handyCheck</span> <span class="n">limit</span> <span class="ow">=</span> <span class="n">quickCheckWith</span> <span class="p">(</span><span class="n">stdArgs</span> <span class="p">{</span> <span class="n">maxSuccess</span> <span class="ow">=</span> <span class="n">limit</span> <span class="p">)</span>
</pre></div>
</div>
<p>]</p>
<p>下面我们要完成的第一个任务是确保：无论用户选择多大的容错率，只要向布隆过滤器添加了一个任意值，则之后针对该值的成员测试都应得到 “值已存在” 的结果。</p>
<p>我们将使用 <code class="docutils literal notranslate"><span class="pre">easyList</span></code> 函数来创建一个布隆过滤器。 <code class="docutils literal notranslate"><span class="pre">Double</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Random</span></code> 实例能够生成 0 到 1 之间的随机数，因此 QuickCheck 可以提供任意大小的错误率。</p>
<p>然而，测试生成的错误率应当排除 0 和 1。QuickCheck 提供了两种方法：</p>
<ul class="simple">
<li><p>通过结构：指定要生成的有效值的范围。QuickCheck 为此提供了 <code class="docutils literal notranslate"><span class="pre">forAll</span></code> 组合器。</p></li>
<li><p>通过过滤：当 QuickCheck 生成一个任意值时，用 <code class="docutils literal notranslate"><span class="pre">(=~&gt;)</span></code> 运算符过滤掉不符合标准的值。如果布隆过滤器通过这种方式拒绝一个输入值，测试将显示成功。</p></li>
</ul>
<p>如果以上两个方法都可以选择，那么最好采用通过结构的方法：假设 QuickCheck 生成了 1000 个任意值，其中 800 个由于某些原因被过滤掉。看起来我们似乎运行了 1000 次测试，但实际上只有 200 次做了有意义的事。</p>
<p>出于这个原因，当需要产生错误率时，我们不会去消除 QuickCheck 提供的 0 或 1，而是在一个始终有效的区间中构造值：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">falsePositive</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="kt">Double</span>
<span class="nf">falsePositive</span> <span class="ow">=</span> <span class="n">choose</span> <span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="kr">where</span> <span class="n">epsilon</span> <span class="ow">=</span> <span class="mf">1e-6</span>

<span class="p">(</span><span class="o">=~&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">k</span> <span class="o">=~&gt;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">either</span> <span class="p">(</span><span class="n">const</span> <span class="kt">True</span><span class="p">)</span> <span class="n">f</span> <span class="n">k</span>

<span class="nf">prop_one_present</span> <span class="kr">_</span> <span class="n">elt</span> <span class="ow">=</span>
        <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
          <span class="kt">B</span><span class="o">.</span><span class="n">easyList</span> <span class="n">errRate</span> <span class="p">[</span><span class="n">elt</span><span class="p">]</span> <span class="o">=~&gt;</span> <span class="nf">\</span><span class="n">filt</span> <span class="ow">-&gt;</span>
                <span class="n">elt</span> <span class="p">`</span><span class="kt">B</span><span class="o">.</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span>
</pre></div>
</div>
<p>[Forec 译注：原著作者似乎在这里犯了一点错误，根据代码， <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的型别声明应为 <code class="docutils literal notranslate"><span class="pre">(Hashable</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Property</span></code> ，但这无法通过编译，因为 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的第一个参数 <code class="docutils literal notranslate"><span class="pre">_</span></code> 隐藏着对类型 <code class="docutils literal notranslate"><span class="pre">t</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的约束，它们二者必须相等。有两种解决方法：一是不指定这个多余的 <code class="docutils literal notranslate"><span class="pre">_</span></code> 参数，二是将型别声明显式地指定为 <code class="docutils literal notranslate"><span class="pre">(Hashable</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Property</span></code> 。]</p>
<p>组合器 <code class="docutils literal notranslate"><span class="pre">(=~&gt;)</span></code> 过滤了 <code class="docutils literal notranslate"><span class="pre">easyList</span></code> 失败的情况：如果失败了，测试会自动通过。</p>
<section id="id17">
<h3>多态测试<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>[Forec 译注：以下几节，原著作者给出的代码在新版本 GHC 中无法通过编译，如需在 GHC 中运行，请按照译注中的说明修改对应文件。译文仅对代码和部分运行结果进行一定修正。]</p>
<p>QuickCheck 要求属性必须是单型的。鉴于目前有多种可散列类型需要测试，我们有必要设计一个方法，避免对每种类型都编写同样的测试。</p>
<p>注意， <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 这个函数是多态的，但它忽略了第一个参数。我们可以借助这一点模拟单型性质：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>ghci&gt; :load BloomCheck
BloomCheck.hs:9:17:
        Could not find module `BloomFilter.Easy&#39;:
          Use -v to see a list of the files searched for.
Failed, modules loaded: none.
ghci&gt; :t prop_one_present
&lt;interactive&gt;:1:0: Not in scope: `prop_one_present&#39;
ghci&gt; :t prop_one_present (undefined :: Int)
&lt;interactive&gt;:1:0: Not in scope: `prop_one_present&#39;
</pre></div>
</div>
<p>[Forec 译注：原著给出的代码无法正确运行，要想正确运行需要对 <code class="docutils literal notranslate"><span class="pre">BloomCheck.hs</span></code> 做如下修改：</p>
<ul class="simple">
<li><p>按上面译注里所述，将 <code class="docutils literal notranslate"><span class="pre">handyCheck</span> <span class="pre">limit</span></code> 部分修改；</p></li>
<li><p>移除 <code class="docutils literal notranslate"><span class="pre">Random</span> <span class="pre">Word8</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Arbitary</span> <span class="pre">Word8</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Random</span> <span class="pre">Word32</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">Arbitary</span> <span class="pre">Word32</span></code> 的实例；</p></li>
<li><p>删除 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Lazy.ByteString</span></code> 实例中 <code class="docutils literal notranslate"><span class="pre">coarbitrary</span></code> 所属行；</p></li>
<li><p>删除 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Strict.ByteString</span></code> 实例中 <code class="docutils literal notranslate"><span class="pre">coarbitrary</span></code> 所属行；</p></li>
</ul>
<p>]</p>
<p>任何值都可以作为 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的第一个参数。第二个参数中第一个元素的类型需要和第一个参数保持一致。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">5000</span> <span class="o">$</span> <span class="n">prop_one_present</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_one_present&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">5000</span> <span class="o">$</span> <span class="n">prop_one_present</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Double</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_one_present&#39;</span>
</pre></div>
</div>
<p>[Forec 译注：请留意本节译注中对 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的修正，我们需要显式声明 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的类型，或者移除 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的 <code class="docutils literal notranslate"><span class="pre">_</span></code> 参数。
这里采取第二种方法，定义函数 <code class="docutils literal notranslate"><span class="pre">prop_one_present'</span></code> ，它与 <code class="docutils literal notranslate"><span class="pre">prop_one_present</span></code> 的唯一区别在于它没有匿名参数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_one_present&#39;</span> <span class="n">elt</span> <span class="ow">=</span>
        <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
        <span class="kt">B</span><span class="o">.</span><span class="n">easyList</span> <span class="n">errRate</span> <span class="p">[</span><span class="n">elt</span><span class="p">]</span> <span class="o">=~&gt;</span> <span class="nf">\</span><span class="n">filt</span> <span class="ow">-&gt;</span>
        <span class="n">elt</span> <span class="p">`</span><span class="kt">B</span><span class="o">.</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span>
</pre></div>
</div>
<p>载入修改后的文件，并显式指定 <code class="docutils literal notranslate"><span class="pre">prop_one_present'</span></code> 的型别：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">2</span> <span class="o">$</span> <span class="p">(</span><span class="n">prop_one_present&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Property</span><span class="p">)</span>
<span class="kt">Passed:</span>
<span class="s">&quot;&quot;</span>
<span class="mf">7.053216229843191e-2</span>
<span class="kt">Passed:</span>
<span class="s">&quot;</span><span class="se">\n</span><span class="s">9UP&#39;</span><span class="se">\161</span><span class="s">O%~S&quot;</span>
<span class="mf">0.5021342445896073</span>
</pre></div>
</div>
<p>本节剩余部分在 GHCI 中执行 <code class="docutils literal notranslate"><span class="pre">handyCheck</span></code> 指令均需做类似的修正。下面的译文不再对原著的运行结果予以更正。
]</p>
<p>在向布隆过滤器添加多个元素之后，这些元素应该都能够被识别出来：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">prop_all_present</span> <span class="kr">_</span> <span class="n">xs</span> <span class="ow">=</span>
        <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
          <span class="kt">B</span><span class="o">.</span><span class="n">easyList</span> <span class="n">errRate</span> <span class="n">xs</span> <span class="o">=~&gt;</span> <span class="nf">\</span><span class="n">filt</span> <span class="ow">-&gt;</span>
                <span class="n">all</span> <span class="p">(`</span><span class="kt">B</span><span class="o">.</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<p>测试依然成功：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">2000</span> <span class="o">$</span> <span class="n">prop_all_present</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_all_present</span>
</pre></div>
</div>
</section>
<section id="bytestring">
<h3>为 ByteString 编写任意实例<a class="headerlink" href="#bytestring" title="Permalink to this headline">¶</a></h3>
<p>QuickCheck 库没有为 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型提供 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 的实例，因此我们必须自己编写。 <code class="docutils literal notranslate"><span class="pre">pack</span></code> 函数可基于 <code class="docutils literal notranslate"><span class="pre">[Word8]</span></code> 创建一个 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">arbitrary</span> <span class="ow">=</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">pack</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">arbitrary</span>
        <span class="n">coarbitrary</span> <span class="ow">=</span> <span class="n">coarbitrary</span> <span class="o">.</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">unpack</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">arbitrary</span> <span class="ow">=</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">pack</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">arbitrary</span>
        <span class="n">coarbitrary</span> <span class="ow">=</span> <span class="n">coarbitrary</span> <span class="o">.</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">unpack</span>
</pre></div>
</div>
<p>[Forec 译注：原著编写时的 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 类型类到今天已经发生了变化， <code class="docutils literal notranslate"><span class="pre">coarbitrary</span></code> 函数现在属于 <code class="docutils literal notranslate"><span class="pre">CoArbitrary</span></code> 类型类。上面的代码需要修正为：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
<span class="nf">arbitrary</span> <span class="ow">=</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">pack</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">arbitrary</span>

<span class="kr">instance</span> <span class="kt">CoArbitrary</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
<span class="nf">coarbitrary</span> <span class="ow">=</span> <span class="n">coarbitrary</span> <span class="o">.</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">unpack</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Strict.ByteString</span></code> 也要做同样的修改。
]</p>
<p>QuickCheck 中还缺少针对 <code class="docutils literal notranslate"><span class="pre">Data.Word</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Data.Int</span></code> 中固定宽度类型的 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 实例。我们至少需要为 <code class="docutils literal notranslate"><span class="pre">Word8</span></code> 实现 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 实例：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="kr">instance</span> <span class="kt">Random</span> <span class="kt">Word8</span> <span class="kr">where</span>
  <span class="n">randomR</span> <span class="ow">=</span> <span class="n">integralRandomR</span>
  <span class="n">random</span> <span class="ow">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="n">minBound</span><span class="p">,</span> <span class="n">maxBound</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Word8</span> <span class="kr">where</span>
        <span class="n">arbitrary</span> <span class="ow">=</span> <span class="n">choose</span> <span class="p">(</span><span class="n">minBound</span><span class="p">,</span> <span class="n">maxBound</span><span class="p">)</span>
        <span class="n">coarbitrary</span> <span class="ow">=</span> <span class="n">integralCoarbitrary</span>
</pre></div>
</div>
<p>[Forec 译注： <code class="docutils literal notranslate"><span class="pre">Word8</span></code> 的实例不需要定义。当前的 <code class="docutils literal notranslate"><span class="pre">QuickCheck</span></code> 库已经默认实现了这些实例。]</p>
<p>为这些实例编写几个通用函数，以便在之后为其他整型类型编写实例时重用它们：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">integralCoarbitrary</span> <span class="n">n</span> <span class="ow">=</span>
        <span class="n">variant</span> <span class="o">$</span> <span class="kr">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span> <span class="kr">else</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">n</span>

<span class="nf">integralRandomR</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">g</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">randomR</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="n">g</span> <span class="kr">of</span>
                                                        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">h</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="kr">where</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">a</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">,</span>
                                   <span class="n">fromIntegral</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Random</span> <span class="kt">Word32</span> <span class="kr">where</span>
  <span class="n">randomR</span> <span class="ow">=</span> <span class="n">integralRandomR</span>
  <span class="n">random</span> <span class="ow">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="n">minBound</span><span class="p">,</span> <span class="n">maxBound</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Word32</span> <span class="kr">where</span>
        <span class="n">arbitrary</span> <span class="ow">=</span> <span class="n">choose</span> <span class="p">(</span><span class="n">minBound</span><span class="p">,</span> <span class="n">maxBound</span><span class="p">)</span>
        <span class="n">coarbitrary</span> <span class="ow">=</span> <span class="n">integralCoarbitrary</span>
</pre></div>
</div>
<p>[Forec 译注：上面这部分代码也是不需要的，<code class="docutils literal notranslate"><span class="pre">QuickCheck</span></code> 库已经实现了它们。]</p>
<p>创建了这些 <code class="docutils literal notranslate"><span class="pre">Arbitary</span></code> 实例后，我们就可以在 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型上尝试现有的属性：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_one_present</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_one_present&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">49</span><span class="kt">:</span>
        <span class="kt">Failed</span> <span class="n">to</span> <span class="n">load</span> <span class="n">interface</span> <span class="n">for</span> <span class="p">`</span><span class="kt">Lazy&#39;:</span>
          <span class="kt">Use</span> <span class="o">-</span><span class="n">v</span> <span class="n">to</span> <span class="n">see</span> <span class="n">a</span> <span class="n">list</span> <span class="kr">of</span> <span class="n">the</span> <span class="n">files</span> <span class="n">searched</span> <span class="n">for</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_all_present</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_all_present&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">49</span><span class="kt">:</span>
        <span class="kt">Failed</span> <span class="n">to</span> <span class="n">load</span> <span class="n">interface</span> <span class="n">for</span> <span class="p">`</span><span class="kt">Strict&#39;:</span>
          <span class="kt">Use</span> <span class="o">-</span><span class="n">v</span> <span class="n">to</span> <span class="n">see</span> <span class="n">a</span> <span class="n">list</span> <span class="kr">of</span> <span class="n">the</span> <span class="n">files</span> <span class="n">searched</span> <span class="n">for</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3>推荐大小是正确的吗？<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>随着待运行测试数量的增加，用于测试 <code class="docutils literal notranslate"><span class="pre">easyList</span></code> 性能的开销也在快速增长。我们希望输入数据规模对 <code class="docutils literal notranslate"><span class="pre">easyList</span></code> 的性能没有影响。直接测试是不现实的，所以这里使用另一个问题来衡量：面对极端的输入规模时， <code class="docutils literal notranslate"><span class="pre">suggestSizing</span></code> 是否仍能给出敏感的数组大小以及哈希值？</p>
<p>检查这一特性略微有些棘手：我们需要同时改变期望的错误率和预期容量。根据 <code class="docutils literal notranslate"><span class="pre">sizings</span></code> 函数给出的结果，这些值之间的关系较难预测。</p>
<p>我们可以尝试忽略复杂性：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">prop_suggest_try1</span> <span class="ow">=</span>
  <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
        <span class="n">forAll</span> <span class="p">(</span><span class="n">choose</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Word32</span><span class="p">))</span> <span class="o">$</span> <span class="nf">\</span><span class="n">cap</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">cap</span><span class="p">)</span> <span class="n">errRate</span> <span class="kr">of</span>
                <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
                <span class="kt">Right</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span> <span class="o">&lt;</span> <span class="n">maxBound</span> <span class="o">&amp;&amp;</span> <span class="n">hashes</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>正如我们所料，这一做法只会带来一个没有实际作用的测试：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_suggest_try1</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_suggest_try1&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_suggest_try1</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_suggest_try1&#39;</span>
</pre></div>
</div>
<p>[Forec 译注：一个仅供参考的运行结果如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_suggest_try1</span>
<span class="kt">Passed:</span>
<span class="mf">0.840272094122386</span>
<span class="mi">1533634864</span>
<span class="kt">Failed:</span>
<span class="mf">0.13172750223946617</span>
<span class="mi">3002287708</span>
<span class="o">***</span> <span class="kt">Failed</span><span class="o">!</span> <span class="kt">Falsifiable</span> <span class="p">(</span><span class="n">after</span> <span class="mi">2</span> <span class="n">tests</span><span class="p">)</span><span class="kt">:</span>
<span class="mf">0.13172750223946617</span>
<span class="mi">3002287708</span>
</pre></div>
</div>
<p>]</p>
<p>将 QuickCheck 打印的反例交给 <code class="docutils literal notranslate"><span class="pre">suggestSizing</span></code> 时，我们发现这些输入被拒绝了，因为它们会导致一个过于庞大的位数组。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="mi">1678125842</span> <span class="mf">8.501133057303545e-3</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
        <span class="kt">Failed</span> <span class="n">to</span> <span class="n">load</span> <span class="n">interface</span> <span class="n">for</span> <span class="p">`</span><span class="kt">B&#39;:</span>
          <span class="kt">Use</span> <span class="o">-</span><span class="n">v</span> <span class="n">to</span> <span class="n">see</span> <span class="n">a</span> <span class="n">list</span> <span class="kr">of</span> <span class="n">the</span> <span class="n">files</span> <span class="n">searched</span> <span class="n">for</span><span class="o">.</span>
</pre></div>
</div>
<p>[Forec 译注：运行结果如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="mi">1678125842</span> <span class="mf">8.501133057303545e-3</span>
<span class="kt">Left</span> <span class="s">&quot;capacity too large&quot;</span>
</pre></div>
</div>
<p>]</p>
<p>由于无法预测哪些组合会导致此问题，我们只能通过限制大小和错误率来防止异常：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">prop_suggest_try2</span> <span class="ow">=</span>
        <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
          <span class="n">forAll</span> <span class="p">(</span><span class="n">choose</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">fromIntegral</span> <span class="n">maxWord32</span><span class="p">))</span> <span class="o">$</span> <span class="nf">\</span><span class="n">cap</span> <span class="ow">-&gt;</span>
                <span class="kr">let</span> <span class="n">bestSize</span> <span class="ow">=</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">minimum</span> <span class="o">$</span> <span class="kt">B</span><span class="o">.</span><span class="n">sizings</span> <span class="n">cap</span> <span class="n">errRate</span>
                <span class="kr">in</span> <span class="n">bestSize</span> <span class="o">&lt;</span> <span class="n">fromIntegral</span> <span class="n">maxWord32</span> <span class="o">==&gt;</span>
                   <span class="n">either</span> <span class="p">(</span><span class="n">const</span> <span class="kt">False</span><span class="p">)</span> <span class="n">sane</span> <span class="o">$</span> <span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="n">cap</span> <span class="n">errRate</span>
  <span class="kr">where</span> <span class="n">sane</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span> <span class="o">&lt;</span> <span class="n">maxBound</span> <span class="o">&amp;&amp;</span> <span class="n">hashes</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">maxWord32</span> <span class="ow">=</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Word32</span>
</pre></div>
</div>
<p>对其加以测试，看起来效果不错：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_suggest_try2</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">18</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_suggest_try2&#39;</span>
</pre></div>
</div>
<p>[Forec 译注：预期的运行结果为：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">prop_suggest_try2</span>
<span class="o">+++</span> <span class="kt">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">1000</span> <span class="n">tests</span><span class="o">.</span>
</pre></div>
</div>
<p>]</p>
<p>在过大的测试中，许多组合都被过滤掉了：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">10000</span> <span class="o">$</span> <span class="n">prop_suggest_try2</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">19</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_suggest_try2&#39;</span>
</pre></div>
</div>
<p>为了解决此问题，我们要尝试降低生成无效输入的可能性：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/BloomCheck.hs</span>
<span class="nf">prop_suggestions_sane</span> <span class="ow">=</span>
        <span class="n">forAll</span> <span class="n">falsePositive</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errRate</span> <span class="ow">-&gt;</span>
          <span class="n">forAll</span> <span class="p">(</span><span class="n">choose</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">fromIntegral</span> <span class="n">maxWord32</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">8</span><span class="p">))</span> <span class="o">$</span> <span class="nf">\</span><span class="n">cap</span> <span class="ow">-&gt;</span>
                <span class="kr">let</span> <span class="n">size</span> <span class="ow">=</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">minimum</span> <span class="o">$</span> <span class="kt">B</span><span class="o">.</span><span class="n">sizings</span> <span class="n">cap</span> <span class="n">errRate</span>
                <span class="kr">in</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">fromIntegral</span> <span class="n">maxWord32</span> <span class="o">==&gt;</span>
                   <span class="n">either</span> <span class="p">(</span><span class="n">const</span> <span class="kt">False</span><span class="p">)</span> <span class="n">sane</span> <span class="o">$</span> <span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="n">cap</span> <span class="n">errRate</span>
  <span class="kr">where</span> <span class="n">sane</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span> <span class="o">&lt;</span> <span class="n">maxBound</span> <span class="o">&amp;&amp;</span> <span class="n">hashes</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">maxWord32</span> <span class="ow">=</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Word32</span>
</pre></div>
</div>
<p>最终，我们得到了更加健壮的性能：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handyCheck</span> <span class="mi">40000</span> <span class="o">$</span> <span class="n">prop_suggestions_sane</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">handyCheck&#39;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">19</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">prop_suggestions_sane&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h2>性能分析和调优<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>我们可以将程序通过 <code class="docutils literal notranslate"><span class="pre">QuickCheck</span></code> 测试视为一条证明代码正确的 “基准线”。在调整性能时，随时重新运行测试能够防止修改过程中不小心导致的破坏。</p>
<p>第一步，编写一个用于计时的小程序：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/WordTest.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span> <span class="p">(</span><span class="kt">NFData</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM_</span><span class="p">,</span> <span class="nf">mapM_</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">BloomFilter.Easy</span> <span class="k">as</span> <span class="n">B</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Char8</span> <span class="k">as</span> <span class="n">BS</span>
<span class="kr">import</span> <span class="nn">Data.Time.Clock</span> <span class="p">(</span><span class="nf">diffUTCTime</span><span class="p">,</span> <span class="nf">getCurrentTime</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Exit</span> <span class="p">(</span><span class="nf">exitFailure</span><span class="p">)</span>

<span class="nf">timed</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">timed</span> <span class="n">desc</span> <span class="n">act</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">start</span> <span class="ow">&lt;-</span> <span class="n">getCurrentTime</span>
        <span class="n">ret</span> <span class="ow">&lt;-</span> <span class="n">act</span>
        <span class="n">end</span> <span class="ow">&lt;-</span> <span class="n">rnf</span> <span class="n">ret</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">getCurrentTime</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="p">(</span><span class="n">diffUTCTime</span> <span class="n">end</span> <span class="n">start</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; to &quot;</span> <span class="o">++</span> <span class="n">desc</span>
        <span class="n">return</span> <span class="n">ret</span>

<span class="kr">instance</span> <span class="kt">NFData</span> <span class="kt">BS</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">rnf</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="kt">Bloom</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">rnf</span> <span class="n">filt</span> <span class="ow">=</span> <span class="kt">B</span><span class="o">.</span><span class="n">length</span> <span class="n">filt</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>
</pre></div>
</div>
<p>[Forec 译注：编译过时的代码总是不尽人意，需要做如下修改：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NFData</span></code> 已经被移动到 <code class="docutils literal notranslate"><span class="pre">Control.DeepSeq</span></code> ，因此需将首行的 <code class="docutils literal notranslate"><span class="pre">import</span></code> 修改为 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Control.DeepSeq</span> <span class="pre">(NFData(..))</span></code> ；</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">rdeepsep</span></code> ，具体原因可参考 <a class="reference external" href="http://hackage.haskell.org/package/parallel-2.2.0.1/docs/Control-Parallel-Strategies.html">http://hackage.haskell.org/package/parallel-2.2.0.1/docs/Control-Parallel-Strategies.html</a> ；</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">GHC</span> <span class="pre">7.6</span></code> 之后，所有的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 均已成为 <code class="docutils literal notranslate"><span class="pre">NFData</span></code> 的实例，所以上面针对 <code class="docutils literal notranslate"><span class="pre">BS.ByteString</span></code> 的实例定义需要被移除。</p></li>
</ul>
<p>]</p>
<p>上面的小程序中，我们使用了 24 章中 “将求值从算法中分离” 一节介绍的 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 函数来实现简单的时间约束。输出用时这一动作能够确保计算完成，从而准确地评估运算成本。</p>
<p>[Note: 24 章该节尚未翻译，翻译完成后应当将此处替换为 reference。]</p>
<p>主程序根据指定文件创建一个布隆过滤器，它将文件中每一行视为一个要添加到布隆过滤器中的元素：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: examples/WordTest.hs</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
  <span class="kr">let</span> <span class="n">files</span> <span class="o">|</span> <span class="n">null</span> <span class="n">args</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;/usr/share/dict/words&quot;</span><span class="p">]</span>
                        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">args</span>
  <span class="n">forM_</span> <span class="n">files</span> <span class="o">$</span> <span class="nf">\</span><span class="n">file</span> <span class="ow">-&gt;</span> <span class="kr">do</span>

        <span class="n">words</span> <span class="ow">&lt;-</span> <span class="n">timed</span> <span class="s">&quot;read words&quot;</span> <span class="o">$</span>
          <span class="kt">BS</span><span class="o">.</span><span class="n">lines</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">BS</span><span class="o">.</span><span class="n">readFile</span> <span class="n">file</span>

        <span class="kr">let</span> <span class="n">len</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">words</span>
                <span class="n">errRate</span> <span class="ow">=</span> <span class="mf">0.01</span>

        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="n">len</span> <span class="o">++</span> <span class="s">&quot; words&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;suggested sizings: &quot;</span> <span class="o">++</span>
                           <span class="n">show</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="n">suggestSizing</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="n">errRate</span><span class="p">)</span>

        <span class="n">filt</span> <span class="ow">&lt;-</span> <span class="n">timed</span> <span class="s">&quot;construct filter&quot;</span> <span class="o">$</span>
          <span class="kr">case</span> <span class="kt">B</span><span class="o">.</span><span class="n">easyList</span> <span class="n">errRate</span> <span class="n">words</span> <span class="kr">of</span>
                <span class="kt">Left</span> <span class="n">errmsg</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Error: &quot;</span> <span class="o">++</span> <span class="n">errmsg</span>
                  <span class="n">exitFailure</span>
                <span class="kt">Right</span> <span class="n">filt</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">filt</span>

        <span class="n">timed</span> <span class="s">&quot;query every element&quot;</span> <span class="o">$</span>
          <span class="n">mapM_</span> <span class="n">print</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="p">(`</span><span class="kt">B</span><span class="o">.</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span><span class="p">))</span> <span class="n">words</span>
</pre></div>
</div>
<p>[Forec 译注：显然，原著给出的程序需要在类 Linux 环境下运行，并且 <code class="docutils literal notranslate"><span class="pre">/usr/share/dict</span></code> 路径下要存在 <code class="docutils literal notranslate"><span class="pre">words</span></code> 文件，该文件用于为程序提供输入。]</p>
<p><code class="docutils literal notranslate"><span class="pre">timed</span></code> 函数用来计算程序执行中三个不同阶段的成本；读取并按行分割数据、 填充布隆过滤器和查询其中的每个元素。</p>
<p>如果将上述程序编译运行几次，就可以发现执行时间比较长，但多次运行之间的时长差距很小。至此，我们创建了一个看似可信的微基准测试：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="kt">O2</span>  <span class="c1">--make WordTest</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="kt">Linking</span> <span class="kt">WordTest</span> <span class="o">...</span>
<span class="o">$</span> <span class="o">./</span><span class="kt">WordTest</span>
<span class="mf">0.196347</span><span class="n">s</span> <span class="n">to</span> <span class="n">read</span> <span class="n">words</span>
<span class="mi">479829</span> <span class="n">words</span>
<span class="mf">1.063537</span><span class="n">s</span> <span class="n">to</span> <span class="n">construct</span> <span class="n">filter</span>
<span class="mi">4602978</span> <span class="n">bits</span>
<span class="mf">0.766899</span><span class="n">s</span> <span class="n">to</span> <span class="n">query</span> <span class="n">every</span> <span class="n">element</span>
<span class="o">$</span> <span class="o">./</span><span class="kt">WordTest</span>
<span class="mf">0.179284</span><span class="n">s</span> <span class="n">to</span> <span class="n">read</span> <span class="n">words</span>
<span class="mi">479829</span> <span class="n">words</span>
<span class="mf">1.069363</span><span class="n">s</span> <span class="n">to</span> <span class="n">construct</span> <span class="n">filter</span>
<span class="mi">4602978</span> <span class="n">bits</span>
<span class="mf">0.780079</span><span class="n">s</span> <span class="n">to</span> <span class="n">query</span> <span class="n">every</span> <span class="n">element</span>
</pre></div>
</div>
<section id="id20">
<h3>配置驱动的性能调优<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>下面重新构建这个程序，并在启用分析的情况下运行，以观察哪些调优能够改善它的性能。</p>
<p>因为此前我们已经构建了 <code class="docutils literal notranslate"><span class="pre">WordTest</span></code> 且没有对源码做任何改动，如果仅仅重新运行 GHC，GHC 会认为已存在的二进制文件足够新，从而跳过重新构建。我们必须强制重新构建此程序，这里可以通过编辑源文件以更新文件系统来实现。</p>
<p>[Forec 译注：也可以使用 <code class="docutils literal notranslate"><span class="pre">=fforce-recomp</span></code> 标识，它会强迫 GHC 重新构建。]</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">touch</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">hs</span>
<span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="kt">O2</span> <span class="o">-</span><span class="n">prof</span> <span class="o">-</span><span class="n">auto</span><span class="o">-</span><span class="n">all</span> <span class="c1">--make WordTest</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="kt">Linking</span> <span class="kt">WordTest</span> <span class="o">...</span>

<span class="o">$</span> <span class="o">./</span><span class="kt">WordTest</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="n">p</span>
<span class="mf">0.322675</span><span class="n">s</span> <span class="n">to</span> <span class="n">read</span> <span class="n">words</span>
<span class="mi">479829</span> <span class="n">words</span>
<span class="nf">suggested</span> <span class="n">sizings</span><span class="kt">:</span> <span class="kt">Right</span> <span class="p">(</span><span class="mi">4602978</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="mf">2.475339</span><span class="n">s</span> <span class="n">to</span> <span class="n">construct</span> <span class="n">filter</span>
<span class="mf">1.964404</span><span class="n">s</span> <span class="n">to</span> <span class="n">query</span> <span class="n">every</span> <span class="n">element</span>

<span class="o">$</span> <span class="n">head</span> <span class="o">-</span><span class="mi">20</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">prof</span>
<span class="nf">total</span> <span class="n">time</span>  <span class="ow">=</span>          <span class="mf">4.10</span> <span class="n">secs</span>   <span class="p">(</span><span class="mi">205</span> <span class="n">ticks</span> <span class="o">@</span> <span class="mi">20</span> <span class="n">ms</span><span class="p">)</span>
<span class="nf">total</span> <span class="n">alloc</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">,</span><span class="mi">752</span><span class="p">,</span><span class="mi">287</span><span class="p">,</span><span class="mi">168</span> <span class="n">bytes</span>  <span class="p">(</span><span class="n">excludes</span> <span class="n">profiling</span> <span class="n">overheads</span><span class="p">)</span>

<span class="kt">COST</span> <span class="kt">CENTRE</span>                    <span class="kt">MODULE</span>               <span class="o">%</span><span class="n">time</span> <span class="o">%</span><span class="n">alloc</span>

<span class="nf">doubleHash</span>                     <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>      <span class="mf">48.8</span>   <span class="mf">66.4</span>
<span class="nf">indices</span>                        <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>   <span class="mf">13.7</span>   <span class="mf">15.8</span>
<span class="nf">elem</span>                           <span class="kt">BloomFilter</span>            <span class="mf">9.8</span>    <span class="mf">1.3</span>
<span class="nf">hashByteString</span>                 <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>       <span class="mf">6.8</span>    <span class="mf">3.8</span>
<span class="nf">easyList</span>                       <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span>       <span class="mf">5.9</span>    <span class="mf">0.3</span>
<span class="nf">hashIO</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>       <span class="mf">4.4</span>    <span class="mf">5.3</span>
<span class="nf">main</span>                           <span class="kt">Main</span>                   <span class="mf">4.4</span>    <span class="mf">3.8</span>
<span class="nf">insert</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>    <span class="mf">2.9</span>    <span class="mf">0.0</span>
<span class="nf">len</span>                            <span class="kt">BloomFilter</span>            <span class="mf">2.0</span>    <span class="mf">2.4</span>
<span class="nf">length</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>    <span class="mf">1.5</span>    <span class="mf">1.0</span>
</pre></div>
</div>
<p>可以看出， <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 占用了巨大的时空资源。</p>
<p>回忆一下，<code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 函数的主体功能是无副作用的列表解析：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">doubleHash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">doubleHash</span> <span class="n">numHashes</span> <span class="n">value</span> <span class="ow">=</span> <span class="p">[</span><span class="n">h1</span> <span class="o">+</span> <span class="n">h2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">num</span><span class="p">]]</span>
        <span class="kr">where</span> <span class="n">h</span>   <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x9150a946c4a8966e</span> <span class="n">value</span>
                  <span class="n">h1</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">h</span> <span class="p">`</span><span class="n">shiftR</span><span class="p">`</span> <span class="mi">32</span><span class="p">)</span> <span class="o">.&amp;.</span> <span class="n">maxBound</span>
                  <span class="n">h2</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">h</span>
                  <span class="n">num</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">numHashes</span>
</pre></div>
</div>
<p>鉴于 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 的返回值是列表，它占这么大内存似乎有点道理。但是这么简单的代码却表现出如此之差的性能，难免让人怀疑。</p>
<p>面对这么一个性能上的谜团，我们自然会想到检查编译器的输出。这里并不需要通过汇编语言转储来分析，从更高层次开始会更容易。</p>
<p>GHC 的 <code class="docutils literal notranslate"><span class="pre">-ddump-simpl</span></code> 选项会打印出执行所有高级优化后生成的代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="kt">O2</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">ddump</span><span class="o">-</span><span class="n">simpl</span> <span class="c1">--make BloomFilter/Hash.hs &gt; dump.txt</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span> <span class="p">(</span> <span class="kt">BloomFilter</span><span class="o">/</span><span class="kt">Hash</span><span class="o">.</span><span class="n">hs</span> <span class="p">)</span>
</pre></div>
</div>
<p>产生的 <code class="docutils literal notranslate"><span class="pre">dump.txt</span></code> 大约有一千行，其中多数名字是根据原始 Haskell 表示自动生成的。即使如此，搜索 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 仍然可以帮助我们立刻定位到函数的定义。下面这个例子说明了如何在 Unix Shell 中寻找到函数的定义：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">less</span> <span class="o">+/</span><span class="n">doubleHash</span> <span class="n">dump</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>刚开始阅读 GHC 简化器的输出会有些困难。这些输出包含了许多自动生成的名称，并且代码中有许多不明显的注释。我们可以忽略掉自己不了解的东西，将注意力集中在看起来很熟悉的部分上。普通的 Haskell 和 Core 语言在语法特性上有一定相似之处，尤其是类型签名、用于变量绑定的 <code class="docutils literal notranslate"><span class="pre">let</span></code> 和模式匹配的 <code class="docutils literal notranslate"><span class="pre">case</span></code> 。</p>
<p>如果去除 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 定义之外的部分，我们将得到类似如下所示的代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">__letrec</span> <span class="p">{</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span>
  <span class="n">go_s1YC</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span><span class="p">]</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
  <span class="p">[</span><span class="kt">Arity</span> <span class="mi">1</span>
   <span class="kt">Str:</span> <span class="kt">DmdType</span> <span class="kt">S</span><span class="p">]</span>
  <span class="n">go_s1YC</span> <span class="ow">=</span>
        <span class="nf">\</span> <span class="p">(</span><span class="n">ds_a1DR</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span><span class="p">])</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">ds_a1DR</span> <span class="kr">of</span> <span class="n">wild_a1DS</span> <span class="p">{</span>
        <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="kt">[]</span> <span class="o">@</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span><span class="p">;</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span>
        <span class="kt">:</span> <span class="n">y_a1DW</span> <span class="n">ys_a1DX</span> <span class="ow">-&gt;</span> <span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>
          <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.:</span> <span class="o">@</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span> <span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span>
                <span class="p">(</span><span class="kr">case</span> <span class="n">h1_s1YA</span> <span class="kr">of</span> <span class="n">wild1_a1Mk</span> <span class="p">{</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">W32</span><span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="n">_a1Mm</span> <span class="ow">-&gt;</span> <span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span>
                 <span class="kr">case</span> <span class="n">h2_s1Yy</span> <span class="kr">of</span> <span class="n">wild2_a1Mu</span> <span class="p">{</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">W32</span><span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="mi">1</span><span class="n">_a1Mw</span> <span class="ow">-&gt;</span>
                 <span class="kr">case</span> <span class="n">y_a1DW</span> <span class="kr">of</span> <span class="n">wild11_a1My</span> <span class="p">{</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">W32</span><span class="o">#</span> <span class="n">y</span><span class="o">#</span><span class="n">_a1MA</span> <span class="ow">-&gt;</span>
                 <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">W32</span><span class="o">#</span> <span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span>
                   <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span>
                  <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">plusWord</span><span class="o">#</span> <span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>
                         <span class="n">x</span><span class="o">#</span><span class="n">_a1Mm</span> <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span>
                                                          <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">timesWord</span><span class="o">#</span> <span class="n">x</span><span class="o">#</span><span class="mi">1</span><span class="n">_a1Mw</span> <span class="n">y</span><span class="o">#</span><span class="n">_a1MA</span><span class="p">))))</span>
                 <span class="p">}</span>
                 <span class="p">}</span>
                 <span class="p">})</span>
                <span class="p">(</span><span class="n">go_s1YC</span> <span class="n">ys_a1DX</span><span class="p">)</span> <span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span>
          <span class="p">};</span>
<span class="p">}</span> <span class="kr">in</span>
  <span class="n">go_s1YC</span> <span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.$</span><span class="n">w</span><span class="o">$</span><span class="n">dmenumFromTo2</span>
           <span class="n">__word</span> <span class="mi">0</span> <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span> <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">int2Word</span><span class="o">#</span> <span class="n">ww_s1X3</span><span class="p">)))</span>
</pre></div>
</div>
<p>[Forec 译注：原著中给出的代码包含了图片，译文使用 <code class="docutils literal notranslate"><span class="pre">&lt;编号&gt;</span></code> 这样的标识代替图片，并在下面给出对应的注释。]</p>
<p>这是列表分析部分的主体。看起来似乎令人生畏，但我们可以逐步分析它。你会发现它并非那么复杂：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__letrec</span></code> 等价于 Haskell 中的 <code class="docutils literal notranslate"><span class="pre">let</span></code> ；</p></li>
<li><p>GHC 将列表解析的主体部分编译成了一个名为 <code class="docutils literal notranslate"><span class="pre">go_s1YC</span></code> 的循环；</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">case</span></code> 表达式匹配了空列表，我们就返回空列表。是不是看起来很熟悉？</p></li>
<li><p>这个模式在 Haskell 中读作 <code class="docutils literal notranslate"><span class="pre">(y_a1DW:ys_a1DX)</span></code> 。<code class="docutils literal notranslate"><span class="pre">(:)</span></code> 构造器之所以出现在操作数之前，是因为 Core 语言出于简单起见使用了前缀表达式；</p></li>
<li><p>这是 <code class="docutils literal notranslate"><span class="pre">(:)</span></code> 构造器的一种应用。符号 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 表明第一个操作数的类型是 <code class="docutils literal notranslate"><span class="pre">Word32</span></code> ；</p></li>
<li><p>三个 <code class="docutils literal notranslate"><span class="pre">case</span></code> 表达式分别对一个 <code class="docutils literal notranslate"><span class="pre">Word32</span></code> 值拆箱以取出其中包含的原始值。首先处理的是 <code class="docutils literal notranslate"><span class="pre">h1</span></code> （这里命名为 <code class="docutils literal notranslate"><span class="pre">h1_s1YA</span></code> ），然后是 <code class="docutils literal notranslate"><span class="pre">h2</span></code> ，最后是当前列表元素 <code class="docutils literal notranslate"><span class="pre">y</span></code> 。拆箱是通过模式匹配实现的：<code class="docutils literal notranslate"><span class="pre">W32#</span></code> 是用于将原始值装箱的构造函数。按照惯例，原始类型、值以及使用它们的函数在命名时都会包含一个 <code class="docutils literal notranslate"><span class="pre">#</span></code>；</p></li>
<li><p>这里我们将 <code class="docutils literal notranslate"><span class="pre">W32#</span></code> 构造器应用于 <code class="docutils literal notranslate"><span class="pre">Word32#</span></code> 类型的原始值，从而给出类型为 <code class="docutils literal notranslate"><span class="pre">Word32</span></code> 的正常值；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plusWord#</span></code> 和 <code class="docutils literal notranslate"><span class="pre">timesWord#</span></code> 函数分别对原始的无符号整数做添加和相乘操作；</p></li>
<li><p>这是 <code class="docutils literal notranslate"><span class="pre">(:)</span></code> 构造器的第二个参数，其中 <code class="docutils literal notranslate"><span class="pre">go_s1YC</span></code> 函数以递归的方式调用自身；</p></li>
<li><p>这里调用了列表解析函数。它的参数是用 Core 语言表示的 <code class="docutils literal notranslate"><span class="pre">[0..n]</span></code> 。</p></li>
</ol>
<p>阅读这段代码，我们发现了两处有趣的行为：</p>
<ul class="simple">
<li><p>我们创建了一个列表，并且立刻在 <code class="docutils literal notranslate"><span class="pre">go_s1YC</span></code> 循环中解构它。GHC 通常可以检查出这种生产后立刻消费的模式，并将其转化为一个不包含资源分配的循环。这类变换称为 <em>融合</em> ，因为生产者和消费者被融合到了一起。不幸的是，在上面的代码中 GHC 并没有为我们实现这一点。</p></li>
<li><p>在循环体中重复对 <code class="docutils literal notranslate"><span class="pre">h1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">he</span></code> 开箱的行为非常浪费资源。</p></li>
</ul>
<p>为了解决这些问题，我们对 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 函数做了一些细微的修改：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">doubleHash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">doubleHash</span> <span class="n">numHashes</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">go</span> <span class="mi">0</span>
        <span class="kr">where</span> <span class="n">go</span> <span class="n">n</span> <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">num</span>  <span class="ow">=</span> <span class="kt">[]</span>
                           <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">h2</span> <span class="o">*</span> <span class="n">n</span> <span class="kt">:</span> <span class="n">go</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                  <span class="o">!</span><span class="n">h1</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">h</span> <span class="p">`</span><span class="n">shiftR</span><span class="p">`</span> <span class="mi">32</span><span class="p">)</span> <span class="o">.&amp;.</span> <span class="n">maxBound</span>
                  <span class="o">!</span><span class="n">h2</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">h</span>

                  <span class="n">h</span>   <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x9150a946c4a8966e</span> <span class="n">value</span>
                  <span class="n">num</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">numHashes</span>
</pre></div>
</div>
<p>上面的代码中，我们手动将 <code class="docutils literal notranslate"><span class="pre">[0..num]</span></code> 表达式和 “消费” 它的代码合并成单个循环，并为 <code class="docutils literal notranslate"><span class="pre">h1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">h2</span></code> 添加了严格注释。这些修改将 6 行代码变成 8 行，除此之外没有任何其它变动。它们会对 Core 的输出有什么影响呢？</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">__letrec</span> <span class="p">{</span>
  <span class="o">$</span><span class="n">wgo_s1UH</span> <span class="ow">::</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">Word</span><span class="o">#</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span><span class="p">]</span>
  <span class="p">[</span><span class="kt">Arity</span> <span class="mi">1</span>
   <span class="kt">Str:</span> <span class="kt">DmdType</span> <span class="kt">L</span><span class="p">]</span>
  <span class="o">$</span><span class="n">wgo_s1UH</span> <span class="ow">=</span>
        <span class="nf">\</span> <span class="p">(</span><span class="n">ww2_s1St</span> <span class="ow">::</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">Word</span><span class="o">#</span><span class="p">)</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">eqWord</span><span class="o">#</span> <span class="n">ww2_s1St</span> <span class="n">a_s1T1</span> <span class="kr">of</span> <span class="n">wild1_X2m</span> <span class="p">{</span>
        <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="kt">False</span> <span class="ow">-&gt;</span>
          <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.:</span> <span class="o">@</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span>
                <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">W32</span><span class="o">#</span>
                 <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span>
                  <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">plusWord</span><span class="o">#</span>
                   <span class="n">ipv_s1B2</span>
                   <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span>
                <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">timesWord</span><span class="o">#</span> <span class="n">ipv1_s1AZ</span> <span class="n">ww2_s1St</span><span class="p">)))))</span>
                <span class="p">(</span><span class="o">$</span><span class="n">wgo_s1UH</span> <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">narrow32Word</span><span class="o">#</span>
                                                <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="n">plusWord</span><span class="o">#</span> <span class="n">ww2_s1St</span> <span class="n">__word</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="kt">True</span> <span class="ow">-&gt;</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="kt">[]</span> <span class="o">@</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Word</span><span class="o">.</span><span class="kt">Word32</span>
          <span class="p">};</span>
<span class="p">}</span> <span class="kr">in</span>  <span class="o">$</span><span class="n">wgo_s1UH</span> <span class="n">__word</span> <span class="mi">0</span>
</pre></div>
</div>
<p>新函数被编译成了简单的计数循环。多么令人兴奋！来看看它的实际运行效果：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">touch</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">hs</span>
<span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="kt">O2</span> <span class="o">-</span><span class="n">prof</span> <span class="o">-</span><span class="n">auto</span><span class="o">-</span><span class="n">all</span> <span class="c1">--make WordTest</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="kt">Linking</span> <span class="kt">WordTest</span> <span class="o">...</span>

<span class="o">$</span> <span class="o">./</span><span class="kt">WordTest</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="n">p</span>
<span class="mf">0.304352</span><span class="n">s</span> <span class="n">to</span> <span class="n">read</span> <span class="n">words</span>
<span class="mi">479829</span> <span class="n">words</span>
<span class="nf">suggested</span> <span class="n">sizings</span><span class="kt">:</span> <span class="kt">Right</span> <span class="p">(</span><span class="mi">4602978</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="mf">1.516229</span><span class="n">s</span> <span class="n">to</span> <span class="n">construct</span> <span class="n">filter</span>
<span class="mf">1.069305</span><span class="n">s</span> <span class="n">to</span> <span class="n">query</span> <span class="n">every</span> <span class="n">element</span>
<span class="o">~/</span><span class="n">src</span><span class="o">/</span><span class="n">darcs</span><span class="o">/</span><span class="n">book</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ch27</span><span class="o">/</span><span class="n">examples</span> <span class="o">$</span> <span class="n">head</span> <span class="o">-</span><span class="mi">20</span> <span class="kt">WordTest</span><span class="o">.</span><span class="n">prof</span>
<span class="nf">total</span> <span class="n">time</span>  <span class="ow">=</span>        <span class="mf">3.68</span> <span class="n">secs</span>    <span class="p">(</span><span class="mi">184</span> <span class="n">ticks</span> <span class="o">@</span> <span class="mi">20</span> <span class="n">ms</span><span class="p">)</span>
<span class="nf">total</span> <span class="n">alloc</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">,</span><span class="mi">644</span><span class="p">,</span><span class="mi">805</span><span class="p">,</span><span class="mi">536</span> <span class="n">bytes</span> <span class="p">(</span><span class="n">excludes</span> <span class="n">profiling</span> <span class="n">overheads</span><span class="p">)</span>

<span class="kt">COST</span> <span class="kt">CENTRE</span>                    <span class="kt">MODULE</span>               <span class="o">%</span><span class="n">time</span> <span class="o">%</span><span class="n">alloc</span>

<span class="nf">doubleHash</span>                     <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>      <span class="mf">45.1</span>   <span class="mf">65.0</span>
<span class="nf">indices</span>                        <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>   <span class="mf">19.0</span>   <span class="mf">16.4</span>
<span class="nf">elem</span>                           <span class="kt">BloomFilter</span>           <span class="mf">12.5</span>    <span class="mf">1.3</span>
<span class="nf">insert</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>    <span class="mf">7.6</span>    <span class="mf">0.0</span>
<span class="nf">easyList</span>                       <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span>       <span class="mf">4.3</span>    <span class="mf">0.3</span>
<span class="nf">len</span>                            <span class="kt">BloomFilter</span>            <span class="mf">3.3</span>    <span class="mf">2.5</span>
<span class="nf">hashByteString</span>                 <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>       <span class="mf">3.3</span>    <span class="mf">4.0</span>
<span class="nf">main</span>                           <span class="kt">Main</span>                   <span class="mf">2.7</span>    <span class="mf">4.0</span>
<span class="nf">hashIO</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Hash</span>       <span class="mf">2.2</span>    <span class="mf">5.5</span>
<span class="nf">length</span>                         <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Mutable</span>    <span class="mf">0.0</span>    <span class="mf">1.0</span>
</pre></div>
</div>
<p>针对 <code class="docutils literal notranslate"><span class="pre">doubleHash</span></code> 的调整使性能提高了约 11%。对于仅仅添加两行代码的变动来说已经相当不错了。</p>
</section>
</section>
<section id="id21">
<h2>练习<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">easyList</span></code> 中使用的 <code class="docutils literal notranslate"><span class="pre">genericLength</span></code> 在处理无限列表时会导致函数陷入无限循环。如何修正此问题？</p></li>
<li><p><em>困难</em> ：编写一个 <code class="docutils literal notranslate"><span class="pre">QuickCheck</span></code> 属性以检查观察到的错误率是否接近用户可容忍的错误率。</p></li>
</ul>
<dl class="citation">
<dt class="label" id="broder02"><span class="brackets"><a class="fn-backref" href="#id3">Broder02</a></span></dt>
<dd><p>Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id6">58</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ST</span></code> 是 “状态变换器” （state transformer） 的缩写。</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id12">59</a></span></dt>
<dd><p>与流行的非加密哈希函数（如 FNV 和 hashpjw）相比，Jenkins 的哈希函数的混合属性要好得多，因此我们建议避免使用那些非加密哈希函数。</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id13">60</a></span></dt>
<dd><p>遗憾的是，详细讨论这些情况能否判断不属于本书范畴。</p>
</dd>
</dl>
</section>
</section>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, huangz1990.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>