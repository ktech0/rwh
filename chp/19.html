<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>第 19 章： 错误处理 &#8212; Real World Haskell 中文版</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="第 20 章：使用 Haskell 进行系统编程" href="20.html" />
    <link rel="prev" title="第 18 章： Monad变换器" href="18.html" /> 
  </head><body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="18.html">第 18 章： Monad变换器</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="20.html">第 20 章：使用 Haskell 进行系统编程</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <section id="id1">
<h1>第 19 章： 错误处理<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>无论使用哪门语言，错误处理都是程序员最重要–也是最容易忽视–的话题之一。在Haskell中，你会发现有两类主流的错误处理：“纯”的错误处理和异常。</p>
<p>当我们说“纯”的错误处理，我们是指算法不依赖任何IO Monad。我们通常会利用Haskell富于表现力的数据类型系统来实现这一类错误处理。Haskell也支持异常。由于惰性求值复杂性，Haskell中任何地方都可能抛出异常，但是只会在IO monad中被捕获。在这一章中，这两类错误处理我们都会考虑。</p>
<section id="id2">
<h2>使用数据类型进行错误处理<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>让我们从一个非常简单的函数来开始我们关于错误处理的讨论。假设我们希望对一系列的数字执行除法运算。分子是常数，但是分母是变化的。可能我们会写出这样一个函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby1.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`)</span>
</pre></div>
</div>
<p>非常简单，对吧？我们可以在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中执行这些代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">divBy</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
<span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>这个行为跟我们预期的是一致的：50 / 1 得到50，50 / 2 得到25，等等。甚至对于无穷的链表 [1..] 它也是可以工作的。如果有个0溜进去我们的链表中了，会发生什么事呢？</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="o">***</span> <span class="kt">Exception:</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>是不是很有意思？ <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 开始显示输出，然后当它遇到零时发生了一个异常停止了。这是惰性求值的作用–它只按需求值。</p>
<p>在这一章里接下来我们会看到，缺乏一个明确的异常处理时，这个异常会使程序崩溃。这当然不是我们想要的，所以让我们思考一下更好的方式来表征这个纯函数中的错误。</p>
<section id="maybe">
<h3>使用Maybe<a class="headerlink" href="#maybe" title="Permalink to this headline">¶</a></h3>
<p>可以立刻想到的一个表示失败的简单的方法是使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 。如果输入链表中任何地方包含了零，相对于仅仅返回一个链表并在失败的时候抛出异常，我们可以返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ，或者如果没有出现零我们可以返回结果的 <code class="docutils literal notranslate"><span class="pre">Just</span></code>。下面是这个算法的实现：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby2.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">[]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">divBy</span> <span class="n">numerator</span> <span class="n">xs</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Just</span> <span class="n">results</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中尝试它，你会发现它可以工作：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 的函数现在可以使用 <code class="docutils literal notranslate"><span class="pre">case</span></code> 语句来观察调用成功与否，就像 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 调用自己时所做的那样。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>你大概注意到，上面可以使用一个monadic的实现，像这样子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby2m.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="n">denominators</span> <span class="ow">=</span> 
    <span class="n">mapM</span> <span class="p">(</span><span class="n">numerator</span> <span class="p">`</span><span class="n">safeDiv</span><span class="p">`)</span> <span class="n">denominators</span>
    <span class="kr">where</span> <span class="n">safeDiv</span> <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Nothing</span>
          <span class="n">safeDiv</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>出于简单考虑，在这章中我们会避免使用monadic实现，但是会指出有这种做法。</p>
</div>
<p>[译注:原 Tip 中代码错误，在除以非0数字的情况下没有返回正确类型，因此编译不过，可以使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 来修正，此处使用 <code class="docutils literal notranslate"><span class="pre">Just</span></code>]</p>
<section id="id3">
<h4>丢失和保存惰性<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 很方便，但是有代价。 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 将不能够再处理无限的链表输入。由于结果是一个 <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">[a]</span></code> ，必须要检查整个输入链表，我们才能确认不会因为存在零而返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 。你可以尝试在之前的例子中验证这一点：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">stack</span> <span class="n">overflow</span>
</pre></div>
</div>
<p>这里观察到，你没有看到部分的输出；你没得到任何输出。注意到在 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 的每一步中(除了输入链表为空或者链表开头是零的情况)，每个子序列元素的结果必须先于当前元素的结果得到。因此这个算法无法处理无穷链表，并且对于大的有限链表，它的空间效率也不高。</p>
<p>之前已经说过， <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 通常是一个好的选择。在这个特殊例子中，只有当我们去执行整个输入的时候我们才知道是否有问题。有时候我们可以提交发现问题，例如，在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中 <code class="docutils literal notranslate"><span class="pre">tail</span> <span class="pre">[]</span></code> 会生成一个异常。我们可以很容易写一个可以处理无穷情况的 <code class="docutils literal notranslate"><span class="pre">tail</span></code> ：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/safetail.hs</span>
<span class="nf">safeTail</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">safeTail</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">safeTail</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">xs</span>
</pre></div>
</div>
<p>如果输入为空，简单的返回一个 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ，其它情况返回结果的 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 。由于在知道是否发生错误之前，我们只需要确认链表非空，在这里使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 不会破坏惰性。我们可以在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中测试并观察跟普通的 <code class="docutils literal notranslate"><span class="pre">tail</span></code> 有何不同：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">safeTail</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">tail</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">safeTail</span> <span class="kt">[]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>这里我们可以看到，我们的 <code class="docutils literal notranslate"><span class="pre">safeTail</span></code> 执行结果符合预期。但是对于无穷链表呢？我们不想打印无穷的结果的数字，所以我们用 <code class="docutils literal notranslate"><span class="pre">take</span> <span class="pre">5</span> <span class="pre">(tail</span> <span class="pre">[1..])</span></code> 以及一个类似的saftTail构建测试：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">safeTail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="kr">of</span> <span class="p">{</span><span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span><span class="p">;</span> <span class="kt">Just</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">take</span> <span class="mi">5</span> <span class="n">x</span><span class="p">)}</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">tail</span> <span class="kt">[]</span><span class="p">)</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">tail</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">safeTail</span> <span class="kt">[]</span> <span class="kr">of</span> <span class="p">{</span><span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span><span class="p">;</span> <span class="kt">Just</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">take</span> <span class="mi">5</span> <span class="n">x</span><span class="p">)}</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>这里你可以看到 <code class="docutils literal notranslate"><span class="pre">tail</span></code> 和 <code class="docutils literal notranslate"><span class="pre">safeTail</span></code> 都可以处理无穷链表。注意我们可以更好地处理空的输入链表；而不是抛出异常，我们决定这种情况返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 。我们可以获得错误处理能力却不会失去惰性。</p>
<p>但是我们如何将它应用到我们的 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 的例子中呢？让我们思考下现在的情况：失败是单个坏的输入的属性，而不是输入链表自身。那么将失败作为单个输出元素的属性，而不是整个输出链表怎么样？也就是说，不是一个类型为 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">[a]</span></code> 的函数，取而代之我们使用 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[Maybe</span> <span class="pre">a]</span></code> 。这样做的好处是可以保留惰性，并且调用者可以确定是在链表中的哪里出了问题–或者甚至是过滤掉有问题的结果，如果需要的话。这里是一个实现：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby3.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="n">denominators</span> <span class="ow">=</span>
    <span class="n">map</span> <span class="n">worker</span> <span class="n">denominators</span>
    <span class="kr">where</span> <span class="n">worker</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Nothing</span>
          <span class="n">worker</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>看下这个函数，我们再次回到使用 <code class="docutils literal notranslate"><span class="pre">map</span></code> ，这无论对简洁和惰性都是件好事。我们可以在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中测试它，并观察对于有限和无限链表它都可以正常工作：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">50</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">25</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">10</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">50</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">25</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">divBy</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">100</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">50</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">33</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">25</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>我们希望通过这个讨论你可以明白这点，不符合规范的（正如 <code class="docutils literal notranslate"><span class="pre">safeTail</span></code> 中的情况）输入和包含坏的数据的输入( <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 中的情况)是有区别的。这两种情况通常需要对结果采用不同的处理。</p>
</section>
<section id="maybe-monad">
<h4>Maybe Monad的用法<a class="headerlink" href="#maybe-monad" title="Permalink to this headline">¶</a></h4>
<p>回到 <span class="xref std std-ref">使用Maybe</span> 这一节，我们有一个叫做 <code class="docutils literal notranslate"><span class="pre">divby2.hs</span></code> 的示例程序。这个例子没有保存惰性，而是返回一个类型为 <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">[a]</span></code> 的值。用monadic风格也可以表达同样的算法。更多信息和monad相关背景，参考 <a class="reference external" href="http://rwh.readthedocs.org/en/latest/chp/14.html">第14章Monads</a> 。这是我们新的monadic风格的算法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby4.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;division by zero in divBy&quot;</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">next</span> <span class="ow">&lt;-</span> <span class="n">divBy</span> <span class="n">numerator</span> <span class="n">xs</span>
       <span class="n">return</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">next</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad使得这个算法的表示看上去更好。对于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad， <code class="docutils literal notranslate"><span class="pre">return</span></code> 就跟 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 一样，并且 <code class="docutils literal notranslate"><span class="pre">fail</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Nothing</span></code> ，因此我们看到任何的错误说明的字段串。我们可以用我们在 <code class="docutils literal notranslate"><span class="pre">divby2.hs</span></code> 中使用过的测试来测试这个算法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">stack</span> <span class="n">overflow</span>
</pre></div>
</div>
<p>我们写的代码实际上并不限于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad。只要简单地改变类型，我们可以让它对于任何monad都能工作。让我们试一下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby5.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="ow">=</span> <span class="n">divByGeneric</span>

<span class="nf">divByGeneric</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;division by zero in divByGeneric&quot;</span>
<span class="nf">divByGeneric</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">next</span> <span class="ow">&lt;-</span> <span class="n">divByGeneric</span> <span class="n">numerator</span> <span class="n">xs</span>
       <span class="n">return</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">next</span><span class="p">)</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">divByGeneric</span></code> 包含的代码 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 之前所做的一样；我们只是给它一个更通用的类型。事实上，如果不给出类型，这个类型是由 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 自动推导的。我们还为特定的类型定义了一个更方便的函数 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 。</p>
<p>让我们在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中运行一下。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">divby5</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">divby5</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">divByGeneric</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span><span class="ow">::</span><span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divByGeneric</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divByGeneric</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">user</span> <span class="ne">error</span> <span class="p">(</span><span class="n">division</span> <span class="n">by</span> <span class="n">zero</span> <span class="kr">in</span> <span class="n">divByGeneric</span><span class="p">)</span>
</pre></div>
</div>
<p>前两个例子产生的输出都跟我们之前看到的一样。由于 <code class="docutils literal notranslate"><span class="pre">divByGeneric</span></code> 没有指定返回的类型，我们要么指定一个，要么让解释器从环境中推导得到。如果我们不指定返回类型， <code class="docutils literal notranslate"><span class="pre">ghic</span></code> 推荐得到 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad。在第三和第四个例子中你可以看出来。在第四个例子中你可以看到， <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad将 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 转化成了一个异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">mtl</span></code> 包中的 <code class="docutils literal notranslate"><span class="pre">Control.Monad.Error</span></code> 模块也将 <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span></code> 变成了一个monad。如果你使用 <code class="docutils literal notranslate"><span class="pre">Either</span></code> ，你可以得到保存了错误信息的纯的结果，像这样子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span><span class="o">.</span><span class="kt">Error</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">divByGeneric</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span><span class="ow">::</span><span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Right</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">divByGeneric</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span><span class="ow">::</span><span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="kt">Left</span> <span class="s">&quot;division by zero in divByGeneric&quot;</span>
</pre></div>
</div>
<p>这让我们进入到下一个话题的讨论：使用 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 返回错误信息。</p>
</section>
</section>
<section id="either">
<h3>使用Either<a class="headerlink" href="#either" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Either</span></code> 类型跟 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型类似，除了一处关键的不同：对于错误或者成功（“ <code class="docutils literal notranslate"><span class="pre">Right</span></code> 类型”），它都可以携带数据。尽管语言没有强加任何限制，按照惯例，一个返回 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 的函数使用 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 返回值来表示一个错误， <code class="docutils literal notranslate"><span class="pre">Right</span></code> 来表示成功。如果你觉得这样有助于记忆，你可以认为 <code class="docutils literal notranslate"><span class="pre">Right</span></code> 表式正确结果。我们可以改一下前面小节中关于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 时使用的 <code class="docutils literal notranslate"><span class="pre">divby2.hs</span></code> 的例子，让 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 可以工作：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby6.hs</span>
<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="kt">[]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;divBy: division by 0&quot;</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">divBy</span> <span class="n">numerator</span> <span class="n">xs</span> <span class="kr">of</span>
      <span class="kt">Left</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">x</span>
      <span class="kt">Right</span> <span class="n">results</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>这份代码跟 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 的代码几乎是完全一样的；我们只是把每个 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 用 <code class="docutils literal notranslate"><span class="pre">Right</span></code> 替换。<code class="docutils literal notranslate"><span class="pre">Left</span></code> 对应于 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ，但是现在它可以携带一条信息。让我们在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 里面运行一下：</p>
<blockquote>
<div><p>ghci&gt; divBy 50 [1,2,5,8,10]
Right [50,25,10,6,5]
ghci&gt; divBy 50 [1,2,0,8,10]
Left “divBy: division by 0”</p>
</div></blockquote>
<section id="id4">
<h4>为错误定制数据类型<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>尽管用 <code class="docutils literal notranslate"><span class="pre">String</span></code> 类型来表示错误的原因对今后很有好处，自定义的错误类型通常会更有帮助。使用自定义的错误类型我们可以知道到底是出了什么问题，并且获知是什么动作引发的这个问题。例如，让我们假设，由于某些原因，不仅仅是除0，我们还不想除以10或者20。我们可以像这样子自定义一个错误类型：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby7.hs</span>
<span class="kr">data</span> <span class="kt">DivByError</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">DivBy0</span>
                 <span class="o">|</span> <span class="kt">ForbiddenDenominator</span> <span class="n">a</span>
                   <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">DivByError</span> <span class="n">a</span><span class="p">)</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="kt">[]</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="kt">DivBy0</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">10</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="kt">ForbiddenDenominator</span> <span class="mi">10</span><span class="p">)</span>
<span class="nf">divBy</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">20</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="kt">ForbiddenDenominator</span> <span class="mi">20</span><span class="p">)</span>
<span class="nf">divBy</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">divBy</span> <span class="n">numerator</span> <span class="n">xs</span> <span class="kr">of</span>
      <span class="kt">Left</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">x</span>
      <span class="kt">Right</span> <span class="n">results</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>现在，在出现错误时，可以通过 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 数据检查导致错误的准确原因。或者，可以简单的只是通过 <code class="docutils literal notranslate"><span class="pre">show</span></code> 打印出来。下面是这个函数的应用：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Right</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Left</span> <span class="p">(</span><span class="kt">ForbiddenDenominator</span> <span class="mi">10</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">divBy</span> <span class="mi">50</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">Left</span> <span class="kt">DivBy0</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>所有这些 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 的例子都跟我们之前的 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 一样，都会遇到失去惰性的问题。我们将在这一章的最后用一个练习题来解决这个问题。</p>
</div>
</section>
<section id="monadiceither">
<h4>Monadic地使用Either<a class="headerlink" href="#monadiceither" title="Permalink to this headline">¶</a></h4>
<p>回到 <span class="xref std std-ref">Maybe Monad的用法</span> 这一节，我们向你展示了如何在一个monad中使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 。 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 也可以在monad中使用，但是可能会复杂一点。原因是 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 是硬编码的只接受 <code class="docutils literal notranslate"><span class="pre">String</span></code> 作为失败代码，因此我们必须有一种方法将这样的字符串映射成我们的 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 使用的类型。正如你前面所见， <code class="docutils literal notranslate"><span class="pre">Control.Monad.Error</span></code> 为 <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span> <span class="pre">a</span></code> 提供了内置的支持，它没有涉及到将参数映射到 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 。这里我们可以将我们的例子修改为monadic风格使得 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 可以工作：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/divby8.hs</span>
<span class="cm">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Error</span>

<span class="kr">data</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> 
    <span class="kt">DivByError</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">DivBy0</span>
                  <span class="o">|</span> <span class="kt">ForbiddenDenominator</span> <span class="n">a</span>
                  <span class="o">|</span> <span class="kt">OtherDivByError</span> <span class="kt">String</span>
                    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Error</span> <span class="p">(</span><span class="kt">DivByError</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">strMsg</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">OtherDivByError</span> <span class="n">x</span>

<span class="nf">divBy</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">DivByError</span> <span class="n">a</span><span class="p">)</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divBy</span> <span class="ow">=</span> <span class="n">divByGeneric</span>

<span class="nf">divByGeneric</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">,</span> <span class="kt">MonadError</span> <span class="p">(</span><span class="kt">DivByError</span> <span class="n">a</span><span class="p">)</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span>
                 <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="kt">DivBy0</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">10</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="p">(</span><span class="kt">ForbiddenDenominator</span> <span class="mi">10</span><span class="p">)</span>
<span class="nf">divByGeneric</span> <span class="kr">_</span> <span class="p">(</span><span class="mi">20</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="p">(</span><span class="kt">ForbiddenDenominator</span> <span class="mi">20</span><span class="p">)</span>
<span class="nf">divByGeneric</span> <span class="n">numerator</span> <span class="p">(</span><span class="n">denom</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">next</span> <span class="ow">&lt;-</span> <span class="n">divByGeneric</span> <span class="n">numerator</span> <span class="n">xs</span>
       <span class="n">return</span> <span class="p">((</span><span class="n">numerator</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">denom</span><span class="p">)</span> <span class="kt">:</span> <span class="n">next</span><span class="p">)</span>
</pre></div>
</div>
<p>这里，我们需要打开 <code class="docutils literal notranslate"><span class="pre">FlexibleContexts</span></code> 语言扩展以提供 <code class="docutils literal notranslate"><span class="pre">divByGeneric</span></code> 的类型签名。 <code class="docutils literal notranslate"><span class="pre">divBy</span></code> 函数跟之前的工作方式完全一致。对于 <code class="docutils literal notranslate"><span class="pre">divByGeneric</span></code> ，我们将 <code class="docutils literal notranslate"><span class="pre">divByError</span></code> 做为 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 类型类的成员，通过定义调用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 时的行为（ <code class="docutils literal notranslate"><span class="pre">strMsg</span></code> 函数）。我们还将 <code class="docutils literal notranslate"><span class="pre">Right</span></code> 转化成 <code class="docutils literal notranslate"><span class="pre">return</span></code> ，将 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 转化成 <code class="docutils literal notranslate"><span class="pre">throwError</span></code> 进行泛化。</p>
</section>
</section>
</section>
<section id="id5">
<h2>异常<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>许多语言中都有异常处理，包括Haskell。异常很有用，因为当发生故障时，它提供了一种简单的处理方法，即使故障离发生的地方沿着函数调用链走了几层。有了异常，不需要检查每个函数调用的返回值是否发生了错误，不需要注意去生成表示错误的返回值，像C程序员必须这么做。在Haskell中，由于有 monad以及 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型，你通常可以在纯的代码中达到同样的效果而不需要使用异常和异常处理。</p>
<p>有些问题–尤其是涉及到IO调用–需要处理异常。在Haskell中，异常可能会在程序的任何地方抛出。然而，由于计算顺序是不确定的，异常只可以在 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中捕获。Haskell异常处理不涉及像Python或者Java中那样的特殊语法。捕获和处理异常的技术是–真令人惊讶–函数。</p>
<section id="id6">
<h3>异常第一步<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 模块中，定义了各种跟异常相关的函数和类型。 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 类型是在那里定义的；所有的异常的类型都是 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 。还有用于捕获和处理异常的函数。让我们先看一看 <code class="docutils literal notranslate"><span class="pre">try</span></code> ，它的类型是 <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">(Either</span> <span class="pre">Exception</span> <span class="pre">a)</span></code> 。它将异常处理包装在 <code class="docutils literal notranslate"><span class="pre">IO</span></code> 中。如果有异常抛出，它会返回一个 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 值表示异常；否则，返回原始结果到 <code class="docutils literal notranslate"><span class="pre">Right</span></code> 值。让我们在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中运行一下。我们首先触发一个未处理的异常，然后尝试捕获它。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Exception</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="n">x</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="n">y</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">try</span> <span class="p">(</span><span class="n">print</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Left</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">try</span> <span class="p">(</span><span class="n">print</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">5</span>
<span class="kt">Right</span> <span class="nb">()</span>
</pre></div>
</div>
<p>注意到在 <code class="docutils literal notranslate"><span class="pre">let</span></code> 语句中没有抛出异常。这是意料之中的，是因为惰性求值；除以零只有到打印 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值的时候才需要计算。还有，注意 <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">(print</span> <span class="pre">y)</span></code> 有两行输出。第一行是由 <code class="docutils literal notranslate"><span class="pre">print</span></code> 产生的，它在终端上显示5。第二个是由 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 生成的，这个表示 <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">y</span></code> 的返回值为 <code class="docutils literal notranslate"><span class="pre">()</span></code> 并且没有抛出异常。</p>
</section>
<section id="id7">
<h3>惰性和异常处理<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>既然你知道了 <code class="docutils literal notranslate"><span class="pre">try</span></code> 是如何工作的，让我们试下另一个实验。让我们假设我们想捕获 <code class="docutils literal notranslate"><span class="pre">try</span></code> 的结果用于后续的计算，这样我们可以处理除的结果。我们大概会这么做：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">return</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Right</span> <span class="o">***</span> <span class="kt">Exception:</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>这里发生了什么？让我们拆成一步一步看，先试下另一个例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">undefined</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">try</span> <span class="p">(</span><span class="n">print</span> <span class="n">z</span><span class="p">)</span>
<span class="kt">Left</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">return</span> <span class="n">z</span><span class="p">)</span>
<span class="kt">Right</span> <span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>跟之前一样，将 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 赋值给 <code class="docutils literal notranslate"><span class="pre">z</span></code> 没什么问题。问题的关键，以及前面的迷惑，都在于惰性求值。准确地说，是在于 <code class="docutils literal notranslate"><span class="pre">return</span></code> ，它没有强制它的参数的执行；它只是将它包装了一下。这样， <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">(return</span> <span class="pre">undefined)</span></code> 的结果应该是 <code class="docutils literal notranslate"><span class="pre">Right</span> <span class="pre">undefined</span></code> 。现在， <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 想要将这个结果显示在终端上。它将运行到打印”Right”，但是 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 无法打印（或者说除以零的结果无法打印）。因此你看到了异常信息，它是来源于 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 的，而不是你的程序。</p>
<p>这是一个关键点。让我们想想为什么之前的例子可以工作，而这个不可以。之前，我们把 <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">x</span></code> 放在了 <code class="docutils literal notranslate"><span class="pre">try</span></code> 里面。打印一些东西的值，固然是需要执行它的，因此，异常在正确的地方被检测到了。但是，仅仅是使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 并不会强制计算的执行。为了解决这个问题， <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 模块中定义了一个 <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> 函数。它的行为跟 <code class="docutils literal notranslate"><span class="pre">return</span></code> 类似，但是会让参数立即执行。让我们试一下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">undefined</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">evaluate</span> <span class="n">z</span><span class="p">)</span>
<span class="kt">Left</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">evaluate</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Left</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>看，这就是我们想要的答案。无论对于 <code class="docutils literal notranslate"><span class="pre">undefiined</span></code> 还是除以零的例子，都可以正常工作。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>记住：任何时候你想捕获纯的代码中抛出的异常，在你的异常处理函数中使用 <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">return</span></code> 。</p>
</div>
</section>
<section id="handle">
<h3>使用handle<a class="headerlink" href="#handle" title="Permalink to this headline">¶</a></h3>
<p>通常，你可能希望如果一块代码中没有任何异常发生，就执行某个动作，否则执行不同的动作。对于像这种场合，有一个叫做 <code class="docutils literal notranslate"><span class="pre">handle</span></code> 的函数。这个函数的类型是 <code class="docutils literal notranslate"><span class="pre">(Exception</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code> 。即是说，它需要两个参数：前一个是一个函数，当执行后一个动作发生异常的时候它会被调用。下面是我们使用的一种方式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Exception</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handle</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Error calculating result&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">print</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Error</span> <span class="n">calculating</span> <span class="n">result</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handle</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Error calculating result&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">print</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>像这样，如果计算中没有错误发生，我们可以打印一条好的信息。这当然要比除以零出错时程序崩溃要好。</p>
</section>
<section id="id8">
<h3>选择性地处理异常<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>上面的例子的一个问题是，对于任何异常它都是打印 “Error calculating result”。可能会有些其它不是除零的异常。例如，显示输出时可能会发生错误，或者纯的代码中可能抛出一些其它的异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">handleJust</span></code> 函数就是处理这种情况的。它让你指定一个测试来决定是否对给定的异常感兴趣。让我们看一下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/hj1.hs</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span>

<span class="nf">catchIt</span> <span class="ow">::</span> <span class="kt">Exception</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nb">()</span>
<span class="nf">catchIt</span> <span class="p">(</span><span class="kt">ArithException</span> <span class="kt">DivideByZero</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="nb">()</span>
<span class="nf">catchIt</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>

<span class="nf">handler</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Caught error: divide by zero&quot;</span>

<span class="nf">safePrint</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">safePrint</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">handleJust</span> <span class="n">catchIt</span> <span class="n">handler</span> <span class="p">(</span><span class="n">print</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cacheIt</span></code> 定义了一个函数，这个函数会决定我们对给定的异常是否感兴趣。如果是，它会返回 <code class="docutils literal notranslate"><span class="pre">Just</span></code> ，否则返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 。还有， <code class="docutils literal notranslate"><span class="pre">Just</span></code> 中附带的值会被传到我们的处理函数中。现在我们可以很好地使用 <code class="docutils literal notranslate"><span class="pre">safePrint</span></code> 了：</p>
<blockquote>
<div><p>ghci&gt; :l hj1.hs
[1 of 1] Compiling Main             ( hj1.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; let x = 5 <cite>div</cite> 0
ghci&gt; let y = 5 <cite>div</cite> 1
ghci&gt; safePrint x
Caught error: divide by zero
ghci&gt; safePrint y
5</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 模块还提供了一些可以在 <code class="docutils literal notranslate"><span class="pre">handleJust</span></code> 中使用的函数，以便于我们将异常的范围缩小到我们所关心的类别。例如，有个函数 <code class="docutils literal notranslate"><span class="pre">arithExceptions</span></code> 类型是 <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">ArithException</span></code> 可以挑选出任意的 <code class="docutils literal notranslate"><span class="pre">ArithException</span></code> 异常，但是会忽略掉其它。我们可以像这样使用它：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/hj2.hs</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span>

<span class="nf">handler</span> <span class="ow">::</span> <span class="kt">ArithException</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Caught arithmetic error: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">e</span>

<span class="nf">safePrint</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">safePrint</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">handleJust</span> <span class="n">arithExceptions</span> <span class="n">handler</span> <span class="p">(</span><span class="n">print</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>用这种方式，我们可以捕获所有 <code class="docutils literal notranslate"><span class="pre">ArithException</span></code> 类型的异常，但是仍然让其它的异常通过，不捕获也不修改。我们可以看到它是这样工作的：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">hj2</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">hj2</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">5</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">safePrint</span> <span class="n">x</span>
<span class="kt">Caught</span> <span class="n">arithmetic</span> <span class="ne">error</span><span class="kt">:</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">safePrint</span> <span class="n">y</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>其中特别感兴趣的是，你大概注意到了 <code class="docutils literal notranslate"><span class="pre">ioErrors</span></code> 测试，这是跟一大类的I/O相关的异常。</p>
</section>
<section id="i-o">
<h3>I/O异常<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>大概在任何程序中异常最大的来源就是I/O。在处理外部世界的时候所有事情都可能出错：磁盘满了，网络断了，或者你期望文件里面有数据而文件却是空的。在Haskell中，I/O异常就跟其它的异常一样可以用 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 数据类型来表示。另一方面，由于有这么多类型的I/O异常，有一个特殊的模块– <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 专门用于处理它们。</p>
<p><code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 定义了两个函数： <code class="docutils literal notranslate"><span class="pre">catch</span></code> 和 <code class="docutils literal notranslate"><span class="pre">try</span></code> ，跟 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 中的类似，它们都是用于处理异常的。然而，不像 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 中的函数，这些函数只会捕获I/O错误，而不处理其它类型异常。在Haskell中，所有I/O错误有一个共同类型 <code class="docutils literal notranslate"><span class="pre">IOError</span></code> ，它的定义跟 <code class="docutils literal notranslate"><span class="pre">IOException</span></code> 是一样的。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>当心你使用的哪个名字
因为 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 定义了同样名字的函数，如果你将它们都导入你的程序，你将收到一个错误信息说引用的函数有歧义。你可以通过 <code class="docutils literal notranslate"><span class="pre">qualified</span></code> 引用其中一个或者另一个，或者将其中一个或者另一个的符号隐藏。</p>
<p>注意 <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> 导出的是 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">catch</span></code> ，而不是 <code class="docutils literal notranslate"><span class="pre">ControlException</span></code> 中提供的。记住，前者只捕获I/O错误，而后者捕获所有的异常。换句话说， 你要的几乎总是 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 中的那个 <code class="docutils literal notranslate"><span class="pre">catch</span></code> ，而不是默认的那个。</p>
</div>
<p>让我们看一下对我们有益的一个在I/O系统中使用异常的方法。在 <a class="reference external" href="http://rwh.readthedocs.org/en/latest/chp/7.html#handle">使用文件和句柄</a> 这一节里，我们展示了一个使用命令式风格从文件中一行一行的读取的程序。尽管我们后面也示范过更简洁的，更”Haskelly”的方式解决那个问题，让我们在这里重新审视这个例子。在 <code class="docutils literal notranslate"><span class="pre">mainloop</span></code> 函数中，在读一行之前，我们必须明确地测试我们的输入文件是否结束。这次，我们可以检查尝试读一行是否会导致一个EOF错误，像这样子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/toupper-impch20.hs</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.IO.Error</span>
<span class="kr">import</span> <span class="nn">Data.Char</span><span class="p">(</span><span class="n">toUpper</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
       <span class="n">inh</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;input.txt&quot;</span> <span class="kt">ReadMode</span>
       <span class="n">outh</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;output.txt&quot;</span> <span class="kt">WriteMode</span>
       <span class="n">mainloop</span> <span class="n">inh</span> <span class="n">outh</span>
       <span class="n">hClose</span> <span class="n">inh</span>
       <span class="n">hClose</span> <span class="n">outh</span>

<span class="nf">mainloop</span> <span class="ow">::</span> <span class="kt">Handle</span> <span class="ow">-&gt;</span> <span class="kt">Handle</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">mainloop</span> <span class="n">inh</span> <span class="n">outh</span> <span class="ow">=</span> 
    <span class="kr">do</span> <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">hGetLine</span> <span class="n">inh</span><span class="p">)</span>
       <span class="kr">case</span> <span class="n">input</span> <span class="kr">of</span>
         <span class="kt">Left</span> <span class="n">e</span> <span class="ow">-&gt;</span> 
             <span class="kr">if</span> <span class="n">isEOFError</span> <span class="n">e</span>
                <span class="kr">then</span> <span class="n">return</span> <span class="nb">()</span>
                <span class="kr">else</span> <span class="n">ioError</span> <span class="n">e</span>
         <span class="kt">Right</span> <span class="n">inpStr</span> <span class="ow">-&gt;</span>
             <span class="kr">do</span> <span class="n">hPutStrLn</span> <span class="n">outh</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span> <span class="n">inpStr</span><span class="p">)</span>
                <span class="n">mainloop</span> <span class="n">inh</span> <span class="n">outh</span>
</pre></div>
</div>
<p>这里，我们使用 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">try</span></code> 来检测是否 <code class="docutils literal notranslate"><span class="pre">hGetLine</span></code> 抛出一个 <code class="docutils literal notranslate"><span class="pre">IOError</span></code> 。如果是，我们使用 <code class="docutils literal notranslate"><span class="pre">isEOFError</span></code> （在 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 中定义）来看是否抛出异常表明我们到达了文件末尾。如果是的，我们退出循环。如果是其它的异常，我们调用 <code class="docutils literal notranslate"><span class="pre">ioError</span></code> 重新抛出它。</p>
<p>有许多的这种测试和方法可以从 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 中定义的 <code class="docutils literal notranslate"><span class="pre">IOError</span></code> 中提取信息。我们推荐你在需要的时候去查一下库的参考页。</p>
</section>
<section id="id10">
<h3>抛出异常<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>到现在为止，我们已经详细地讨论了异常处理。还有另外一个困惑：抛出异常。到目前为止这一章我们所接触到的例子中，都是由Haskell为你抛出异常的。然后你也可以自己抛出任何异常。我们会告诉你怎么做。</p>
<p>你将会注意到这些函数大部分似乎返回一个类型为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code> 的值。这意味着这个函数似乎可以返回任意类型的值。事实上，由于这些函数会抛出异常，一般情况下它们决不“返回”任何东西。这些返回值让你可以在各种各样的上下文中使用这些函数，不同的上下文需要不同的类型。</p>
<p>让我们使用函数 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 来开始我们的抛出异常的教程。最通用的函数是 <code class="docutils literal notranslate"><span class="pre">throw</span></code> ，它的类型是 <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> 。这个函数可以抛出任何的 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> ，并且可以用于纯的上下文中。还有一个类型为 <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code> 的函数 <code class="docutils literal notranslate"><span class="pre">throwIO</span></code> 在 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中抛出异常。这两个函数都需要一个 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 用于抛出。你可以手工制作一个 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> ，或者重用之前创建的 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 。</p>
<p>还有一个函数 <code class="docutils literal notranslate"><span class="pre">ioError</span></code> ，它在 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 和 <code class="docutils literal notranslate"><span class="pre">System.IO.Error</span></code> 中定义都是相同的，它的类型是 <code class="docutils literal notranslate"><span class="pre">IOError</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code> 。当你想生成任意的I/O相关的异常的时候可以使用它。</p>
</section>
<section id="id11">
<h3>动态异常<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>这需要使用两个很不常用的Haskell模块: <code class="docutils literal notranslate"><span class="pre">Data.Dynamic</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Data.Typeable</span></code> 。我们不会讲太多关于这些模块，但是告诉你当你需要制作自己的动态异常类型时，可以使用这些工具。</p>
<p>在 <a class="reference external" href="第二十一章使用数据库http://book.realworldhaskell.org/read/using-databases.html">第二十一章使用数据库http://book.realworldhaskell.org/read/using-databases.html</a> 中，你会看到HDBC数据库库使用动态异常来表示SQL数据库返回给应用的错误。数据库引擎返回的错误通常有三个组件：一个表示错误码的整数，一个状态，以及一条人类可读的错误消息。在这一章中我们会创建我们自己的HDBC <code class="docutils literal notranslate"><span class="pre">SqlError</span></code> 实现。让我们从错误自身的数据结构表示开始：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/dynexc.hs</span>
<span class="cm">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kr">import</span> <span class="nn">Data.Dynamic</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span>

<span class="kr">data</span> <span class="kt">SqlError</span> <span class="ow">=</span> <span class="kt">SqlError</span> <span class="p">{</span><span class="n">seState</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span>
                          <span class="n">seNativeError</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span>
                          <span class="n">seErrorMsg</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">)</span>
</pre></div>
</div>
<p>通过继承 <code class="docutils literal notranslate"><span class="pre">Typeable</span></code> 类型类，我们使这个类型可用于动态的类型编程。为了让GHC自动生成一个 <code class="docutils literal notranslate"><span class="pre">Typeable</span></code> 实例，我们要开启 <code class="docutils literal notranslate"><span class="pre">DeriveDataTypeable</span></code> 语言扩展。</p>
<p>现在，让我们定义一个 <code class="docutils literal notranslate"><span class="pre">catchSql</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">handleSql</span></code> 用于捕猎一个 <code class="docutils literal notranslate"><span class="pre">SqlError</span></code> 异常。注意常规的 <code class="docutils literal notranslate"><span class="pre">catch</span></code> 和 <code class="docutils literal notranslate"><span class="pre">handle</span></code> 函数无法捕猎我们的 <code class="docutils literal notranslate"><span class="pre">SqlError</span></code> ，因为它不是 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 类型的。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/dynexc.hs</span>
<span class="cm">{- | Execute the given IO action.</span>

<span class="cm">If it raises a &#39;SqlError&#39;, then execute the supplied </span>
<span class="cm">handler and return its return value.  Otherwise, proceed</span>
<span class="cm">as normal. -}</span>
<span class="nf">catchSql</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">SqlError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">catchSql</span> <span class="ow">=</span> <span class="n">catchDyn</span>

<span class="cm">{- | Like &#39;catchSql&#39;, with the order of arguments reversed. -}</span>
<span class="nf">handleSql</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">SqlError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">handleSql</span> <span class="ow">=</span> <span class="n">flip</span> <span class="n">catchSql</span>
</pre></div>
</div>
<p>[译注：原文中文件名是dynexc.hs，但是跟前面的冲突了，所以这里重命名为dynexc1.hs]</p>
<p>这些函数仅仅是在 <code class="docutils literal notranslate"><span class="pre">catchDyn</span></code> 外面包了很薄的一层，类型是 <code class="docutils literal notranslate"><span class="pre">Typeable</span> <span class="pre">exception</span> <span class="pre">=&gt;</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(exception</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code> 。这里我们简单地限定了它的类型使得它只捕猎SQL异常。</p>
<p>正常地，当一个异常抛出，但是没有在任何地方被捕获，程序会崩溃并显示异常到标准错误输出。然而，对于动态异常，系统不会知道该如何显示它，因此你将仅仅会看到一个的”unknown exception”消息，这可能没太大帮助。我们可以提供一个辅助函数，这样应用可以写成，比如说 <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">=</span> <span class="pre">handleSqlError</span> <span class="pre">$</span> <span class="pre">do</span> <span class="pre">...</span></code> ，使抛出的异常可以显示。下面是如何写 <code class="docutils literal notranslate"><span class="pre">handleSqlError</span></code> ：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/dynexc.hs</span>
<span class="cm">{- | Catches &#39;SqlError&#39;s, and re-raises them as IO errors with fail.</span>
<span class="cm">Useful if you don&#39;t care to catch SQL errors, but want to see a sane</span>
<span class="cm">error message if one happens.  One would often use this as a </span>
<span class="cm">high-level wrapper around SQL calls. -}</span>
<span class="nf">handleSqlError</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">handleSqlError</span> <span class="n">action</span> <span class="ow">=</span>
    <span class="n">catchSql</span> <span class="n">action</span> <span class="n">handler</span>
    <span class="kr">where</span> <span class="n">handler</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">fail</span> <span class="p">(</span><span class="s">&quot;SQL error: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：原文中是dynexc.hs，这里重命名过文件]</p>
<p>最后，让我们给出一个如何抛出 <code class="docutils literal notranslate"><span class="pre">SqlError</span></code> 异常的例子。下面的函数做的就是这件事：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/dynexc.hs</span>
<span class="nf">throwSqlError</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">throwSqlError</span> <span class="n">state</span> <span class="n">nativeerror</span> <span class="n">errormsg</span> <span class="ow">=</span>
    <span class="n">throwDyn</span> <span class="p">(</span><span class="kt">SqlError</span> <span class="n">state</span> <span class="n">nativeerror</span> <span class="n">errormsg</span><span class="p">)</span>

<span class="nf">throwSqlErrorIO</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">throwSqlErrorIO</span> <span class="n">state</span> <span class="n">nativeerror</span> <span class="n">errormsg</span> <span class="ow">=</span>
    <span class="n">evaluate</span> <span class="p">(</span><span class="n">throwSqlError</span> <span class="n">state</span> <span class="n">nativeerror</span> <span class="n">errormsg</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>提醒一下， <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> 跟 <code class="docutils literal notranslate"><span class="pre">return</span></code> 类似但是会立即计算它的参数。</p>
</div>
<p>这样我们的动态异常的支持就完成了。代码很多，你大概不需要这么多代码，但是我们想要给你一个动态异常自身的例子以及和它相关的工具。事实上，这里的例子几乎就反映在HDBC库中。让我们在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中试一下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">dynexc</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">dynexc</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">throwSqlErrorIO</span> <span class="s">&quot;state&quot;</span> <span class="mi">5</span> <span class="s">&quot;error message&quot;</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="p">(</span><span class="n">unknown</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handleSqlError</span> <span class="o">$</span> <span class="n">throwSqlErrorIO</span> <span class="s">&quot;state&quot;</span> <span class="mi">5</span> <span class="s">&quot;error message&quot;</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">user</span> <span class="ne">error</span> <span class="p">(</span><span class="kt">SQL</span> <span class="ne">error</span><span class="kt">:</span> <span class="kt">SqlError</span> <span class="p">{</span><span class="n">seState</span> <span class="ow">=</span> <span class="s">&quot;state&quot;</span><span class="p">,</span> <span class="n">seNativeError</span> <span class="ow">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">seErrorMsg</span> <span class="ow">=</span> <span class="s">&quot;error message&quot;</span><span class="p">})</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handleSqlError</span> <span class="o">$</span> <span class="n">fail</span> <span class="s">&quot;other error&quot;</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">user</span> <span class="ne">error</span> <span class="p">(</span><span class="n">other</span> <span class="ne">error</span><span class="p">)</span>
</pre></div>
</div>
<p>这里你可以看出， <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 自己并不知道如何显示SQL错误。但是，你可以看到 <code class="docutils literal notranslate"><span class="pre">handleSqlError</span></code> 帮助做了这些，不过没有捕获其它的错误。最后让我们试一个自定义的handler：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">handleSql</span> <span class="p">(</span><span class="n">fail</span> <span class="o">.</span> <span class="n">seErrorMsg</span><span class="p">)</span> <span class="p">(</span><span class="n">throwSqlErrorIO</span> <span class="s">&quot;state&quot;</span> <span class="mi">5</span> <span class="s">&quot;my error&quot;</span><span class="p">)</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="n">user</span> <span class="ne">error</span> <span class="p">(</span><span class="n">my</span> <span class="ne">error</span><span class="p">)</span>
</pre></div>
</div>
<p>这里，我们自定义了一个错误处理抛出一个新的异常，构成 <code class="docutils literal notranslate"><span class="pre">SqlError</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">seErrorMsg</span></code> 域。你可以看到它是按预想中那样工作的。</p>
</section>
</section>
<section id="id12">
<h2>练习<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>将 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 修改成 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 例子中的那种风格，使它保存惰性。</p></li>
</ol>
</section>
<section id="monad">
<h2>monad中的错误处理<a class="headerlink" href="#monad" title="Permalink to this headline">¶</a></h2>
<p>因为我们必须捕获 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中的异常，如果我们在一个monad中或者在monad的转化栈中使用它们，我们将跳出到 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad。这几乎肯定不是我们想要的。</p>
<p>在 <a class="reference external" href="http://rwh.readthedocs.org/en/latest/chp/18.html#id9">构建以理解Monad变换器</a> 中我们定义了一个 <code class="docutils literal notranslate"><span class="pre">MaybeT</span></code> 的变换，但是它更像是一个有助于理解的东西，而不是编程的工具。幸运的是，已经有一个专门的–也更有用的–monad变换： <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> ，它是定义在 <code class="docutils literal notranslate"><span class="pre">Control.Monad.Error</span></code> 模块中的。</p>
<p><code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 变换器使我们可以向monad中添加异常，但是它使用了特殊的方法，跟 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 模块中提供的不一样。它提供给我们一些有趣的能力。</p>
<ul class="simple">
<li><p>如果我们继续用 <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 接口，在这个monad中我们可以抛出和捕获异常。</p></li>
<li><p>根据其它monad变换器的命名规范，这个执行函数的名字是 <code class="docutils literal notranslate"><span class="pre">runErrorT</span></code> 。当它遇到 <code class="docutils literal notranslate"><span class="pre">runErrorT</span></code> 之后，未被捕获的 <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 异常将停止向上传递。我们不会被踢到 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中。</p></li>
<li><p>我们可以控制我们的异常的类型。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>不要把ErrorT跟普通异常混淆
如果我们在 <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 内面使用 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">throw</span></code> 函数，我们仍然会弹出到 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad。</p>
</div>
<p>正如其它的 <code class="docutils literal notranslate"><span class="pre">mtl</span></code> monad一样， <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 提供的接口是由一个类型类定义的。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/MonadError.hs</span>
<span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadError</span> <span class="n">e</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="kr">where</span>
    <span class="n">throwError</span> <span class="ow">::</span> <span class="n">e</span>             <span class="c1">-- error to throw</span>
               <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>

    <span class="n">catchError</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span>           <span class="c1">-- action to execute</span>
               <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>    <span class="c1">-- error handler</span>
               <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>类型变量 <code class="docutils literal notranslate"><span class="pre">e</span></code> 代表我们想要使用的错误类型。不管我们的错误类型是什么，我们必须将它做成 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 类型类的实例。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/MonadError.hs</span>
<span class="kr">class</span> <span class="kt">Error</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="c1">-- create an exception with no message</span>
    <span class="n">noMsg</span>  <span class="ow">::</span> <span class="n">a</span>

    <span class="c1">-- create an exception with a message</span>
    <span class="n">strMsg</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 实现 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 时会用到 <code class="docutils literal notranslate"><span class="pre">strMsg</span></code> 函数。它将 <code class="docutils literal notranslate"><span class="pre">strMsg</span></code> 作为一个异常抛出，将自己接收到的字符串参数传递给这个异常。对于 <code class="docutils literal notranslate"><span class="pre">noMsg</span></code> ，它是用于提供 <code class="docutils literal notranslate"><span class="pre">MonadPlus</span></code> 类型类中的 <code class="docutils literal notranslate"><span class="pre">mzero</span></code> 的实现。</p>
<p>为了支持 <code class="docutils literal notranslate"><span class="pre">strMsg</span></code> 和 <code class="docutils literal notranslate"><span class="pre">noMsg</span></code> 函数，我们的 <code class="docutils literal notranslate"><span class="pre">ParseError</span></code> 类型会有一个 <code class="docutils literal notranslate"><span class="pre">Chatty</span></code> 构造器。这个将用作构造器如果，比如说，有人在我们的monad中调用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 。</p>
<p>我们需要知道的最后一块是关于执行函数 <code class="docutils literal notranslate"><span class="pre">runErrorT</span></code> 的类型。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">runErrorT</span>
<span class="nf">runErrorT</span> <span class="ow">::</span> <span class="kt">ErrorT</span> <span class="n">e</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<section id="id14">
<h3>一个小的解析构架<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>为了说明 <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 的使用，让我们开发一个类似于Parsec的解析库的基本的骨架。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/ParseInt.hs</span>
<span class="cm">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Error</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Char8</span> <span class="k">as</span> <span class="n">B</span>

<span class="kr">data</span> <span class="kt">ParseError</span> <span class="ow">=</span> <span class="kt">NumericOverflow</span>
            <span class="o">|</span> <span class="kt">EndOfInput</span>
            <span class="o">|</span> <span class="kt">Chatty</span> <span class="kt">String</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Error</span> <span class="kt">ParseError</span> <span class="kr">where</span>
    <span class="n">noMsg</span>  <span class="ow">=</span> <span class="kt">Chatty</span> <span class="s">&quot;oh noes!&quot;</span>
    <span class="n">strMsg</span> <span class="ow">=</span> <span class="kt">Chatty</span>
</pre></div>
</div>
<p>对于我们解析器的状态，我们会创建一个非常小的monad变换器栈。一个 <code class="docutils literal notranslate"><span class="pre">State</span></code> monad包含了需要解析的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> ，在栈的顶部是 <code class="docutils literal notranslate"><span class="pre">ErrorT</span></code> 用于提供错误处理。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/ParseInt.hs</span>
<span class="kr">newtype</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">P</span> <span class="p">{</span>
      <span class="n">runP</span> <span class="ow">::</span> <span class="kt">ErrorT</span> <span class="kt">ParseError</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span> <span class="n">a</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Monad</span><span class="p">,</span> <span class="kt">MonadError</span> <span class="kt">ParseError</span><span class="p">)</span>
</pre></div>
</div>
<p>和平常一样，我们将我们的monad栈包装在一个 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 中。这样做没有任意性能损耗，但是增加了类型安全。我们故意避免继承 <code class="docutils literal notranslate"><span class="pre">MonadState</span> <span class="pre">B.ByteString</span></code> 的实例。这意味着 <code class="docutils literal notranslate"><span class="pre">Parser</span></code> monad用户将不能够使用 <code class="docutils literal notranslate"><span class="pre">get</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">put</span></code> 去查询或者修改解析器的状态。这样的结果是，我们强制自己去做一些手动提升的事情来获取在我们栈中的 <code class="docutils literal notranslate"><span class="pre">State</span></code> monad。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/ParseInt.hs</span>
<span class="nf">liftP</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="nf">liftP</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">P</span> <span class="p">(</span><span class="n">lift</span> <span class="n">m</span><span class="p">)</span>

<span class="nf">satisfy</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="nf">satisfy</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftP</span> <span class="n">get</span>
  <span class="kr">case</span> <span class="kt">B</span><span class="o">.</span><span class="n">uncons</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>         <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="kt">EndOfInput</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">p</span> <span class="n">c</span>       <span class="ow">-&gt;</span> <span class="n">liftP</span> <span class="p">(</span><span class="n">put</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">c</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="p">(</span><span class="kt">Chatty</span> <span class="s">&quot;satisfy failed&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">catchError</span></code> 函数对于我们的任何非常有用，远胜于简单的错误处理。例如，我们可以很轻松地解除一个异常，将它变成更友好的形式。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/ParseInt.hs</span>
<span class="nf">optional</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">optional</span> <span class="n">p</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="n">catchError</span><span class="p">`</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>我们的执行函数仅仅是将各层连接起来，将结果重新组织成更整洁的形式。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch19/ParseInt.hs</span>
<span class="nf">runParser</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span>
          <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">ParseError</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="nf">runParser</span> <span class="n">p</span> <span class="n">bs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">runState</span> <span class="p">(</span><span class="n">runErrorT</span> <span class="p">(</span><span class="n">runP</span> <span class="n">p</span><span class="p">))</span> <span class="n">bs</span> <span class="kr">of</span>
                   <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
                   <span class="p">(</span><span class="kt">Right</span> <span class="n">r</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span>
</pre></div>
</div>
<p>如果我们将它加载到 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 中，我们可以对它进行了一些测试。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">satisfy</span> <span class="n">isDigit</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">array</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.9</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runParser</span> <span class="n">p</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="kt">Left</span> <span class="p">(</span><span class="kt">Chatty</span> <span class="s">&quot;satisfy failed&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runParser</span> <span class="n">p</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;9abc&quot;</span><span class="p">)</span>
<span class="kt">Right</span> <span class="p">(</span><span class="sc">&#39;9&#39;</span><span class="p">,</span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runParser</span> <span class="p">(</span><span class="n">optional</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="kt">Right</span> <span class="p">(</span><span class="kt">Nothing</span><span class="p">,</span><span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runParser</span> <span class="p">(</span><span class="n">optional</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;9a&quot;</span><span class="p">)</span>
<span class="kt">Right</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id15">
<h3>练习<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>写一个 <code class="docutils literal notranslate"><span class="pre">many</span></code> 解析器，类型是 <code class="docutils literal notranslate"><span class="pre">Parser</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Parser</span> <span class="pre">[a]</span></code> 。它应该执行解析直到失败。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">many</span></code> 写一个 <code class="docutils literal notranslate"><span class="pre">int</span></code> 解析器，类型是 <code class="docutils literal notranslate"><span class="pre">Parser</span> <span class="pre">Int</span></code> 。它应该既能接受负数也能接受正数。</p></li>
<li><p>修改你们 <code class="docutils literal notranslate"><span class="pre">int</span></code> 解析器，如果在解析时检测到了一个数值溢出，抛出一个 <code class="docutils literal notranslate"><span class="pre">NumericOverflow</span></code> 异常。</p></li>
</ol>
<p class="rubric">注</p>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets">38</span></dt>
<dd><p>这里我们使用的是整数的除法，因此 50 / 8 显示是 6 而不是 6.25 。在这个例子中我们没有使用浮点算术是因为对一个 <code class="docutils literal notranslate"><span class="pre">Double</span></code> 除以零会返回一个特殊的 <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> 而不是一个错误。</p>
</dd>
<dt class="label" id="id17"><span class="brackets">39</span></dt>
<dd><p>关于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 的介绍，参考`&lt;让过程更可控的方法 <a class="reference external" href="http://rwh.readthedocs.org/en/latest/chp/3.html#id21">http://rwh.readthedocs.org/en/latest/chp/3.html#id21</a>&gt;`_</p>
</dd>
<dt class="label" id="id18"><span class="brackets">40</span></dt>
<dd><p>更多关于 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 的信息，参考`&lt;通过 API 设计进行错误处理 <a class="reference external" href="http://rwh.readthedocs.org/en/latest/chp/8.html#api">http://rwh.readthedocs.org/en/latest/chp/8.html#api</a>&gt;`_</p>
</dd>
<dt class="label" id="id19"><span class="brackets">41</span></dt>
<dd><p>在一些其它语言中，抛出异常是叫做 raising 。</p>
</dd>
<dt class="label" id="id20"><span class="brackets">42</span></dt>
<dd><p>可以手动继承 <code class="docutils literal notranslate"><span class="pre">Typeable</span></code> 实例，但是那样很麻烦。</p>
</dd>
</dl>
</section>
</section>
</section>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="18.html">第 18 章： Monad变换器</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="20.html">第 20 章：使用 Haskell 进行系统编程</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, huangz1990.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>