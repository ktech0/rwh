<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>第 14 章：Monads &#8212; Real World Haskell 中文版</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="第 15 章：使用 Monad 编程" href="15.html" />
    <link rel="prev" title="第 13 章：数据结构" href="13.html" /> 
  </head><body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="13.html">第 13 章：数据结构</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="15.html">第 15 章：使用 Monad 编程</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <section id="monads">
<h1>第 14 章：Monads<a class="headerlink" href="#monads" title="Permalink to this headline">¶</a></h1>
<section id="id1">
<h2>简介<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在 <a class="reference internal" href="7.html"><span class="doc">第 7 章：I/O</span></a> 中，我们讨论了 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad，那时我们刻意把精力集中在如何与外界交互上，并没有讨论monad是什么。</p>
<p>在 <a class="reference internal" href="7.html"><span class="doc">第 7 章：I/O</span></a> 中我们看到 <code class="docutils literal notranslate"><span class="pre">IO</span></code> Monad确实很好用；除了在语法上不同之外，在 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中写代码跟其他命令式语言基本没有什么区别。</p>
<p>在前面的章节中，我们在解决一些实际问题的时候引入了一些数据结构，很快我们就会知道它们其实就是monads。我们想告诉你的是，在解决某些问题的时候，monad通常是一个非常直观且实用的工具。本章我们将定义一些monads并告诉你它有多么简单。</p>
</section>
<section id="revisiting-earlier-code-examples">
<span id="id2"></span><h2>回顾之前代码<a class="headerlink" href="#revisiting-earlier-code-examples" title="Permalink to this headline">¶</a></h2>
<section id="maybe">
<span id="maybe-chaining"></span><h3>Maybe链<a class="headerlink" href="#maybe" title="Permalink to this headline">¶</a></h3>
<p>我们先看看我们在 <a class="reference internal" href="10.html"><span class="doc">第 10 章：代码案例学习：解析二进制数据格式</span></a> 写的 <code class="docutils literal notranslate"><span class="pre">parseP5</span></code> 函数:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/PNM.hs</span>
<span class="nf">matchHeader</span> <span class="ow">::</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span>

<span class="c1">-- &quot;nat&quot; here is short for &quot;natural number&quot;</span>
<span class="nf">getNat</span> <span class="ow">::</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>

<span class="nf">getBytes</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span>
         <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">,</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>

    <span class="n">parseP5</span> <span class="n">s</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">matchHeader</span> <span class="p">(</span><span class="kt">L8</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;P5&quot;</span><span class="p">)</span> <span class="n">s</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kt">Just</span> <span class="n">s1</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">getNat</span> <span class="n">s1</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">-&gt;</span>
              <span class="kr">case</span> <span class="n">getNat</span> <span class="p">(</span><span class="kt">L8</span><span class="o">.</span><span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">s2</span><span class="p">)</span> <span class="kr">of</span>
                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span> <span class="ow">-&gt;</span>
                  <span class="kr">case</span> <span class="n">getNat</span> <span class="p">(</span><span class="kt">L8</span><span class="o">.</span><span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">s3</span><span class="p">)</span> <span class="kr">of</span>
                    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                    <span class="kt">Just</span> <span class="p">(</span><span class="n">maxGrey</span><span class="p">,</span> <span class="n">s4</span><span class="p">)</span>
                      <span class="o">|</span> <span class="n">maxGrey</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                      <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">-&gt;</span>
                          <span class="kr">case</span> <span class="n">getBytes</span> <span class="mi">1</span> <span class="n">s4</span> <span class="kr">of</span>
                            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                            <span class="kt">Just</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">s5</span><span class="p">)</span> <span class="ow">-&gt;</span>
                              <span class="kr">case</span> <span class="n">getBytes</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="n">s5</span> <span class="kr">of</span>
                                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                                <span class="kt">Just</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">s6</span><span class="p">)</span> <span class="ow">-&gt;</span>
                                  <span class="kt">Just</span> <span class="p">(</span><span class="kt">Greymap</span> <span class="n">width</span> <span class="n">height</span> <span class="n">maxGrey</span> <span class="n">bitmap</span><span class="p">,</span> <span class="n">s6</span><span class="p">)</span>
</pre></div>
</div>
<p>这个函数要是再复杂一点，就要超出屏幕的右边了；当时我们使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 操作符避免了这种情况:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/PNM.hs</span>
<span class="p">(</span><span class="o">&gt;&gt;?</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="kt">Nothing</span> <span class="o">&gt;&gt;?</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="kt">Just</span> <span class="n">v</span>  <span class="o">&gt;&gt;?</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">v</span>
</pre></div>
</div>
<p>我们对 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 操作符的类型进行了精挑细选使得它能把一系列返回类型是 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 的函数串联起来；只要一个函数的返回值能和下一个函数的参数类型匹配，我们就能无限串联返回类型是 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 的函数。 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 的函数体把细节隐藏了起来，我们不知道我们通过 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 串联的函数是由于中间某个函数返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 而中断了还是所有函数全部执行了。</p>
</section>
<section id="implicit-state">
<span id="id3"></span><h3>隐式状态<a class="headerlink" href="#implicit-state" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 被用来整理 <code class="docutils literal notranslate"><span class="pre">parseP5</span></code> 的结构，但是在解析的时候我们还是要一点一点地处理输入字符串；这使得我们必须把当前处理的值通过一个元组传递下去[若干个函数串联了起来，都返回Maybe，作者称之为Maybe链]。Maybe链上的每一个函数把自己处理的结果以及自己没有解析的剩下的字符串放到元组里面, 并传递下去。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/PNM.hs</span>
<span class="nf">parseP5_take2</span> <span class="ow">::</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Greymap</span><span class="p">,</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="nf">parseP5_take2</span> <span class="n">s</span> <span class="ow">=</span>
    <span class="n">matchHeader</span> <span class="p">(</span><span class="kt">L8</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;P5&quot;</span><span class="p">)</span> <span class="n">s</span>       <span class="o">&gt;&gt;?</span>
    <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">skipSpace</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>           <span class="o">&gt;&gt;?</span>
    <span class="p">(</span><span class="n">getNat</span> <span class="o">.</span> <span class="n">snd</span><span class="p">)</span>                    <span class="o">&gt;&gt;?</span>
    <span class="n">skipSpace</span>                         <span class="o">&gt;&gt;?</span>
    <span class="nf">\</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span>   <span class="n">getNat</span> <span class="n">s</span>         <span class="o">&gt;&gt;?</span>
    <span class="n">skipSpace</span>                         <span class="o">&gt;&gt;?</span>
    <span class="nf">\</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span>  <span class="n">getNat</span> <span class="n">s</span>         <span class="o">&gt;&gt;?</span>
    <span class="nf">\</span><span class="p">(</span><span class="n">maxGrey</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">getBytes</span> <span class="mi">1</span> <span class="n">s</span>     <span class="o">&gt;&gt;?</span>
    <span class="p">(</span><span class="n">getBytes</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">.</span> <span class="n">snd</span><span class="p">)</span> <span class="o">&gt;&gt;?</span>
    <span class="nf">\</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Greymap</span> <span class="n">width</span> <span class="n">height</span> <span class="n">maxGrey</span> <span class="n">bitmap</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="nf">skipSpace</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="nf">skipSpace</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">L8</span><span class="o">.</span><span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>我们又碰到了有着重复行为的模式：处理字符串的时候，某个函数消耗部分字符串并返回它处理的结果，同时把剩下的字符串传递给下一个函数继续处理。但是，这个模式比之前的更糟糕：如果我们要在处理链往下传递另外一些额外信息，我们必须把传递的二元组修改为三元组，这几乎要修改这个处理链上的所有元素！</p>
<p>我们把管理当前字符串的任务从处理链上的单个函数移出来，将它(管理字符串)转交给串联这些单个函数的函数完成！[译：比如上面的 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code>]</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/Parse.hs</span>
<span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Parse</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">b</span>

<span class="nf">firstParser</span> <span class="o">==&gt;</span> <span class="n">secondParser</span>  <span class="ow">=</span>  <span class="kt">Parse</span> <span class="n">chainedParser</span>
  <span class="kr">where</span> <span class="n">chainedParser</span> <span class="n">initState</span>   <span class="ow">=</span>
          <span class="kr">case</span> <span class="n">runParse</span> <span class="n">firstParser</span> <span class="n">initState</span> <span class="kr">of</span>
            <span class="kt">Left</span> <span class="n">errMessage</span> <span class="ow">-&gt;</span>
                <span class="kt">Left</span> <span class="n">errMessage</span>
            <span class="kt">Right</span> <span class="p">(</span><span class="n">firstResult</span><span class="p">,</span> <span class="n">newState</span><span class="p">)</span> <span class="ow">-&gt;</span>
                <span class="n">runParse</span> <span class="p">(</span><span class="n">secondParser</span> <span class="n">firstResult</span><span class="p">)</span> <span class="n">newState</span>
</pre></div>
</div>
<p>我们把解析状态的细节隐藏在 <code class="docutils literal notranslate"><span class="pre">ParseState</span></code> 类型中，就连 <code class="docutils literal notranslate"><span class="pre">getState</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putState</span></code>  都不会窥视解析状态，所以，无论对 <code class="docutils literal notranslate"><span class="pre">ParseState</span></code> 做怎样的修改都不会影响已有的代码。</p>
</section>
</section>
<section id="looking-for-shared-patterns">
<span id="id4"></span><h2>寻找共同特征<a class="headerlink" href="#looking-for-shared-patterns" title="Permalink to this headline">¶</a></h2>
<p>如果我们仔细分析上面的例子，它们好像没有什么共同特点。不过有一点比较明显，它们都想把函数串联起来并试图隐藏细节以便我们写出整洁的代码。然后，我们先不管那些细节，从更粗略的层面去思考一下。</p>
<p>首先，我们看一看类型声明：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span>
             <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch11/Parse.hs</span>
<span class="kr">newtype</span> <span class="kt">Parse</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Parse</span> <span class="p">{</span>
      <span class="n">runParse</span> <span class="ow">::</span> <span class="kt">ParseState</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">ParseState</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>这两个类型的共同特点是它们都有一个类型参数，因此它们都是范型，对具体的类型一无所知。</p>
<p>然后看一看我们给两个类型写的串联函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">&gt;&gt;?</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;?</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Parse</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">b</span>
</pre></div>
</div>
<p>这两个函数的类型非常相似，如果我们把它们的类型构造器替换为一个类型变量，我们会得到一个更加抽象的类型。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="nf">chain</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>最终，在两种情况下，我们都得到了一个获取一个普通的值，然后把它“注入”到一个目标类型里面去的函数。对于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型，这个函数就是它的一个值构造器 <code class="docutils literal notranslate"><span class="pre">Just</span></code> ，<a href="#id5"><span class="problematic" id="id6">``</span></a>Parse``的注入函数就略微复杂一些。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/Parse.hs</span>
<span class="nf">identity</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">a</span>
<span class="nf">identity</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Parse</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>我们不用关心它的实现细节，也不管它有多么复杂；重要的是，这些类型都有一个“注入器”函数，它大致长这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="nf">inject</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>在Haskell里面，正是这三个属性和一些如何使用它们的规则定义了monad。我们集中总结一下：</p>
<ol class="arabic simple">
<li><p>一个类型构造器 <code class="docutils literal notranslate"><span class="pre">m</span></code></p></li>
<li><p>一个用于把某个函数的输出串联到另外一个函数输入上的函数，它的类型是 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></code></p></li>
<li><p>一个类型是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> 类型的函数，它把普通值注入到调用链里面，也就是说，它把类型 <code class="docutils literal notranslate"><span class="pre">a</span></code> 用类型构造器 <code class="docutils literal notranslate"><span class="pre">m</span></code> 包装起来。</p></li>
</ol>
<p>Maybe 类型的类型构造器 <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> ,串联函数 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;?)</span></code> 以及注入函数 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 使Maybe成为一个monad。对于 <code class="docutils literal notranslate"><span class="pre">Parse</span></code> 类型，对应的是类型构造器 <code class="docutils literal notranslate"><span class="pre">Parse</span> <span class="pre">a</span></code> ,串联函数 <code class="docutils literal notranslate"><span class="pre">Parse</span> <span class="pre">a</span></code> 以及注入函数 <code class="docutils literal notranslate"><span class="pre">identify</span></code> 。</p>
<p>对于Monad的串联函数和注入函数具体应该干什么我们刻意只字未提，因为它几乎不重要。事实上，正是因为Monad如此简单，它在Haskell里面无处不在。许多常见的编程模式都用到了monad结构：传递隐式数据，或是短路求值链。</p>
</section>
<section id="monad">
<span id="the-monad-typeclass"></span><h2>Monad 类型类<a class="headerlink" href="#monad" title="Permalink to this headline">¶</a></h2>
<p>在Haskell里面我们可以使用一个类型类(typeclass)来表示“串联”以及“注入”的概念以及它们的类型。标准库的Predule模块已经包含了这样一个类型类，也就是 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="c1">-- chain</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
    <span class="c1">-- inject</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>在这里，<code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 就是我们的串联函数。 在 <a class="reference internal" href="7.html#sequencing"><span class="std std-ref">串联化（Sequencing）</span></a> 中我们已经介绍了它。通常将这个操作符称呼为“绑定”，因为它把左侧运算的结果绑定到右侧运算的参数上。</p>
<p>我们的注入函数是 <code class="docutils literal notranslate"><span class="pre">return</span></code> ,在 <a class="reference internal" href="7.html#the-nature-of-return"><span class="std std-ref">Return的本色</span></a> 中讲过，选用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 这个名字有点倒霉。这个关键字在命令式语言中被广泛使用并且有一个非常容易理解的含义。但是在Haskell里面它的含义完全不同；具体来说，在函数调用链中间使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 并不会导致调用链提前中止；我们可以这样理解它：它把纯值( <code class="docutils literal notranslate"><span class="pre">a</span></code> 类型)放进(returns)monads( <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code> 类型)里。</p>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 这个类型类的核心函数；除此之外，它还定义了另外两个函数。一个函数是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> ，类似于 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> ，它的作用也是串联，但是它忽略左侧的值。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
        <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">f</span>
</pre></div>
</div>
<p>当我们需要按顺序执行一系列操作的，并且不关心先前的计算结果的时候，可以使用这操作符。这样也许看起来让人觉得费解：为什么我们会忽略一个函数的返回值呢，这样有什么意义？回想一下，我们之前定义了一个 <code class="docutils literal notranslate"><span class="pre">(==&gt;&amp;)</span></code> 组合子来专门表达这个概念。另外，考虑一下 <code class="docutils literal notranslate"><span class="pre">print</span></code> 这样的函数，它的返回结果是一个占位符，我们没有必要关心它返回值是什么。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">print</span> <span class="s">&quot;foo&quot;</span>
<span class="nf">print</span> <span class="s">&quot;foo&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>如果我们使用普通的 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 来串联调用，我们必须提供一个新的函数来忽略参数（这个参数是前一个 <code class="docutils literal notranslate"><span class="pre">print</span></code> 的返回值。)</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="s">&quot;foo&quot;</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="s">&quot;bar&quot;</span>
<span class="s">&quot;foo&quot;</span>
<span class="s">&quot;bar&quot;</span>
</pre></div>
</div>
<p>但是，如果我们使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 操作符，那么就可以去掉那个没什么用的函数了：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="s">&quot;baz&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">print</span> <span class="s">&quot;quux&quot;</span>
<span class="s">&quot;baz&quot;</span>
<span class="s">&quot;quux&quot;</span>
</pre></div>
</div>
<p>正如我们上面看到的一样， <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 的默认实现是通过 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 完成的。</p>
<p>Monad类型类另外一个非核心函数是 <code class="docutils literal notranslate"><span class="pre">fail</span></code> ,这个函数接受一个错误消息然后让函数调用链失败。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>许多Monad实现并没有重写 <code class="docutils literal notranslate"><span class="pre">fail``函数的默认实现，因此在这些Monad里面，</span> <span class="pre">``fail</span></code> 将由 <code class="docutils literal notranslate"><span class="pre">error</span></code> 函数实现。但是由于 <code class="docutils literal notranslate"><span class="pre">error</span></code> 函数抛出的异常对于调用者来说要么就是无法捕获的，要么就是无法预期的，所以调用 <code class="docutils literal notranslate"><span class="pre">error</span></code> 并不是一件好事。
就算你很清楚在Monad使用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 在当前场景下是个明智之选，但是依然非常不推荐使用它。当你以后重构代码的时候，很有可能这个 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 函数在新的语境下无法工作从而导致非常复杂的问题，这种情况太容易发生了。</p>
</div>
<p>回顾一下我们在 <a class="reference internal" href="10.html"><span class="doc">第 10 章：代码案例学习：解析二进制数据格式</span></a> 写的parse, 里面有一个 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 的实例：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch10/Parse.hs</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Parse</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="ow">=</span> <span class="n">identity</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span>
    <span class="n">fail</span> <span class="ow">=</span> <span class="n">bail</span>
</pre></div>
</div>
</section>
<section id="and-now-a-jargon-moment">
<span id="id7"></span><h2>术语解释<a class="headerlink" href="#and-now-a-jargon-moment" title="Permalink to this headline">¶</a></h2>
<p>可能你对monad的某些惯用语并不熟悉，虽然他们不是正式术语，但是很常见；因此有必要了解一下。</p>
<ul class="simple">
<li><p>“Monadic”仅仅表示“和Monad相关的”。一个monadic 类型就是一个Monad 类型类的实例；一个monadic值就是一个具有monadic类型的值。</p></li>
<li><p>当我们说某个东西“是一个monad”的时候，我们其实表达的意思是“这个类型是Monad这个类型类的实例”；作为Monad的实例就有三要素：类型构造器，注入函数，串联函数。</p></li>
<li><p>同样，当我们谈到“Foo这个monad”的时候，我们实际上指的是Foo这个类型，只不过Foo是Monad这个类型类的实例。</p></li>
<li><p>Monadic值的一个别称是“动作”；这个说法可能源自 <code class="docutils literal notranslate"><span class="pre">I/O</span> <span class="pre">Monad</span></code> 的引入， <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;foo&quot;</span></code> 这样的monad值会导致副作用。返回类型是monadic值的函数有时候也被称之为动作，虽然这样并不太常见。</p></li>
</ul>
</section>
<section id="using-a-new-monad-show-your-work">
<span id="id8"></span><h2>使用新的Monad<a class="headerlink" href="#using-a-new-monad-show-your-work" title="Permalink to this headline">¶</a></h2>
<p>我们在介绍Monad的时候，展示了一些之前的代码，并说明它们其实就是Monad。既然我们慢慢知道monad是什么，而且已经见识过 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 这个类型类；现在就让我们用学到的知识来写一个Monad吧。我们先定义它的接口，然后使用它；一旦完成了这些，我们就写出了自己的Monad！</p>
<p>纯粹的Haskell代码写起来非常简洁，但是它不能执行IO操作；有时候，我们想记下我们程序的一些操作，但是又不想直接把日志信息写入文件；就这些需求，我们开发一个小型库。</p>
<p>回忆一下我们在 <a class="reference internal" href="8.html#translate-a-glob-pattern-into-a-regular-expression"><span class="std std-ref">将 glob 模式翻译为正则表达式</span></a> 中定义的 <code class="docutils literal notranslate"><span class="pre">globToRegex</span></code> 函数；我们修改它让它能够记住每次它翻译过的句子。我们又回到了熟悉的恐怖场景：比较同一份代码的Monadic版本和非Monadic版。</p>
<p>首先，我们可以使用一个 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类型类把处理结果的类型包装起来。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="kt">String</span>
</pre></div>
</div>
<section id="information-hiding">
<span id="id9"></span><h3>信息隐藏<a class="headerlink" href="#information-hiding" title="Permalink to this headline">¶</a></h3>
<p>我们将刻意隐藏 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 模块的实现。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="kr">module</span> <span class="nn">Logger</span>
    <span class="p">(</span>
      <span class="kt">Logger</span>
    <span class="p">,</span> <span class="kt">Log</span>
    <span class="p">,</span> <span class="nf">runLogger</span>
    <span class="p">,</span> <span class="nf">record</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>像这样隐藏实现有两个好处：它很大程度出上保证了我们对于Monad实现的灵活性，更重要的是，这样有一个非常简单的接口。</p>
<p><code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类型就是单纯的一个类型构造器。我们并没有将它的值构造器导出，因此 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 模块的使用者没有办法自己创建一个 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类型的值，它们对于 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类型能做的就是把它写在类型签名上。</p>
<p><code class="docutils literal notranslate"><span class="pre">Log</span></code> 类型就是一串字符串的别名，这样写是为了让它可读性更好。同时我们使用一串字符串来保持实现的简单。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="kr">type</span> <span class="kt">Log</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</pre></div>
</div>
<p>我们给接口的使用者提供了一个 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 函数来执行某个日志操作，而不是直接给他们一个值构造器。这个函数既回传了日志纪录这个操作，同时也回传了日志信息本身。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">runLogger</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="controlled-escape">
<span id="id10"></span><h3>受控的Monad<a class="headerlink" href="#controlled-escape" title="Permalink to this headline">¶</a></h3>
<p>Monad类型类没有提供任何方法使一个monadic的值成为一个普通的值。我们可以使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 函数把一个普通的值“注入”到monad里面；我们也可以用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 操作符把一个monadic的值提取出来，但是经过操作符处理之后还是回传一个monadic的值。</p>
<p>很多monads都有一个或者多个类似 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 的函数； <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad是个例外，通常情况下我们只能退出整个程序来脱离这个monad。</p>
<p>一个Monad函数在monad内部执行然后向外返回结果；一般来说这些函数是把一个Monadic的值脱离Monad成为一个普通值的唯一方法。因此，Monad的创建者对于如何处理这个过程有着完全的控制权。</p>
<p>有的Monad有好几个执行函数。在我们这个Logger的例子里面，我们可以假设有一些 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 的替代方法：一个仅仅返回日志信息，另外一个可能返回日志操作，然后把日志信息本身丢掉。</p>
</section>
<section id="leaving-a-trace">
<span id="id11"></span><h3>日志纪录<a class="headerlink" href="#leaving-a-trace" title="Permalink to this headline">¶</a></h3>
<p>当我们执行一个 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 动作的时候，代码将调用 <code class="docutils literal notranslate"><span class="pre">record</span></code> 函数来纪录某些东西。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">record</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="nb">()</span>
</pre></div>
</div>
<p>由于日志纪录的过程发生在Monad的内部，因此 <code class="docutils literal notranslate"><span class="pre">record</span></code> 这个动作并不返回什么有用的信息（ <code class="docutils literal notranslate"><span class="pre">()</span></code> )</p>
<p>通常Monad会提供一些类似 <code class="docutils literal notranslate"><span class="pre">record</span></code> 这样的辅助函数；这些函数也是我们访问这个Monad某些特定行为的方式。</p>
<p>我们的模块也把 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 定义为了 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 的实例。这个实例里面的定义就是使用 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类型所需要的全部东西。</p>
<p>下面就是使用我们的 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类的一个例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">simple</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">True</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runLogger</span> <span class="n">simple</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们使用 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 函数执行被记录的操作之后，会得到一个二元组。二元组的第一个元素是我们代码的执行结果；第二个元素是我们的日志动作执行的时候纪录信息的列表。由于我们没有纪录任何东西，所以返回的列表是空；来个有日志信息的例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runLogger</span> <span class="p">(</span><span class="n">record</span> <span class="s">&quot;hi mom!&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="mf">3.1337</span><span class="p">)</span>
<span class="p">(</span><span class="mf">3.1337</span><span class="p">,[</span><span class="s">&quot;hi mom!&quot;</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="logger-monad">
<span id="using-the-logger-monad"></span><h3>使用 Logger monad<a class="headerlink" href="#logger-monad" title="Permalink to this headline">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> monad里面我们可以剔除通配符到正则表达式的转换，代码如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex</span> <span class="n">cs</span> <span class="ow">=</span>
    <span class="n">globToRegex&#39;</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="sc">&#39;^&#39;</span><span class="kt">:</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>然后我们来简单说明一下一些值得注意的代码风格。我们函数体在函数名字下面一行，要这么做，需要添加一些水平的空格；对于匿名函数，我们把它的参数放在另起的一行，这是monadic代码通常的组织方式。</p>
<p>回忆一下 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的类型：它从 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 包装器中中提取出操作符 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 左边的值，然后把取出来的值传递给右边的函数。右边的操作数函数必须把这个取出来的值用 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 包装起来然后回传出去。这个操作正如正如 <code class="docutils literal notranslate"><span class="pre">return</span></code> 一样：接受一个纯值，然后用Monad的类型构造器包装一下返回。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="n">globToRegex</span> <span class="s">&quot;&quot;</span> <span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="n">globToRegex</span> <span class="s">&quot;&quot;</span> <span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="n">b</span>
</pre></div>
</div>
<p>就算我们写一个什么都不做的函数，我们也必须使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 去包装具有正确类型的值。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="kt">String</span>
<span class="nf">globToRegex&#39;</span> <span class="s">&quot;&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="s">&quot;$&quot;</span>
</pre></div>
</div>
<p>当我们要使用 <code class="docutils literal notranslate"><span class="pre">record</span></code> 函数纪录某些日志的时候，我们采用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 来串联一系列的日志操作。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex&#39;</span> <span class="p">(</span><span class="sc">&#39;?&#39;</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">record</span> <span class="s">&quot;any&quot;</span> <span class="o">&gt;&gt;</span>
    <span class="n">globToRegex&#39;</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="kt">:</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的一个变种，只不过它会忽略左边操作的结果；由于 <code class="docutils literal notranslate"><span class="pre">record</span></code> 函数的返回值永远都是 <code class="docutils literal notranslate"><span class="pre">()</span></code> 因此获取它的返回值没有什么意义，直接使用 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 更简洁。</p>
<p>另外，我们也可以使用在 <a class="reference internal" href="7.html#sequencing"><span class="std std-ref">串联化（Sequencing）</span></a> 引入的 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法来整理代码。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex&#39;</span> <span class="p">(</span><span class="sc">&#39;*&#39;</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">record</span> <span class="s">&quot;kleene star&quot;</span>
    <span class="n">ds</span> <span class="ow">&lt;-</span> <span class="n">globToRegex&#39;</span> <span class="n">cs</span>
    <span class="n">return</span> <span class="p">(</span><span class="s">&quot;.*&quot;</span> <span class="o">++</span> <span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>选择使用 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法还是显式使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 结合匿名函数完全取决于个人爱好，但是对于长度超过两行的代码来说，几乎所有人都会选择使用 <code class="docutils literal notranslate"><span class="pre">do</span></code>. 这两种风格有一个非常重要的区别，我们将会在 <a class="reference internal" href="#desugaring-of-do-blocks"><span class="std std-ref">还原do的本质</span></a> 里面介绍。</p>
<p>对于解析单个字符的情况，monadic的代码几乎和普通的一样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">globToRegex&#39;</span> <span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="kt">:</span><span class="sc">&#39;!&#39;</span><span class="kt">:</span><span class="n">c</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">record</span> <span class="s">&quot;character class, negative&quot;</span> <span class="o">&gt;&gt;</span>
    <span class="n">charClass</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="s">&quot;[^&quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="kt">:</span> <span class="n">ds</span><span class="p">)</span>
<span class="nf">globToRegex&#39;</span> <span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="kt">:</span><span class="n">c</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">record</span> <span class="s">&quot;character class&quot;</span> <span class="o">&gt;&gt;</span>
    <span class="n">charClass</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="s">&quot;[&quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="kt">:</span> <span class="n">ds</span><span class="p">)</span>
<span class="nf">globToRegex&#39;</span> <span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">fail</span> <span class="s">&quot;unterminated character class&quot;</span>
</pre></div>
</div>
</section>
</section>
<section id="puermonadic">
<span id="mixing-pure-and-monadic-code"></span><h2>同时使用puer和monadic代码<a class="headerlink" href="#puermonadic" title="Permalink to this headline">¶</a></h2>
<p>迄今为止我们看到的Monad好像有一个非常明显的缺陷：Monad的类型构造器把一个值包装成一个monadic的值，这样导致在monad里面使用普通的纯函数有点困难。举个例子，假设我们有一段运行在monad里面的代码，它所做的就是返回一个字符串：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">return</span> <span class="s">&quot;foo&quot;</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="kt">String</span>
</pre></div>
</div>
<p>如果我们想知道字符串的长度是多少，我们不能直接调用 <code class="docutils literal notranslate"><span class="pre">length</span></code> 函数：因为这个字符串被 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 这个monad包装起来了，因此类型并不匹配。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="n">m</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">7</span><span class="kt">:</span>
    <span class="kt">Couldn&#39;t</span> <span class="n">match</span> <span class="n">expected</span> <span class="kr">type</span> <span class="p">`[</span><span class="n">a</span><span class="p">]</span><span class="sc">&#39;</span>
           <span class="n">against</span> <span class="n">inferred</span> <span class="kr">type</span> <span class="p">`</span><span class="kt">Logger</span> <span class="kt">String&#39;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">first</span> <span class="n">argument</span> <span class="kr">of</span> <span class="p">`</span><span class="n">length&#39;</span><span class="p">,</span> <span class="n">namely</span> <span class="p">`</span><span class="n">m&#39;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">length</span> <span class="n">m</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">definition</span> <span class="kr">of</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">m</span>
</pre></div>
</div>
<p>我们能做的事情就是下面这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span>   <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">length</span> <span class="n">s</span><span class="p">)</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">length</span> <span class="n">s</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 把字符串从monad里面取出来，然后使用一个匿名函数调用 <code class="docutils literal notranslate"><span class="pre">length</span></code> 接着用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 把这个字符串重新包装成 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 。</p>
<p>由于这种形式的代码经常在Haskell里面出现，因此已经有一个类似的操作符存在了。在 <a class="reference internal" href="10.html#introducing-functors"><span class="std std-ref">Functor 简介</span></a> 里面我们介绍了 <em>lifting</em> 这种技术；把一个纯函数 Lift 为一个函子通常意味着从一个带有上下文的特殊值里面取出那个值，然后使用这个普通的值调用纯函数，得到结果之后用特定的类型构造器包装成原来有着上下文的特殊值。</p>
<p>在monad里面，我们需要干同样的一件事。由于 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 这个类型类已经提供了 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 这两个函数处理monadic的值和普通值之间的转换，因此 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 函数不需要知道monad的任何实现细节。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">liftM</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span>
            <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们把一个类型声明为 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> 这个类型类的实例之后，我们必须根据这个特定的类型实现对应的 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 函数；但是， 由于 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 对monad的进行了抽象，因此``liftM`` 不需要知道任何monad的任何实现细节。我们只需要实现一次并配上合适的类型签名即可。</p>
<p>在标准库的 <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> 模块里面已经为我们定义好了 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 函数。</p>
<p>我们来看看使用 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 对于提升我们代码可读性有什么作用；先看看没有使用 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 的代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">charClass_wordy</span> <span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">globToRegex&#39;</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="kt">:</span><span class="n">ds</span><span class="p">)</span>
<span class="nf">charClass_wordy</span> <span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">charClass_wordy</span> <span class="n">cs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">ds</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
<p>然后我们用 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 去掉那些 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=))</span></code> 和匿名函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">charClass</span> <span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="kt">:</span><span class="p">)</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">globToRegex&#39;</span> <span class="n">cs</span>
<span class="nf">charClass</span> <span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="p">)</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">charClass</span> <span class="n">cs</span>
</pre></div>
</div>
<p>正如 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 一样，我们通常用中缀的方式调用 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 。可以用这种方式来阅读这个表达式：把右边操作得到的monadic的值应用到左边的纯函数上。</p>
<p><code class="docutils literal notranslate"><span class="pre">liftM</span></code> 函数实在是太有用了，因此 <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> 定义了它的几个变种，这些变种可以处理更长的参数；我们可以看一看 <code class="docutils literal notranslate"><span class="pre">globToRegex</span></code> 这个函数的最后一个分句：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>-- file: ch14/Logger.hs
globToRegex&#39; (c:cs) = liftM2 (++) (escape c) (globToRegex&#39; cs)

escape :: Char -&gt; Logger String
escape c
    | c `elem` regexChars = record &quot;escape&quot; &gt;&gt; return [&#39;\\&#39;,c]
    | otherwise           = return [c]
  where regexChars = &quot;\\+()^$.{}]|&quot;
</pre></div>
</div>
<p>上面这段代码用到的 <code class="docutils literal notranslate"><span class="pre">liftM2</span></code> 函数的定义如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">liftM2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">c</span>
<span class="nf">liftM2</span> <span class="n">f</span> <span class="n">m1</span> <span class="n">m2</span> <span class="ow">=</span>
    <span class="n">m1</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span>
    <span class="n">m2</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>它首先执行第一个动作，接着执行第二个操作，然后把这两个操作的结果组合起来应用到那个纯函数上并包装返回的结果。 <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> 里面定义了 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> <code class="docutils literal notranslate"><span class="pre">liftM2</span></code> 直到 <code class="docutils literal notranslate"><span class="pre">liftM5</span></code> 。</p>
</section>
<section id="putting-a-few-misconceptions-to-rest">
<span id="id12"></span><h2>关于Monad的一些误解<a class="headerlink" href="#putting-a-few-misconceptions-to-rest" title="Permalink to this headline">¶</a></h2>
<p>我们已经见识过很多Monad的例子并且对monad也有一些感觉了；在继续探讨monad之前，有一些广为流传的关于monad的观念需要澄清。你肯定经常听到这些说法，因此你可能已经有一些很好的理由来反驳这些谬论了。</p>
<ul class="simple">
<li><p><em>Monads很难理解</em> 我们已经从好几个实例的问题来说明Monad是如何工作的了，并且我们已经知道理解monad最好的方式就是先通过一些具体的例子来进行解释，然后抽象出这些这些例子共同的东西。</p></li>
<li><p><em>Monads仅仅用于 I/O 操作和命令式代码</em>  虽然我们在Haskell的IO里面使用Monad，但是Monad在其他的地方也非常有用。我们已经通过monad串联简单的计算，隐藏复杂的状态以及纪录日志了；然而，Monad的作用我们还只看到冰山一角。</p></li>
<li><p><em>只有Haskell才有Monad</em> Haskell有可能是显式使用Monad最多的语言，但是在别的语言里面也存在，从C++到OCaml。由于Haskell的 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法，强大的类型系统以及语言的语法使得Monad在Haskell里面非常容易处理。</p></li>
<li><p><em>Monads使用来控制求值顺序的</em></p></li>
</ul>
</section>
<section id="building-the-logger-monad">
<span id="id13"></span><h2>创建Logger Monad<a class="headerlink" href="#building-the-logger-monad" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Logger</span></code> 类的定义非常简单：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="kr">newtype</span> <span class="kt">Logger</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Logger</span> <span class="p">{</span> <span class="n">execLogger</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>它其实就是一个二元组，第一个元素是执行动作的结果，第二元素是我们执行动作的时候纪录的日志信息列表。</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 关键字把二元组进行了包装使它的类型更加清晰易读。 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 函数可以从这个Monad里面取出这个元组里面的值；这个函数其实是 <code class="docutils literal notranslate"><span class="pre">execLogger</span></code> 的一个别名。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">runLogger</span> <span class="ow">=</span> <span class="n">execLogger</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">record</span></code> 这个函数将为接收到的日志信息创建一个只包含单个元素的列表。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="nf">record</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Logger</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
</pre></div>
</div>
<p>这个动作的结果是 <code class="docutils literal notranslate"><span class="pre">()</span></code> 。</p>
<p>让我们以 <code class="docutils literal notranslate"><span class="pre">return</span></code> 开始，构建 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 实例；先尝试一下：它什么都不记录，然后把结果存放在二元组里面。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Logger</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Logger</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的定义更有趣，当然它也是monad的核心。 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 把一个普通的值和一个monadic的函数结合起来，得到新的运算结果和一个新的日志信息。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Logger.hs</span>
    <span class="c1">-- (&gt;&gt;=) :: Logger a -&gt; (a -&gt; Logger b) -&gt; Logger b</span>
    <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="n">execLogger</span> <span class="n">m</span>
                  <span class="n">n</span>      <span class="ow">=</span> <span class="n">k</span> <span class="n">a</span>
                  <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">execLogger</span> <span class="n">n</span>
              <span class="kr">in</span> <span class="kt">Logger</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="o">++</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>我们看看这段代码里面发生了什么。首先使用 <code class="docutils literal notranslate"><span class="pre">runLogger</span></code> 函数从动作 <code class="docutils literal notranslate"><span class="pre">m</span></code> 取出结果 <code class="docutils literal notranslate"><span class="pre">a</span></code> ,然后把它传递给monadic函数 <code class="docutils literal notranslate"><span class="pre">k</span></code>; 接着我们又取出 <code class="docutils literal notranslate"><span class="pre">b</span></code> ；最后把 <code class="docutils literal notranslate"><span class="pre">w</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x</span></code> 拼接得到一个新的日志。</p>
<section id="sequential-logging-not-sequential-evaluation">
<span id="id14"></span><h3>顺序的日志，而不是顺序的求值<a class="headerlink" href="#sequential-logging-not-sequential-evaluation" title="Permalink to this headline">¶</a></h3>
<p>我们定义的 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 保证了新输出的日志一定在之前的输出的日志之后。但是这并不意味着 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的求值是顺序的：<code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 操作符是惰性求值的。</p>
<p>正如Monad的很多其他行为一样，求值的严格性是由Monad的实现者控制的，并不是所有Monad的共同性质。事实上，有一些Monad同时有几种特性，每一种都有着不同程度的严格性（求值）。</p>
</section>
<section id="writer-monad">
<span id="the-writer-monad"></span><h3>Writer monad<a class="headerlink" href="#writer-monad" title="Permalink to this headline">¶</a></h3>
<p>我们创建的 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> monad实际上是标准库里面 <code class="docutils literal notranslate"><span class="pre">Writer</span></code> Monad的一个特例；<code class="docutils literal notranslate"><span class="pre">Writer</span></code> Monad可以在 <code class="docutils literal notranslate"><span class="pre">mtl</span></code> 包里面的 <code class="docutils literal notranslate"><span class="pre">Control.Monad.Writer</span></code> 模块找到。我们会在 <a class="reference internal" href="6.html#using-typeclasses"><span class="std std-ref">第 6 章：使用类型类</span></a> 里面介绍 <code class="docutils literal notranslate"><span class="pre">Writer</span></code> 的用法。</p>
</section>
</section>
<section id="maybe-monad">
<span id="the-maybe-monad"></span><h2>Maybe monad<a class="headerlink" href="#maybe-monad" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 应该是最简单的Monad了。它代表了一种可能不会产生计算结果的计算过程。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>  <span class="ow">=</span>  <span class="n">k</span> <span class="n">x</span>
    <span class="kt">Nothing</span> <span class="o">&gt;&gt;=</span> <span class="kr">_</span> <span class="ow">=</span>  <span class="kt">Nothing</span>

    <span class="kt">Just</span> <span class="kr">_</span> <span class="o">&gt;&gt;</span> <span class="n">k</span>   <span class="ow">=</span>  <span class="n">k</span>
    <span class="kt">Nothing</span> <span class="o">&gt;&gt;</span> <span class="kr">_</span>  <span class="ow">=</span>  <span class="kt">Nothing</span>

    <span class="n">return</span> <span class="n">x</span>      <span class="ow">=</span>  <span class="kt">Just</span> <span class="n">x</span>

    <span class="n">fail</span> <span class="kr">_</span>        <span class="ow">=</span>  <span class="kt">Nothing</span>
</pre></div>
</div>
<p>当我们使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 串联一些 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 计算的时候，如果这些计算中的任何一个返回了 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ， <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 就不会对余下的任何计算进行求值。</p>
<p>值得一提的是，整个调用链并不是完全短路的。每一个 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 仍然会匹配它左边的 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 然后给右边的函数一个 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, 直到达到调用链的末端。这一点很容易被遗忘：当调用链中某个计算失败的时候，之前计算的结果，余下的调用链以及使用的 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 值在运行时的开销是廉价的，但并不是完全没有开销。</p>
<section id="executing-the-maybe-monad">
<span id="id15"></span><h3>执行Maybe monad<a class="headerlink" href="#executing-the-maybe-monad" title="Permalink to this headline">¶</a></h3>
<p>适合执行 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> Monad的函数是 <code class="docutils literal notranslate"><span class="pre">maybe</span></code> (“执行”一个monad意味着取出Monad里面包含的值，移除Monad类的包装）</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Maybe.hs</span>
<span class="nf">maybe</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">maybe</span> <span class="n">n</span> <span class="kr">_</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="n">n</span>
<span class="nf">maybe</span> <span class="kr">_</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>如果第三个参数是 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ， <code class="docutils literal notranslate"><span class="pre">maybe</span></code> 将使用第一个参数作为返回值；而第二个参数则是在 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 值构造器里面进行包装值的函数。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型非常简单，直接对它进行模式匹配和调用 <code class="docutils literal notranslate"><span class="pre">maybe</span></code> 函数使用起来差不多，在不同的场景下，两种方式都有各自的优点。</p>
</section>
<section id="maybe-api">
<span id="maybe-at-work-and-good-api-design"></span><h3>使用Maybe，以及好的API设计方式<a class="headerlink" href="#maybe-api" title="Permalink to this headline">¶</a></h3>
<p>下面是一个使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 的例子。给出一个顾客的名字，找出它们手机号对应的账单地址。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Carrier.hs</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>

<span class="kr">type</span> <span class="kt">PersonName</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">PhoneNumber</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">BillingAddress</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">data</span> <span class="kt">MobileCarrier</span> <span class="ow">=</span> <span class="kt">Honest_Bobs_Phone_Network</span>
                   <span class="o">|</span> <span class="kt">Morrisas_Marvelous_Mobiles</span>
                   <span class="o">|</span> <span class="kt">Petes_Plutocratic_Phones</span>
                     <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>

<span class="nf">findCarrierBillingAddress</span> <span class="ow">::</span> <span class="kt">PersonName</span>
                          <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">PersonName</span> <span class="kt">PhoneNumber</span>
                          <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">PhoneNumber</span> <span class="kt">MobileCarrier</span>
                          <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">MobileCarrier</span> <span class="kt">BillingAddress</span>
                          <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">BillingAddress</span>
</pre></div>
</div>
<p>我们的第一个实现使用 <code class="docutils literal notranslate"><span class="pre">case</span></code> 表达式，用它完成的代码相当难看，差不多超出了屏幕的右边。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Carrier.hs</span>
<span class="nf">variation1</span> <span class="n">person</span> <span class="n">phoneMap</span> <span class="n">carrierMap</span> <span class="n">addressMap</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">person</span> <span class="n">phoneMap</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Just</span> <span class="n">number</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">number</span> <span class="n">carrierMap</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="n">carrier</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">carrier</span> <span class="n">addressMap</span>
</pre></div>
</div>
<p>模块 <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> 的函数 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 返回一个 monadic的值：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>ghci&gt; :module +Data.Map
ghci&gt; :type Data.Map.lookup
Data.Map.lookup :: (Ord k, Monad m) =&gt; k -&gt; Map k a -&gt; m a
</pre></div>
</div>
<p>换句话说，如果给定的key在map里面存在，那么 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 把这个值注入到monad里面去；否则就会调用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 函数。这是这个API一个有趣的实现，虽然有人觉得它很糟糕。</p>
<ul class="simple">
<li><p>这样设计好的一方式是，根据具体Monad实现的不同，查找成功和失败的结果是可以根据不同需求定制的；而且， <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 函数本身对于具体的这些行为完全不用关心。</p></li>
<li><p>坏处就是，在有些Monad里面调用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 会直接抛出让人恼火的异常；之前我们就警告过最好不要使用 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 函数，这里就不在赘述了。</p></li>
</ul>
<p>实际上，每个人都使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型作为 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 函数的返回结果；这样一个简单的函数对于它的返回结果提供了它并不需要的通用性：其实 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 应该直接返回 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 。</p>
<p>先放下API设计的问题，我们来处理一下我们之前用 <code class="docutils literal notranslate"><span class="pre">case</span></code> 编写的丑陋代码。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Carrier.hs</span>
<span class="nf">variation2</span> <span class="n">person</span> <span class="n">phoneMap</span> <span class="n">carrierMap</span> <span class="n">addressMap</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">number</span> <span class="ow">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">person</span> <span class="n">phoneMap</span>
  <span class="n">carrier</span> <span class="ow">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">number</span> <span class="n">carrierMap</span>
  <span class="n">address</span> <span class="ow">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">carrier</span> <span class="n">addressMap</span>
  <span class="n">return</span> <span class="n">address</span>
</pre></div>
</div>
<p>如果这其中的任何一个查找失败， <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 的定义告诉我们整个运算的结果将会是 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>; 就和我们显式使用 <code class="docutils literal notranslate"><span class="pre">case</span></code> 表达式结果一样。</p>
<p>使用Monad的版本的代码更加整洁，但是其实 <code class="docutils literal notranslate"><span class="pre">return</span></code> 是不必要的；从风格上说，使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 让代码看起来更加有规律，另外熟悉命令式编程的程序员可能对它感觉更熟悉；但其实上它是多余的；下面是与它等价的版本：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Carrier.hs</span>
<span class="nf">variation2a</span> <span class="n">person</span> <span class="n">phoneMap</span> <span class="n">carrierMap</span> <span class="n">addressMap</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">number</span> <span class="ow">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">person</span> <span class="n">phoneMap</span>
  <span class="n">carrier</span> <span class="ow">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">number</span> <span class="n">carrierMap</span>
  <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">carrier</span> <span class="n">addressMap</span>
</pre></div>
</div>
</section>
</section>
<section id="list-monad">
<span id="the-list-monad"></span><h2>List Monad<a class="headerlink" href="#list-monad" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型代表有可能有值也可能没有值的计算；也有的情况下希望计算会返回一系列的结果，显然，List正适合这个目的。List的类型带有一个参数，这暗示它有可能能作为一个monad使用；事实上，我们确实能把它当作monad使用。</p>
<p>先不看标准库的 <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> 对于List monad的实现，我们自己来看看一个 List 的monad应该是什么样的。这个过程很简单：首先看 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 的类型，然后进行一些替换操作，看看我们能不能使用一些熟悉的list函数。</p>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 这两个函数里面显然 <code class="docutils literal notranslate"><span class="pre">return</span></code> 比较简单。我们已经知道 <code class="docutils literal notranslate"><span class="pre">return</span></code> 函数接受一个类型，然后把它用类型构造器 <code class="docutils literal notranslate"><span class="pre">m</span></code> 包装一下然后产生一个新的类型 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code>. 在List这种情况下，这个类型构造器就是 <code class="docutils literal notranslate"><span class="pre">[]</span></code>. 把这个类型构造器使用List的类型构造器替换掉我们就得到了类型 <code class="docutils literal notranslate"><span class="pre">[]</span> <span class="pre">a</span></code> (当然，这样写是非法的！）；可以把它写成更加熟悉的形式 <code class="docutils literal notranslate"><span class="pre">[a]</span></code>.</p>
<p>现在我们知道list的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 函数的类型应该是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code> 。对于这种类型的函数，只有少数那么几种实现的可能：要么它返回一个空列表，要么返回一个单个元素的列表，或者一个无穷长度的列表。基于我们现在对于Monad的理解，最有可能的实现方式应该是返回单个元素的列表：它不会丢失已有信息，也不会无限重复。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/ListMonad.hs</span>
<span class="nf">returnSingleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">returnSingleton</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>如果我们对 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的类型签名进行和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 类似的替换，我们会得到： <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">[b])</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code> . 这看起来和 <code class="docutils literal notranslate"><span class="pre">map</span></code> 非常相似。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">map</span>
<span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">map</span></code> 函数的参数顺序和它有点不对应，我们可以改成这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">flip</span> <span class="n">map</span>
<span class="nf">flip</span> <span class="n">map</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p>但是还是有一点小问题： <code class="docutils literal notranslate"><span class="pre">flip</span> <span class="pre">map</span></code> 的第二个参数的类型是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> ，但是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的第二个参数的类型是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code> ,应该怎么办呢？</p>
<p>我们对类型进行更多的替换，看看会发生什么。 <code class="docutils literal notranslate"><span class="pre">flip</span> <span class="pre">map</span></code> 这个函数能把任何类型 <code class="docutils literal notranslate"><span class="pre">b</span></code> 作为返回结果；如果我们使用 <code class="docutils literal notranslate"><span class="pre">[b]</span></code> 来替换 <code class="docutils literal notranslate"><span class="pre">b</span></code> ，这个函数的类型就成了 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">[n])</span> <span class="pre">-&gt;</span> <span class="pre">[[b]]</span></code>. 换句话说，如果我们使用 <code class="docutils literal notranslate"><span class="pre">map</span></code> ，将一个列表与一个返回列表的函数进行映射，我们会得到一个包含列表的列表。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flip</span> <span class="n">map</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">100</span><span class="p">])</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">102</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">103</span><span class="p">]]</span>
</pre></div>
</div>
<p>有趣的是，我们这么做并没有让 <code class="docutils literal notranslate"><span class="pre">flip</span> <span class="pre">map</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的类型更加匹配一点； <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">[b])</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code> ；然而，<code class="docutils literal notranslate"><span class="pre">flip</span> <span class="pre">map</span></code> 如果对返回列表的函数进行map那么它的类型签名是 <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">[b])</span> <span class="pre">-&gt;</span> <span class="pre">[[b]]</span></code> .在类型上依然是不匹配的，我们仅仅是把不匹配的类型从中间转移到了末尾。但是，我们的努力并没有白费：我们现在其实只需要一个能把 <code class="docutils literal notranslate"><span class="pre">[[b]]</span></code> 转化成 <code class="docutils literal notranslate"><span class="pre">[b]</span></code> 的函数就好了。很明显 <code class="docutils literal notranslate"><span class="pre">concat</span></code> 符合我们的要求。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">concat</span>
<span class="nf">concat</span> <span class="ow">::</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的类型告诉我们应该把 <code class="docutils literal notranslate"><span class="pre">map</span></code> 的参数进行翻转，然后使用 <code class="docutils literal notranslate"><span class="pre">concat</span></code> 进行处理得到单个列表。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="nf">\</span><span class="n">xs</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">\</span><span class="n">xs</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a1</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a1</span><span class="p">]</span>
</pre></div>
</div>
<p>事实上lists的 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 定义就是这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/ListMonad.hs</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>它使用函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 对列表 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 的每一个元素 <code class="docutils literal notranslate"><span class="pre">x</span></code> 进行处理，然后把得到的结果拼接起来得到单个列表。</p>
<p>现在我们已经搞定了List这个Monad的两个核心函数，另外两个非核心函数实现起来就很容易了：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/ListMonad.hs</span>
    <span class="n">xs</span> <span class="o">&gt;&gt;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<section id="understanding-the-list-monad">
<span id="id16"></span><h3>理解List monad<a class="headerlink" href="#understanding-the-list-monad" title="Permalink to this headline">¶</a></h3>
<p>List monad与Haskell的另外一个工具——列表推导非常相似。我们可以通过计算两个列表的笛卡尔集来说明它们之间的相似性。首先，我们写一个列表推导：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/CartesianProduct.hs</span>
<span class="nf">comprehensive</span> <span class="n">xs</span> <span class="n">ys</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">ys</span><span class="p">]</span>
</pre></div>
</div>
<p>这里我们使用大括号语法来表示monadic代码，这样会告诉我们monadic代码和列表推导该有多么相似。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/CartesianProduct.hs</span>
<span class="nf">monadic</span> <span class="n">xs</span> <span class="n">ys</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">;</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">ys</span><span class="p">;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>唯一的一个不同点是使用monadic代码计算的结果在一系列表达式的末尾得到；而列表推导的结果表示在最开始。除此之外，这个函数计算的结果是完全相同的。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">comprehensive</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="s">&quot;bar&quot;</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;r&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;r&#39;</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">comprehensive</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="s">&quot;bar&quot;</span> <span class="o">==</span> <span class="n">monadic</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="s">&quot;bar&quot;</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>一开始肯定对列表monad非常迷惑，我们一起看一下monadic代码计算笛卡尔集的过程。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/CartesianProduct.hs</span>
<span class="nf">blockyDo</span> <span class="n">xs</span> <span class="n">ys</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span>
    <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">ys</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> 每次取列表 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 的一个值， <code class="docutils literal notranslate"><span class="pre">y</span></code> 每次取列表 <code class="docutils literal notranslate"><span class="pre">ys</span></code> 的一个值，然后组合在一起得到最终结果；事实上，这就是两层嵌套循环！这也说明了关于monad的一个很重要的事实：除非你知道monad内部是如何执行的，否则你将无法预期monadic代码的行为。</p>
<p>我们再进一步观察这个代码；首先去掉 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法；稍微改变一下代码的结构让它看起来更像一个嵌套循环。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/CartesianProduct.hs</span>
<span class="nf">blockyPlain</span> <span class="n">xs</span> <span class="n">ys</span> <span class="ow">=</span>
    <span class="n">xs</span> <span class="o">&gt;&gt;=</span>
    <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">ys</span> <span class="o">&gt;&gt;=</span>
    <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">blockyPlain_reloaded</span> <span class="n">xs</span> <span class="n">ys</span> <span class="ow">=</span>
    <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span>
                 <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span>
                              <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                         <span class="n">ys</span><span class="p">))</span>
            <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 的值是 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> ，那么函数体的前两行会依次把x值绑定为 <code class="docutils literal notranslate"><span class="pre">1</span></code> , <code class="docutils literal notranslate"><span class="pre">2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">3</span></code> ；如果 <code class="docutils literal notranslate"><span class="pre">ys</span></code> 的值是 <code class="docutils literal notranslate"><span class="pre">[True,</span> <span class="pre">False]</span></code>; 那么最后一行会被求值六次：一次是 <code class="docutils literal notranslate"><span class="pre">x</span></code> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> , <code class="docutils literal notranslate"><span class="pre">y</span></code> 值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ；然后是 <code class="docutils literal notranslate"><span class="pre">x</span></code> 值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> , <code class="docutils literal notranslate"><span class="pre">y</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">False</span></code> ；一直继续下去。 <code class="docutils literal notranslate"><span class="pre">return</span></code> 表达式把每个元组包装成一个单个列表的元素。</p>
</section>
<section id="putting-the-list-monad-to-work">
<span id="id17"></span><h3>使用List Monad<a class="headerlink" href="#putting-the-list-monad-to-work" title="Permalink to this headline">¶</a></h3>
<p>给定一个整数，找出所有的正整数对，使得它们两个积等于这个整数；下面是这个问题的简单解法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MultiplyTo.hs</span>
<span class="nf">guarded</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">guarded</span> <span class="kt">True</span>  <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span>
<span class="nf">guarded</span> <span class="kt">False</span> <span class="kr">_</span>  <span class="ow">=</span> <span class="kt">[]</span>

<span class="nf">multiplyTo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
<span class="nf">multiplyTo</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
  <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="n">x</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
  <span class="n">guarded</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">$</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <strong>ghci</strong> 验证结果：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multiplyTo</span> <span class="mi">8</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multiplyTo</span> <span class="mi">100</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">50</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">25</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multiplyTo</span> <span class="mi">891</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">891</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">297</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="mi">99</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">81</span><span class="p">),(</span><span class="mi">27</span><span class="p">,</span><span class="mi">33</span><span class="p">)]</span>
</pre></div>
</div>
</section>
</section>
<section id="do">
<span id="desugaring-of-do-blocks"></span><h2>还原do的本质<a class="headerlink" href="#do" title="Permalink to this headline">¶</a></h2>
<p>Haskell的 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法实际上是个语法糖：它给我们提供了一种不使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和匿名函数来写monadic代码的方式。去除do语法糖的过程就是把它翻译为 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和匿名函数。</p>
<p>去除do语法糖的规则非常简单。我们可以简单的把编译器想象为机械重复地对这些do语句块执行这些规则直到没有任何do关键字为止。</p>
<p><code class="docutils literal notranslate"><span class="pre">do</span></code> 关键字后面接单个动作（action）直接翻译为动作本身。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">doNotation1</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">act</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">translated1</span> <span class="ow">=</span>
    <span class="n">act</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">do</span></code> 后面包含多个动作（action）的表示是这样的：首先是第一个动作，但是接一个 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 操作符，然后一个 <code class="docutils literal notranslate"><span class="pre">do</span></code> 关键字；最后接剩下的动作。当我们对do语句块重复应用这条规则的时候，整个do语句快就会被 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 串联起来。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">doNotation2</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">act1</span>
       <span class="n">act2</span>
       <span class="cm">{- ... etc. -}</span>
       <span class="n">actN</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">translated2</span> <span class="ow">=</span>
    <span class="n">act1</span> <span class="o">&gt;&gt;</span>
    <span class="kr">do</span> <span class="n">act2</span>
       <span class="cm">{- ... etc. -}</span>
       <span class="n">actN</span>

<span class="nf">finalTranslation2</span> <span class="ow">=</span>
    <span class="n">act1</span> <span class="o">&gt;&gt;</span>
    <span class="n">act2</span> <span class="o">&gt;&gt;</span>
    <span class="cm">{- ... etc. -}</span>
    <span class="n">actN</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> 标记需要额外注意。在 <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> 的左边是一个正常的Haskell模式，可以是单个变量或者更复杂的东西；但是这里不允许使用模式匹配的守卫(guards):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">doNotation3</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="n">pattern</span> <span class="ow">&lt;-</span> <span class="n">act1</span>
       <span class="n">act2</span>
       <span class="cm">{- ... etc. -}</span>
       <span class="n">actN</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">translated3</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">f</span> <span class="n">pattern</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">act2</span>
                       <span class="cm">{- ... etc. -}</span>
                       <span class="n">actN</span>
        <span class="n">f</span> <span class="kr">_</span>     <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;...&quot;</span>
    <span class="kr">in</span> <span class="n">act1</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
</pre></div>
</div>
<p>这种情况会被翻译为声明了一个名字唯一的局部函数(上面的例子里面我们仅仅使用了 <code class="docutils literal notranslate"><span class="pre">f</span></code> 这个名字)的 <code class="docutils literal notranslate"><span class="pre">let</span></code> 表达式； <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> 右边的动作会用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和这个局部函数串联起来。</p>
<p>要注意的是，如果模式匹配失败， <code class="docutils literal notranslate"><span class="pre">let</span></code> 表达式会调用Monad的 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 函数；下面是一个使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad的例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">robust</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">robust</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="n">xs</span>
               <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad里面 <code class="docutils literal notranslate"><span class="pre">fail</span></code> 的实现是返回一个 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 。如果上面的代码模式匹配失败，那么整个计算结果就会是 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> .</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">robust</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">robust</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>当我们在 <code class="docutils literal notranslate"><span class="pre">do</span></code> 块里面使用 <code class="docutils literal notranslate"><span class="pre">let</span></code> 表达式的时候，可以省略掉 <code class="docutils literal notranslate"><span class="pre">in</span></code> 关键字；但是 <code class="docutils literal notranslate"><span class="pre">let</span></code> 后面的语句必须和它对齐。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">doNotation4</span> <span class="ow">=</span>
    <span class="kr">do</span> <span class="kr">let</span> <span class="n">val1</span> <span class="ow">=</span> <span class="n">expr1</span>
           <span class="n">val2</span> <span class="ow">=</span> <span class="n">expr2</span>
           <span class="cm">{- ... etc. -}</span>
           <span class="n">valN</span> <span class="ow">=</span> <span class="n">exprN</span>
       <span class="n">act1</span>
       <span class="n">act2</span>
       <span class="cm">{- ... etc. -}</span>
       <span class="n">actN</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">translated4</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">val1</span> <span class="ow">=</span> <span class="n">expr1</span>
        <span class="n">val2</span> <span class="ow">=</span> <span class="n">expr2</span>
        <span class="n">valN</span> <span class="ow">=</span> <span class="n">exprN</span>
    <span class="kr">in</span> <span class="kr">do</span> <span class="n">act1</span>
          <span class="n">act2</span>
          <span class="cm">{- ... etc. -}</span>
          <span class="n">actN</span>
</pre></div>
</div>
<section id="monads-as-a-programmable-semicolon">
<span id="id18"></span><h3>Monads: 可编程分号<a class="headerlink" href="#monads-as-a-programmable-semicolon" title="Permalink to this headline">¶</a></h3>
<p>在 <a class="reference internal" href="3.html#the-offside-rule-is-not-mandatory"><span class="std std-ref">缩进规则并不是必需</span></a> 里面提到过缩进排版是Haskell的标准，但是这并不是必要的。我们可以使用 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法来替代缩进排版。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">semicolon</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="p">{</span>
    <span class="n">act1</span><span class="p">;</span>
    <span class="n">val1</span> <span class="ow">&lt;-</span> <span class="n">act2</span><span class="p">;</span>
    <span class="kr">let</span> <span class="p">{</span> <span class="n">val2</span> <span class="ow">=</span> <span class="n">expr1</span> <span class="p">};</span>
    <span class="n">actN</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Do.hs</span>
<span class="nf">semicolonTranslated</span> <span class="ow">=</span>
    <span class="n">act1</span> <span class="o">&gt;&gt;</span>
    <span class="kr">let</span> <span class="n">f</span> <span class="n">val1</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">val2</span> <span class="ow">=</span> <span class="n">expr1</span>
                 <span class="kr">in</span> <span class="n">actN</span>
        <span class="n">f</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;...&quot;</span>
    <span class="kr">in</span> <span class="n">act2</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
</pre></div>
</div>
<p>虽然很少人有这么用，但是在单个表达式里面显式地使用分号容易让人产生这种感觉：monads是一种“可编程的分号”，因为在每个monad里面 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> 的行为都是不一样的。</p>
</section>
<section id="sugar-free">
<span id="why-go-sugar-free"></span><h3>为什么要sugar-free<a class="headerlink" href="#sugar-free" title="Permalink to this headline">¶</a></h3>
<p>当我们在代码里面显式使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的时候，它提醒我们在使用组合子组合函数而不是简单的序列化动作。</p>
<p>如果你对monad感觉还很陌生，那么我建议你多显式地使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">do</span></code> 语法来写monadic的代码。这些重复对于大多数的程序员来说都能帮助理解。</p>
<p>当熟悉了monad的时候，你可以按照需要选择你自己的风格；但是永远不要再同一个函数里面混用 <code class="docutils literal notranslate"><span class="pre">do</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 。</p>
<p>不管你用不用do表示法， <code class="docutils literal notranslate"><span class="pre">(=&lt;&lt;)</span></code> 函数经常被使用；它就是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的参数翻转版本。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">=&lt;&lt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">=&lt;&lt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>如果想把monadic函数按照通常Haskell从右往左结合起来的话，那么 <code class="docutils literal notranslate"><span class="pre">(=&lt;&lt;)</span></code> 非常有用。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/CartesianProduct.hs</span>
<span class="nf">wordCount</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">.</span> <span class="n">length</span> <span class="o">.</span> <span class="n">words</span> <span class="o">=&lt;&lt;</span> <span class="n">getContents</span>
</pre></div>
</div>
</section>
</section>
<section id="the-state-monad">
<span id="id19"></span><h2>状态monad<a class="headerlink" href="#the-state-monad" title="Permalink to this headline">¶</a></h2>
<p>在 <a class="reference internal" href="10.html"><span class="doc">第 10 章：代码案例学习：解析二进制数据格式</span></a> 里面我们说 <code class="docutils literal notranslate"><span class="pre">Parse</span></code> 是一个monad。 <code class="docutils literal notranslate"><span class="pre">Parser</span></code> 有两个完全不同的角度像Monad，其一是它在解析失败时候的行为——我们使用 <code class="docutils literal notranslate"><span class="pre">Either</span></code> 表达；其二是它携带这一些隐式的状态信息（每次被部分消耗的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> .</p>
<p>在Haskell里面读写状态这种场景太常见了，因此标准库提供了一个叫做 <code class="docutils literal notranslate"><span class="pre">State</span></code> 的monad解决这个问题。在 <code class="docutils literal notranslate"><span class="pre">Control.Monad.State</span></code> 这个模块可以找到它。</p>
<p>我们的 <code class="docutils literal notranslate"><span class="pre">Parse</span></code> 类型能携带一个 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型的状态， <code class="docutils literal notranslate"><span class="pre">State</span></code> monad可以携带任意类型的状态。姑且把这个未知状态的类型记为 <code class="docutils literal notranslate"><span class="pre">s</span></code> .</p>
<p>我们能对一个状态做什么？给定一个状态的值，我们可以查看这个状态，产生一个结果然后返回一个新的状态。假设计算的结果类型是 <code class="docutils literal notranslate"><span class="pre">a</span></code> . 那么表达这个过程的类型就是 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">s)</span></code> : 接受一个状态 <code class="docutils literal notranslate"><span class="pre">s</span></code> 对它进行某些操作，返回结果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和新状态 <code class="docutils literal notranslate"><span class="pre">s</span></code> .</p>
<section id="state-monad">
<span id="almost-a-state-monad"></span><h3>自己定义State monad<a class="headerlink" href="#state-monad" title="Permalink to this headline">¶</a></h3>
<p>我们先自己实现一个State monad，然后看看标准库的实现是什么样的。首先我们从类型定义开始，正如上面我们已经讨论过的，State的类型定义如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="kr">type</span> <span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>我们定义的monad是把一个状态转换为另外一个状态的函数，在转化的过程中产生一个计算结果。因此，state monad也经常被称为状态转换monad。</p>
<p>在这一章的开始，我们说过monad有一个带单个类型参数的类型构造器，但是这里我们有两个类型参数。理解这里的关键是，我们可以把类型构造器像使用函数一样部分应用（partially apply）；下面是一个最简单的例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="kr">type</span> <span class="kt">StringState</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">SimpleState</span> <span class="kt">String</span> <span class="n">a</span>
</pre></div>
</div>
<p>这里我们把类型变量 <code class="docutils literal notranslate"><span class="pre">s</span></code> 固定为了 <code class="docutils literal notranslate"><span class="pre">String</span></code> 类型。 <code class="docutils literal notranslate"><span class="pre">StringState</span></code> 还带有一个类型参数 <code class="docutils literal notranslate"><span class="pre">a</span></code> ；这样就能比较明显的看出来这个类型与Monad类型构造器比较匹配了。换句话说，现在monad的类型构造器是 <code class="docutils literal notranslate"><span class="pre">SimpleState</span> <span class="pre">s</span></code> ,而不是单独的 <code class="docutils literal notranslate"><span class="pre">SimpleState</span></code> .</p>
<p>实现这个State monad接下来要做的就是定义 <code class="docutils literal notranslate"><span class="pre">return</span></code> 函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="nf">returnSt</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">returnSt</span> <span class="n">a</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>这里 <code class="docutils literal notranslate"><span class="pre">return</span></code> 函数所做的就是接受一个结果和当前状态，把它包装成一个二元组，然后返回。你现在应该已经习惯了Haskell把带有多个参数的函数当成一系列单个参数函数的串联调用，以下是另一种更直观的写法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="nf">returnAlt</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">returnAlt</span> <span class="n">a</span> <span class="n">s</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>实现自定义的State monad最后一步就是定义 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 。下面是标准库的 <code class="docutils literal notranslate"><span class="pre">State</span></code> monad对于 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的实现：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="nf">bindSt</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">SimpleState</span> <span class="n">s</span> <span class="n">b</span>
<span class="nf">bindSt</span> <span class="n">m</span> <span class="n">k</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span> <span class="n">s</span>
                   <span class="kr">in</span> <span class="p">(</span><span class="n">k</span> <span class="n">a</span><span class="p">)</span> <span class="n">s&#39;</span>
</pre></div>
</div>
<p>这些单个参数的变量不太容易懂，先把它们换成一些更可读的名字。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/SimpleState.hs</span>
<span class="c1">-- m == step</span>
<span class="c1">-- k == makeStep</span>
<span class="c1">-- s == oldState</span>

<span class="nf">bindAlt</span> <span class="n">step</span> <span class="n">makeStep</span> <span class="n">oldState</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">newState</span><span class="p">)</span> <span class="ow">=</span> <span class="n">step</span> <span class="n">oldState</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">makeStep</span> <span class="n">result</span><span class="p">)</span> <span class="n">newState</span>
</pre></div>
</div>
</section>
<section id="reading-and-modifying-the-state">
<span id="id20"></span><h3>读取和修改状态<a class="headerlink" href="#reading-and-modifying-the-state" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 的定义仅仅转移状态，但是并不对状态内部做任何事情。因此我们需要一些简单的辅助函数来对状态进行操作。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>       -- file: ch14/SimpleState.hs
       getSt :: SimpleState s s
       getSt = \s -&gt; (s, s)

``getSt`` 函数就是接受当前状态并把它作为计算结果和状态一并返回； ``putSt`` 函数忽略当前状态并使用一个新的状态取代它。
</pre></div>
</div>
</section>
<section id="will-the-real-state-monad-please-stand-up">
<span id="id21"></span><h3>真正的State monad定义<a class="headerlink" href="#will-the-real-state-monad-please-stand-up" title="Permalink to this headline">¶</a></h3>
<p>我们之前实现的 <code class="docutils literal notranslate"><span class="pre">SimpleState</span></code> 仅仅使用了类型别名而不是使用一个新的类型；如果我们当时就使用 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 包装一个新的类型，那么对于这个类型的处理会使我们的代码不太容易懂。</p>
<p>要定义一个Monad的实例，除了实现 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">return</span></code> 还要提供一个合适的类型构造器。这正是标准库的 <code class="docutils literal notranslate"><span class="pre">State</span></code> Monad的做法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/State.hs</span>
<span class="kr">newtype</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">{</span>
      <span class="n">runState</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>这里所做的就是把 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">s)</span></code> 类型用 <code class="docutils literal notranslate"><span class="pre">State</span></code> 构造器包装起来。通过使用Haskell的纪录语法来定义新类型，我们自动获得了一个 <code class="docutils literal notranslate"><span class="pre">runState</span></code> 函数来从类型构造器里面提取状态值。 <code class="docutils literal notranslate"><span class="pre">runState</span></code> 的类型是 `` State s a -&gt; s -&gt; (a, s)``</p>
<p>标准库的State monad中 <code class="docutils literal notranslate"><span class="pre">return</span></code> 的定义和我们的 <code class="docutils literal notranslate"><span class="pre">SimpleState</span></code> 的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 定义基本相同，只不过这里使用 <code class="docutils literal notranslate"><span class="pre">State</span></code> 构造器包装了一下状态函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/State.hs</span>
<span class="nf">returnState</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">returnState</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 要使用 <code class="docutils literal notranslate"><span class="pre">runState</span></code> 函数来提取 <code class="docutils literal notranslate"><span class="pre">State</span></code> 的值，因此它的的定义略微复杂一些。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/State.hs</span>
<span class="nf">bindState</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span>
<span class="nf">bindState</span> <span class="n">m</span> <span class="n">k</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runState</span> <span class="n">m</span> <span class="n">s</span>
                              <span class="kr">in</span> <span class="n">runState</span> <span class="p">(</span><span class="n">k</span> <span class="n">a</span><span class="p">)</span> <span class="n">s&#39;</span>
</pre></div>
</div>
<p>这个函数与我们之前在 <code class="docutils literal notranslate"><span class="pre">SimpleState</span></code> 里面定义的 <code class="docutils literal notranslate"><span class="pre">bindSt</span></code> 函数唯一的不同是它有提取和包装一些值的操作。</p>
<p>同样，我们也修改了读取和修改状态的函数（提取和包装了一些值）：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/State.hs</span>
<span class="nf">get</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">s</span>
<span class="nf">get</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="nf">put</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">put</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="using-the-state-monad-generating-random-values">
<span id="id22"></span><h3>使用State monad生成随机数<a class="headerlink" href="#using-the-state-monad-generating-random-values" title="Permalink to this headline">¶</a></h3>
<p>之前我们使用 <code class="docutils literal notranslate"><span class="pre">Parse</span></code> 解析二进制数据，当时我们把要管理的状态直接放在了 <code class="docutils literal notranslate"><span class="pre">Parse</span></code> 类型里面。</p>
<p>其实 <code class="docutils literal notranslate"><span class="pre">State</span></code> monad可以接受任意的类型作为状态参数，我们可以提供这个状态类型，比如 <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">ByteString</span></code>.</p>
<p>如果你有命令式编程语言的背景的话，相对于别的很多monad，你可能对 <code class="docutils literal notranslate"><span class="pre">State</span></code> 这个monad更加熟悉。毕竟命令式语言所做的就是携带和转移一些隐式的状态，比如读写某些部分，通过赋值修改一些东西；这正是State monad所做的。</p>
<p>既然这样，我们不用费力地解释怎么使用State monad了，直接来个实际的例子就好：生成伪随机数。在命令式编程语言里面，通常有一些很方便使用的均匀分布的伪随机数源；比如在C语言标准库里面，有一个 <code class="docutils literal notranslate"><span class="pre">rand</span></code> 函数使用一个全局的状态生成伪随机数。</p>
<p>Haskell标准库里面生成伪随机数的模块叫做 <code class="docutils literal notranslate"><span class="pre">System.Random</span></code> ，它可以生成任意类型的随机数，而不仅仅是数值类型。这个模块提供了一些非常实用的函数。比如与C语言里面 <code class="docutils literal notranslate"><span class="pre">rand</span></code> 等价的函数如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="kr">import</span> <span class="nn">System.Random</span>

<span class="nf">rand</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">rand</span> <span class="ow">=</span> <span class="n">getStdRandom</span> <span class="p">(</span><span class="n">randomR</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxBound</span><span class="p">))</span>
</pre></div>
</div>
<p>( <code class="docutils literal notranslate"><span class="pre">randomR</span></code> 函数接受一个希望生成的随机数所在范围的闭区间。）</p>
<p><code class="docutils literal notranslate"><span class="pre">System.Random</span></code> 模块提供了一个 <code class="docutils literal notranslate"><span class="pre">RandomGen</span></code> 类型类，它允许我们自行定义一个新的随机整数源。 <code class="docutils literal notranslate"><span class="pre">StdGen</span></code> 类型是标准的 <code class="docutils literal notranslate"><span class="pre">RandomGen</span></code> 的实例，它可以生成伪随机数值。如果我们有一个外部的真实可靠的随机数源，我们可以创建一个 <code class="docutils literal notranslate"><span class="pre">RandomGen</span></code> 的实例来创建真实的随机数，而不是使用伪随机数。</p>
<p><code class="docutils literal notranslate"><span class="pre">Random</span></code> 这个类型类展示了如何给特定的类型生成随机数值。这个模块给所有常见的简单类型创建了 <code class="docutils literal notranslate"><span class="pre">Random</span></code> 的实例。</p>
<p>顺便说下，前面定义的 <code class="docutils literal notranslate"><span class="pre">rand</span></code> 函数也会读取和修改 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中内置的全局随机数生成器。</p>
</section>
<section id="a-first-attempt-at-purity">
<span id="id23"></span><h3>实用纯函数生成随机数的尝试<a class="headerlink" href="#a-first-attempt-at-purity" title="Permalink to this headline">¶</a></h3>
<p>我们一直尽量避免使用 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad，如果仅仅是为了生成随机数就要打破这一点就有点不好意思了。实际上， <code class="docutils literal notranslate"><span class="pre">System.Random</span></code> 模块里面提供了一些纯函数来生成随机数。</p>
<p>使用传统纯函数的缺点是，我们得获取或者手动创建一个随机数生成器，然后把它传递到需要得地方，最终调用这个纯函数的时候回传一个新的随机数生成器：要记住的是，我们是纯函数，所以不能修改已经存在的随机数生成器。</p>
<p>如果我们不管不变性而是直接复用原来的随机数生成器，那么每次我们调用这个函数都会得到完全一样的“随机数”。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">twoBadRandoms</span> <span class="ow">::</span> <span class="kt">RandomGen</span> <span class="n">g</span> <span class="ow">=&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">twoBadRandoms</span> <span class="n">gen</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fst</span> <span class="o">$</span> <span class="n">random</span> <span class="n">gen</span><span class="p">,</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">random</span> <span class="n">gen</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">twoBadRandoms</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">getStdGen</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">old</span><span class="o">-</span><span class="n">locale</span><span class="o">-</span><span class="mf">1.0</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">old</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="mf">1.0</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">random</span><span class="o">-</span><span class="mf">1.0</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="mi">945769311181683171</span><span class="p">,</span><span class="mi">945769311181683171</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的 <code class="docutils literal notranslate"><span class="pre">random</span></code> 函数有一个默认的随机数生成范围，而不是像 <code class="docutils literal notranslate"><span class="pre">randomR</span></code> 一样接受用户传递的参数范围； <code class="docutils literal notranslate"><span class="pre">getStdGen</span></code> 函数从 <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad里面获取全局的标准数据生成器的值。</p>
<p>不幸的是，如果我们把第一个随机数生成之后新的生成器的值正确地传递给第二个随机数的生成过程，代码就不太可读了，下面是个简单的例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">twoGoodRandoms</span> <span class="ow">::</span> <span class="kt">RandomGen</span> <span class="n">g</span> <span class="ow">=&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span>
<span class="nf">twoGoodRandoms</span> <span class="n">gen</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span>
                         <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">gen&#39;&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen&#39;</span>
                     <span class="kr">in</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">gen&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们学到了 <code class="docutils literal notranslate"><span class="pre">State</span></code> monad, 它好像是个比较好的解决办法。 state monad 允许我们整洁地管理可变的状态，并且保证这部分代码与任何诸如修改文件，连接网络等副作用操作分离开来；这样让我们能够更加容易地思考代码的行为。</p>
</section>
<section id="random-values-in-the-state-monad">
<span id="id24"></span><h3>state monad里面的随机数值<a class="headerlink" href="#random-values-in-the-state-monad" title="Permalink to this headline">¶</a></h3>
<p>下面是一个使用 <code class="docutils literal notranslate"><span class="pre">StdGen</span></code> 作为状态的state monad：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="kr">type</span> <span class="kt">RandomState</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="kt">StdGen</span> <span class="n">a</span>
</pre></div>
</div>
<p>上面的类型别名不是必要的，但是很有用；其一它可以让我们少敲几个字符，其二，如果我们想使用别的随机数生成器而不是 <code class="docutils literal notranslate"><span class="pre">StdGen</span></code> ，我们可以少修改一些类型签名。</p>
<p>有了 <code class="docutils literal notranslate"><span class="pre">RandomState</span></code> ，生成随机数值就是获取当前的随机数生成器，使用它然后用新的随机数生成器修改当前状态就行了。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">getRandom</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">RandomState</span> <span class="n">a</span>
<span class="nf">getRandom</span> <span class="ow">=</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">gen</span> <span class="ow">-&gt;</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">gen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span> <span class="kr">in</span>
  <span class="n">put</span> <span class="n">gen&#39;</span> <span class="o">&gt;&gt;</span>
  <span class="n">return</span> <span class="n">val</span>
</pre></div>
</div>
<p>现在我们可以用之前学到的知识写一些monadic的代码来生成一对随机数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">getTwoRandoms</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">RandomState</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">getTwoRandoms</span> <span class="ow">=</span> <span class="n">liftM2</span> <span class="p">(,)</span> <span class="n">getRandom</span> <span class="n">getRandom</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3>练习<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>用 <code class="docutils literal notranslate"><span class="pre">do</span></code> 重写 <code class="docutils literal notranslate"><span class="pre">getRandom</span></code> 函数</p></li>
</ol>
</section>
<section id="running-the-state-monad">
<span id="id26"></span><h3>运行state monad<a class="headerlink" href="#running-the-state-monad" title="Permalink to this headline">¶</a></h3>
<p>之前提到过，每个monad都有他自己的求值函数；在state monad里面，有几个求值函数可供选择。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">runState</span></code> 返回求值结果和最终状态</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">evalState</span></code> 只返回结果</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">execState</span></code> 只返回最终状态</p></li>
</ol>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">evalState</span></code> 和 <code class="docutils literal notranslate"><span class="pre">execState</span></code> 函数其实就是 <code class="docutils literal notranslate"><span class="pre">runState</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fst</span></code> , <code class="docutils literal notranslate"><span class="pre">snd</span></code> 函数的简单组合。所以三个里面最重要的是要记住 <code class="docutils literal notranslate"><span class="pre">runState</span></code> .</p>
</div></blockquote>
<p>下面是实现 <code class="docutils literal notranslate"><span class="pre">getTwoRandoms</span></code> 一个完整的例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">runTwoRandoms</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">runTwoRandoms</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">oldState</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">newState</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runState</span> <span class="n">getTwoRandoms</span> <span class="n">oldState</span>
  <span class="n">setStdGen</span> <span class="n">newState</span>
  <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
</section>
<section id="id27">
<h3>管理更多的状态<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>很难想象针对单个状态我们竟写了这么多有趣的代码，当我们想一次性纪录多个状态的时候，通常的办法是把这些状态放在一个数据结构里面管理。下面是一个纪录我们生成随机数数目的例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="kr">data</span> <span class="kt">CountedRandom</span> <span class="ow">=</span> <span class="kt">CountedRandom</span> <span class="p">{</span>
      <span class="n">crGen</span> <span class="ow">::</span> <span class="kt">StdGen</span>
    <span class="p">,</span> <span class="n">crCount</span> <span class="ow">::</span> <span class="kt">Int</span>
    <span class="p">}</span>

<span class="kr">type</span> <span class="kt">CRState</span> <span class="ow">=</span> <span class="kt">State</span> <span class="kt">CountedRandom</span>

<span class="nf">getCountedRandom</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">CRState</span> <span class="n">a</span>
<span class="nf">getCountedRandom</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">st</span> <span class="ow">&lt;-</span> <span class="n">get</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">gen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="p">(</span><span class="n">crGen</span> <span class="n">st</span><span class="p">)</span>
  <span class="n">put</span> <span class="kt">CountedRandom</span> <span class="p">{</span> <span class="n">crGen</span> <span class="ow">=</span> <span class="n">gen&#39;</span><span class="p">,</span> <span class="n">crCount</span> <span class="ow">=</span> <span class="n">crCount</span> <span class="n">st</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
  <span class="n">return</span> <span class="n">val</span>
</pre></div>
</div>
<p>上面的函数每次被调用的时候都会处理状态的两个元素然后返回一个全新的状态；更常见的情况是我们只需要读写整个状态的某一部分；下面的函数可以获取当前生成过的随机数的数目：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">getCount</span> <span class="ow">::</span> <span class="kt">CRState</span> <span class="kt">Int</span>
<span class="nf">getCount</span> <span class="ow">=</span> <span class="n">crCount</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">get</span>
</pre></div>
</div>
<p>这个例子也说明了我们为什么要使用纪录语法定义 <code class="docutils literal notranslate"><span class="pre">CountedRandom</span></code> 状态；使用纪录函数提供的访问函数，把它与 <code class="docutils literal notranslate"><span class="pre">get</span></code> 函数结合起来可以很方便地读取状态的特定部分。</p>
<p>如果想要更新整个状态的某一部分，下面的代码可能不是很吸引人：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">putCount</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">CRState</span> <span class="nb">()</span>
<span class="nf">putCount</span> <span class="n">a</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">st</span> <span class="ow">&lt;-</span> <span class="n">get</span>
  <span class="n">put</span> <span class="n">st</span> <span class="p">{</span> <span class="n">crCount</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">}</span>
</pre></div>
</div>
<p>这一段代码我们使用了纪录更新语法而不是用一个函数。表达式 <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">{</span> <span class="pre">crCount</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">}</span></code> 会创建一个和 <code class="docutils literal notranslate"><span class="pre">st</span></code> 几乎完全相等的值，只是使用给定的 <code class="docutils literal notranslate"><span class="pre">a</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">crCount</span></code>  字段的值。由于这是个语法上的小技巧，因此它没有使用函数那么灵活。纪录语法可能并没有Haskell通常的语法那么优雅，但是至少它能完成我们的目的。</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">modify</span></code> 组合了 <code class="docutils literal notranslate"><span class="pre">get</span></code> 和 <code class="docutils literal notranslate"><span class="pre">put</span></code> , 它接受一个状态转换函数，但是依然不太令人满意：还是需要使用纪录语法。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/Random.hs</span>
<span class="nf">putCountModify</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">CRState</span> <span class="nb">()</span>
<span class="nf">putCountModify</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">modify</span> <span class="o">$</span> <span class="nf">\</span><span class="n">st</span> <span class="ow">-&gt;</span> <span class="n">st</span> <span class="p">{</span> <span class="n">crCount</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="monadfunctors">
<span id="monad-and-functors"></span><h2>Monad和Functors<a class="headerlink" href="#monadfunctors" title="Permalink to this headline">¶</a></h2>
<p>Functor和Monad之间有非常紧密的联系，这两个术语是从数学里面的范畴论引入的，但是又与数学定义不完全相同。</p>
<p>在范畴论里面，monad通过functor构建出来。你可能希望在Haskell里面也是这样，也就是 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 这个类型类是 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> 类型类的子类；但是在标准库的Prelude里面并不是这么定义的。这是个很不幸的疏忽。</p>
<p>但是，Haskell库的作者们提供了一个变通方案：一旦他们写了一个 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 的实例，几乎总是也给 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> 定义一个实例。所以对于任何monad你都可以使用 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> 类型类的 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 函数。</p>
<p>如果把 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 函数的类型签名与我们已经见到过标准库里面Monad的一些函数做比较，大致就知道在monad里面 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 函数是干什么的了。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>ghci&gt; :type fmap
fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
ghci&gt; :module +Control.Monad
ghci&gt; :type liftM
liftM :: (Monad m) =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</pre></div>
</div>
<p>可以看出， <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 函数作用和 <code class="docutils literal notranslate"><span class="pre">liftM</span></code> 一样，它把一个纯函数lift到monad里面。</p>
<section id="id28">
<h3>换个角度看Monad<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>我们已经知道了monad和functor之间的联系，如果回头再看看List这个monad，会发现一些有趣的东西；具体来说，是list的 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 定义。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>       -- file: ch14/ListMonad.hs
       instance Monad [] where
           return x = [x]
           xs &gt;&gt;= f = concat (map f xs)

``f`` 的类型是 ``a -&gt; [a]`` 我们调用 ``map f xs`` 的时候，我们会得到一个类型是 ``[[a]]`` 的值，然后我们必须使用 ``concat`` 把它“扁平化”（flatten).
</pre></div>
</div>
<p>想一想如果 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Functor</span></code> 的子类的时候我们能做什么；由于list的 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 定义就是 <code class="docutils literal notranslate"><span class="pre">map</span></code> , 在 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 定义里面我们可以使用 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 替换 <code class="docutils literal notranslate"><span class="pre">map</span></code> .这个替换本身并没有什么特殊意义，我们再进一步探讨一下。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">concat</span></code> 函数的类型是 <code class="docutils literal notranslate"><span class="pre">[[a]]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code> :正如我们提到的，它把一个嵌套的列表压平。我们可以把list的这函数的类型签名从list推广到所有monad，也就是一个“移除一层嵌套”的类型 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>; 具有这种类型前面的函数通常叫做 <code class="docutils literal notranslate"><span class="pre">join</span></code> .</p>
</div></blockquote>
<p>如果已经有了 <code class="docutils literal notranslate"><span class="pre">join</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 的定义，我们就不需要为每一个monad定义一个 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 函数了，因为它完全可以由 <code class="docutils literal notranslate"><span class="pre">join</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 定义出来。下面是 <code class="docutils literal notranslate"><span class="pre">Monad</span></code> 类型类另外一种定义方式。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/AltMonad.hs</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">((</span><span class="o">&gt;&gt;=</span><span class="p">),</span> <span class="nf">return</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">AltMonad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">join</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>

<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">AltMonad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">join</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>不能说哪一种定义比另外一种更好，因为有了 <code class="docutils literal notranslate"><span class="pre">join</span></code> 我们可以定义 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> ，反之亦然。但是这两个不同的角度给了我们对Monad全新的认识。</p>
<p>移除一层monadic包装实际上是非常有用的，在 <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> 里面由一个标准的 <code class="docutils literal notranslate"><span class="pre">join</span></code> 定义。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadJoin.hs</span>
<span class="nf">join</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">join</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">id</span>
</pre></div>
</div>
<p>下面是一些使用 <code class="docutils literal notranslate"><span class="pre">join</span></code> 的例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">join</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">))</span>
<span class="kt">Just</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">join</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">join</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="the-monad-laws-and-good-coding-style">
<span id="id29"></span><h2>单子律以及代码风格<a class="headerlink" href="#the-monad-laws-and-good-coding-style" title="Permalink to this headline">¶</a></h2>
<p>在 <a class="reference internal" href="10.html#thinking-more-about-functors"><span class="std std-ref">更多关于 Functor 的思考</span></a> 里面我们介绍了functors必须遵从的两条规则：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">fmap</span> <span class="n">id</span>        <span class="o">==</span>   <span class="n">id</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span>   <span class="o">==</span>   <span class="n">fmap</span> <span class="n">f</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span>
</pre></div>
</div>
<p>monads也有它们必须遵从的规则。下面的三条规则被称为单子律。Haskell并不会强制检查这些规则： 完全由monad的作者保证。</p>
<p>单子律就是简单而正式地表达“某个单子不会表现得让人惊讶”的意思。原则上讲，我们可以完全不管这些规则定义自己的monad，但是如果我们这么干会为人所不齿的；因为单子律有一些我们可能忽视的宝藏。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>下面的每一条规则，<code class="docutils literal notranslate"><span class="pre">==</span></code> 左边的表达式等价于右边的表达式。</p>
</div>
<p>第一条规则说的是 <code class="docutils literal notranslate"><span class="pre">return</span></code> 是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的 <em>Left identity</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>            <span class="o">===</span>   <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>另外一种理解这条规则的方式是：如果我们仅仅是把一个纯值包装到monad里面然后使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 调用的话，我们就没有必要使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 了；使用monad的新手通常所犯的错误就是使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 把一个纯值包装为monadic的，然后接下来由使用 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 把这个值取出来。下面是使用do表示法表达这个规律的等价形式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="kr">do</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="n">x</span>
   <span class="n">f</span> <span class="n">y</span>                    <span class="o">===</span>   <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>这条规则对于我们的代码风格有着实际上的指导意义：我们不想写一些不必要的代码；这条规则保证了简短的写法和冗余的写法是等价的。</p>
<p>单子律的第二条说的是 <code class="docutils literal notranslate"><span class="pre">return</span></code> 是 <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> 的 <em>Right identity</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>              <span class="o">===</span>   <span class="n">m</span>
</pre></div>
</div>
<p>如果你以前使用命令式编程语言，那么这一条规则对风格也有好处：如果在一系列的action块里面，如果最后一句就是需要返回的正确结果，那么就不需要使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 了；看看使用 <code class="docutils literal notranslate"><span class="pre">do</span></code> 表示法如何表达这条规则：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="kr">do</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">m</span>
   <span class="n">return</span> <span class="n">y</span>               <span class="o">===</span>   <span class="n">m</span>
</pre></div>
</div>
<p>和第一条规则一样，这条规律也能帮助我们简化代码。</p>
<p>单子律最后一条和结合性有关。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>   <span class="o">===</span>   <span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
</pre></div>
</div>
<p>这条规则有点难理解，我们先看看等式两边括号里面的内容；等式左边可以重新表示成这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">s</span>
  <span class="kr">where</span> <span class="n">s</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
</pre></div>
</div>
<p>等式右边也做类似的处理：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">t</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="kr">where</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
</pre></div>
</div>
<p>现在我们可以把上述规律表达成如下等价形式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch14/MonadLaws.hs</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">s</span>                   <span class="o">===</span>   <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
</pre></div>
</div>
<p>这条规则的意思是，如果我们把一个大的action分解成一系列的子action，只要我们保证子action的顺序，把哪些子action提取出来组合成一个新action对求值结果是没有影响的。如果我们由三个action串联在一起，我们可以把前两个action替换为它们的组合然后串联第三个，也可以用第一个action串联后面两个cation的组合。</p>
<p>这条较为复杂的规律对我们的代码风格也有一些意义。在软件重构里面，有一个专业术语叫做“提取方法”，它说的就是在一大段代码里面提取出一些代码片段然后组合成一个新的函数，在原始代码里面调用新的函数来取代提取出来的内容；第三条单子律保证了这种做法在Haskell的monadic代码里面也可以使用这种技术。</p>
<p>三条单子律都能帮助我们写出更好的monadic代码；前两条规则指导我们如何避免使用不必要的 <code class="docutils literal notranslate"><span class="pre">return</span></code> , 第三条规则让我们能安全地把一个复杂的action冲构成一系列小的action。我们现在可以不管这些细节，通过直觉我们知道在一个实现良好的monad里面，这些规则是不会被违背的。</p>
<p>顺便说一下，Haskell编译器并不并不能保证一个monad是否遵守单子律。monad的实现者必须确保自己的代码满足（最好是证明）单子律。</p>
</section>
</section>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="13.html">第 13 章：数据结构</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="15.html">第 15 章：使用 Monad 编程</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, huangz1990.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>