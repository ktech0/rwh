<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>第 24 章：并发和多核编程 &#8212; Real World Haskell 中文版</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="第 25 章：性能剖析与优化" href="25.html" />
    <link rel="prev" title="第 23 章：用 gtk2hs 进行图形界面编程" href="23.html" /> 
  </head><body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="23.html">第 23 章：用 gtk2hs 进行图形界面编程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="25.html">第 25 章：性能剖析与优化</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <section id="id1">
<h1>第 24 章：并发和多核编程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>在撰写此书时，CPU 架构的景观正以几十年来最快的速度发生变化。</p>
<section id="id2">
<h2>定义并发和并行<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>一个并发程序需要同时处理多个互不相关的任务。考虑一下游戏服务器的例子：典型做法是将数十个组件组合起来，其中的每一个都与外部有复杂交互。可能其中某个组件负责多个用户间聊天；另外一些负责处理玩家的输入，并且将更新后的状态返回给客户端；同时还有其他程序执行物理计算。</p>
<p>并发程序的正确运转并不需要多核，尽管多核可以提高执行效率和响应速度。</p>
<p>相比之下，一个并行程序仅解决一个单独的问题。假设一个金融模型尝试计算并预测下一分钟某支股票的价格波动。如果想在某个交易所列出的所有股票上执行这个模型，例如计算一下那些股票应该买入或卖出，我们希望在五百个核上可以比仅有一个核的时候跑得更快。这表明，并行程序通常不需要通过多核来保证正确性。</p>
<p>另一个有效区分并行和并发的点在于他们如何与外部世界交互。由定义，并发程序连续不断的处理网络协议和数据库之类的东西。典型的并行程序可能更专注：其接收流入的数据，咀嚼一会儿（间或有点 I/O），然后将需要返回的数据流吐出来。</p>
<p>许多传统编程语言进一步模糊了并发和并行之间已经难以辨认的边界，这些语言强制程序员使用相同的基础设施投监这两种程序。</p>
<p>本章将涉及在单个操作系统进程内进行并发和并行编程。</p>
</section>
<section id="id3">
<h2>用线程进行并发编程<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>作为并发编程的基础，大多数语言提供了创建多个多线程的方法。 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 也不例外，尽管使用 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 进行线程编程看起来和其他语言有些不同。</p>
<p>In Haskell, a thread is an IO action that executes independently from other threads. To create a thread, we import the Control.Concurrent module and use the forkIO function
<code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 中，线程是互相独立的 <code class="docutils literal notranslate"><span class="pre">IO</span></code> 动作。为创建线程，需要导入 <code class="docutils literal notranslate"><span class="pre">Control.Concurrent</span></code> 模块并使用其中的 <code class="docutils literal notranslate"><span class="pre">forkIO</span></code> 函数</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Concurrent</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">forkIO</span>
<span class="nf">forkIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">ThreadId</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">System</span><span class="o">.</span><span class="kt">Directory</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">forkIO</span> <span class="p">(</span><span class="n">writeFile</span> <span class="s">&quot;xyzzy&quot;</span> <span class="s">&quot;seo craic nua!&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">doesFileExist</span> <span class="s">&quot;xyzzy&quot;</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>新线程几乎立即开始执行，创建它的线程同时继续向下执行。新线程将在它的 <code class="docutils literal notranslate"><span class="pre">IO</span></code> 动作结束后停止执行。</p>
<section id="id4">
<h3>线程的不确定性<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>GHC 的运行时组件并不按特定顺序执行多个线程。所以，上面的例子中，文件 xyzzy 的创建时间在初始线程检查其是否存在之前或之后都有可能。如果删除 xyzzy 并且再执行一次，我们可能得到完全相反的结果。</p>
</section>
<section id="id5">
<h3>隐藏延迟<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>假设我们要将一个大文件压缩并写入磁盘，但是希望快速处理用户输入以使他们感觉程序是立即响应的。如果使用 <code class="docutils literal notranslate"><span class="pre">forkIO</span></code> 来开启一个单独的线程去写文件，这样就可以同时做这两件事。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Compressor.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="nf">forkIO</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">handle</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">L</span>
<span class="kr">import</span> <span class="nn">System.Console.Readline</span> <span class="p">(</span><span class="nf">readline</span><span class="p">)</span>

<span class="c1">-- http://hackage.haskell.org/ 上的 zlib 包提供了压缩功能</span>
<span class="kr">import</span> <span class="nn">Codec.Compression.GZip</span> <span class="p">(</span><span class="nf">compress</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">maybeLine</span> <span class="ow">&lt;-</span> <span class="n">readline</span> <span class="s">&quot;Enter a file to compress&gt; &quot;</span>
    <span class="kr">case</span> <span class="n">maybeLine</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>      <span class="c1">-- 用户输入了 EOF</span>
      <span class="kt">Just</span> <span class="s">&quot;&quot;</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>      <span class="c1">-- 不输入名字按 “想要退出” 处理</span>
      <span class="kt">Just</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
           <span class="n">handle</span>
             <span class="p">(</span><span class="n">print</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">SomeException</span><span class="ow">-&gt;</span><span class="kt">IO</span> <span class="nb">()</span><span class="p">))</span>
             <span class="o">$</span> <span class="kr">do</span>
                 <span class="n">content</span> <span class="ow">&lt;-</span> <span class="kt">L</span><span class="o">.</span><span class="n">readFile</span> <span class="n">name</span>
                 <span class="n">forkIO</span> <span class="p">(</span><span class="n">compressFile</span> <span class="n">name</span> <span class="n">content</span><span class="p">)</span>
                 <span class="n">return</span> <span class="nb">()</span>
           <span class="n">main</span>
  <span class="kr">where</span> <span class="n">compressFile</span> <span class="n">path</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">writeFile</span> <span class="p">(</span><span class="n">path</span> <span class="o">++</span> <span class="s">&quot;.gz&quot;</span><span class="p">)</span> <span class="o">.</span> <span class="n">compress</span>
</pre></div>
</div>
<p>[
Forec 译注：
原著代码稍微有点瑕疵，上面是修正后的版本。
此外，在部分 GHC 中执行上述程序可能遇到 <code class="docutils literal notranslate"><span class="pre">System.Console.Readline</span></code> 包无法导入的情况。<code class="docutils literal notranslate"><span class="pre">Readline</span></code> 是 <code class="docutils literal notranslate"><span class="pre">GNU</span> <span class="pre">readline</span></code> 库的 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 绑定，你可以在 <a class="reference external" href="http://www.gnu.org/software/readline/">http://www.gnu.org/software/readline/</a> 获取稳定版本的 readline 库。
另一种解决方法是使用 <code class="docutils literal notranslate"><span class="pre">haskeline</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">readline</span></code> ，它的文档位于 <a class="reference external" href="http://hackage.haskell.org/package/haskeline-0.7.3.1/docs/System-Console-Haskeline.html">http://hackage.haskell.org/package/haskeline-0.7.3.1/docs/System-Console-Haskeline.html</a> ：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="nf">forkIO</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">handle</span><span class="p">,</span> <span class="kt">SomeException</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">L</span>
<span class="kr">import</span> <span class="nn">System.Console.Haskeline</span> <span class="p">(</span><span class="nf">runInputT</span><span class="p">,</span> <span class="nf">defaultSettings</span><span class="p">,</span> <span class="nf">getInputLine</span><span class="p">)</span>

<span class="c1">-- Provided by the &#39;zlib&#39; package on http://hackage.haskell.org/</span>
<span class="kr">import</span> <span class="nn">Codec.Compression.GZip</span> <span class="p">(</span><span class="nf">compress</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">maybeLine</span> <span class="ow">&lt;-</span> <span class="n">runInputT</span> <span class="n">defaultSettings</span> <span class="o">$</span> <span class="n">getInputLine</span> <span class="s">&quot;Enter a file to compress&gt; &quot;</span>
  <span class="kr">case</span> <span class="n">maybeLine</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span> <span class="c1">-- user entered EOF</span>
    <span class="kt">Just</span> <span class="s">&quot;&quot;</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span> <span class="c1">-- treat no name as &quot;want to quit&quot;</span>
    <span class="kt">Just</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">handle</span> <span class="p">(</span><span class="n">print</span> <span class="ow">::</span> <span class="kt">SomeException</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">content</span> <span class="ow">&lt;-</span> <span class="kt">L</span><span class="o">.</span><span class="n">readFile</span> <span class="n">name</span>
        <span class="n">forkIO</span> <span class="p">(</span><span class="n">compressFile</span> <span class="n">name</span> <span class="n">content</span><span class="p">)</span>
        <span class="n">return</span> <span class="nb">()</span>
      <span class="n">main</span>
</pre></div>
</div>
<p>]</p>
<p>因为使用了惰性的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>  I/O ，主线程中做仅仅是打开文件。真正读取文件内容发生在子线程中。</p>
<p>当用户输入的文件名并不存在时将发生异常， <code class="docutils literal notranslate"><span class="pre">handle</span> <span class="pre">(print</span> <span class="pre">::</span> <span class="pre">(SomeException-&gt;</span> <span class="pre">IO</span> <span class="pre">()))</span></code> 是一个低成本的打印错误信息的方式。</p>
</section>
</section>
<section id="id6">
<h2>线程间的简单通信<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>在两个线程之间共享信息最简单的方法是，让它们使用同一个变量。上面文件压缩的例子中， <code class="docutils literal notranslate"><span class="pre">main</span></code> 线程与子线程共享了文件名和文件内容。 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 的数据默认是不可变的，所以这样共享不会有问题，两个线程都无法修改另一个线程中的文件名和文件内容。</p>
<p>线程经常需要和其他线程进行活跃的通信。例如， <code class="docutils literal notranslate"><span class="pre">GHC</span></code>  没有提供查看其他线程是否还在执行、执行完毕、或者崩溃的方法 <a class="footnote-reference brackets" href="#id39" id="id7">54</a> 。可是，其提供了同步变量类型， <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，我们可以通过它自己实现上述功能。</p>
<p><code class="docutils literal notranslate"><span class="pre">MVar</span></code> 的行为类似一个单元素的箱子：其可以为满或空。将一些东西扔进箱子，使其填满，或者从中拿出一些东西，使其变空。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">putMVar</span>
<span class="nf">putMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">takeMVar</span>
<span class="nf">takeMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>
</div>
<p>尝试将一个值放入非空的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，将会导致线程休眠直到其他线程从其中拿走一个值使其变空。类似的，如果尝试从一个空的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 取出一个值，线程也将休眠，直到其他线程向其中放入一个值。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/MVarExample.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span>

<span class="nf">communicate</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">newEmptyMVar</span>
  <span class="n">forkIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">m</span>
    <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;received &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="s">&quot;sending&quot;</span>
  <span class="n">putMVar</span> <span class="n">m</span> <span class="s">&quot;wake up!&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">newEmptyMVar</span></code> 函数的作用从其名字一目了然。要创建一个初始状态非空的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，需要使用 <code class="docutils literal notranslate"><span class="pre">newMVar</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">newEmptyMVar</span>
<span class="nf">newEmptyMVar</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">MVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">newMVar</span>
<span class="nf">newMVar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">MVar</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">ghci</span></code> 运行一下上面例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">MVarExample</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">MVarExample</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">communicate</span>
<span class="nf">sending</span>
<span class="nf">rece</span>
</pre></div>
</div>
<p>如果有使用传统编程语言编写并发程序的经验，你会想到 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 有助于实现两个熟悉的效果。</p>
<blockquote>
<div><ul class="simple">
<li><p>从一个线程向另一个线程发送消息，例如：一个提醒。</p></li>
<li><p>对线程间共享的可变数据提供互斥。在数据没有被任何线程使用时，将其放入 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，某线程需要读取或改变它时，将其临时从中取出。</p></li>
</ul>
</div></blockquote>
</section>
<section id="id8">
<h2>主线程等待其他线程<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>GHC 的运行时系统对主线程的控制与其他线程不同。主线程结束时，运行时系统认为整个程序已经跑完了。其他没有执行完毕的线程，会被强制终止。</p>
<p>所以，如果线程执行时间非常长，且必须不被杀死，必须对主线程做特殊安排，以使得主线程在其他线程完成前都不退出。让我们来开发一个小库实现这一点。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="kt">Exception</span><span class="p">,</span> <span class="nf">try</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>

<span class="kr">data</span> <span class="kt">ThreadStatus</span> <span class="ow">=</span> <span class="kt">Running</span>
                  <span class="o">|</span> <span class="kt">Finished</span>         <span class="c1">-- 正常退出</span>
                  <span class="o">|</span> <span class="kt">Threw</span> <span class="kt">Exception</span>  <span class="c1">-- 被未捕获的异常终结</span>
                    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- | 创建一个新线程管理器</span>
<span class="nf">newManager</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">ThreadManager</span>

<span class="c1">-- | 创建一个被管理的线程</span>
<span class="nf">forkManaged</span> <span class="ow">::</span> <span class="kt">ThreadManager</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">ThreadId</span>

<span class="c1">-- | 立即返回一个被管理线程的状态</span>
<span class="nf">getStatus</span> <span class="ow">::</span> <span class="kt">ThreadManager</span> <span class="ow">-&gt;</span> <span class="kt">ThreadId</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">ThreadStatus</span><span class="p">)</span>

<span class="c1">-- | 阻塞，直到某个特定的被管理线程终结</span>
<span class="nf">waitFor</span> <span class="ow">::</span> <span class="kt">ThreadManager</span> <span class="ow">-&gt;</span> <span class="kt">ThreadId</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">ThreadStatus</span><span class="p">)</span>

<span class="c1">-- | 阻塞，直到所有被管理线程终结</span>
<span class="nf">waitAll</span> <span class="ow">::</span> <span class="kt">ThreadManager</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>[Forec 译注：需要对代码做一些改动。在新版本 <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> 中，<code class="docutils literal notranslate"><span class="pre">Exception</span></code> 的 kind 是 <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>，需要提供一个具体型别作为参数。
可以将代码中的两处 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">SomeException</span></code>。]</p>
<p>我们使用一个常见的方法来实现 <code class="docutils literal notranslate"><span class="pre">ThreadManager</span></code> 的类型抽象：将其包裹进一个 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> ，并防止使用者直接创建这个类型的值。在模块的导出声明中，我们列出了一个创建线程管理器的 IO 动作，但是并不直接导出类型构造器。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="kr">module</span> <span class="nn">NiceFork</span>
    <span class="p">(</span>
      <span class="kt">ThreadManager</span>
    <span class="p">,</span> <span class="nf">newManager</span>
    <span class="p">,</span> <span class="nf">forkManaged</span>
    <span class="p">,</span> <span class="nf">getStatus</span>
    <span class="p">,</span> <span class="nf">waitFor</span>
    <span class="p">,</span> <span class="nf">waitAll</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ThreadManager</span></code> 的实现中维护了一个线程 ID 到线程状态的 map 。我们将此作为线程 map 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="kr">newtype</span> <span class="kt">ThreadManager</span> <span class="ow">=</span>
    <span class="kt">Mgr</span> <span class="p">(</span><span class="kt">MVar</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">ThreadId</span> <span class="p">(</span><span class="kt">MVar</span> <span class="kt">ThreadStatus</span><span class="p">)))</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>

<span class="nf">newManager</span> <span class="ow">=</span> <span class="kt">Mgr</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">newMVar</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span>
</pre></div>
</div>
<p>此处使用了两层 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。首先将 <code class="docutils literal notranslate"><span class="pre">Map</span></code> 保存在 MVar 中。这将允许通过使用新版本替换来“改变” map 中的值。同样确保了每个使用这个 <code class="docutils literal notranslate"><span class="pre">Map</span></code> 的线程可以看到一致的内容。</p>
<p>对每个被管理的线程，都维护一个对应的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。这种 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 从空状态开始，表示这个线程正在执行。当线程被杀死或者发生未处理异常导致退出时，我们将此类信息写入这个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。</p>
<p>为了创建一个线程并观察它的状态，必须做一点簿记。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="nf">forkManaged</span> <span class="p">(</span><span class="kt">Mgr</span> <span class="n">mgr</span><span class="p">)</span> <span class="n">body</span> <span class="ow">=</span>
    <span class="n">modifyMVar</span> <span class="n">mgr</span> <span class="o">$</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">state</span> <span class="ow">&lt;-</span> <span class="n">newEmptyMVar</span>
      <span class="n">tid</span> <span class="ow">&lt;-</span> <span class="n">forkIO</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="n">body</span>
        <span class="n">putMVar</span> <span class="n">state</span> <span class="p">(</span><span class="n">either</span> <span class="kt">Threw</span> <span class="p">(</span><span class="n">const</span> <span class="kt">Finished</span><span class="p">)</span> <span class="n">result</span><span class="p">)</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="n">tid</span> <span class="n">state</span> <span class="n">m</span><span class="p">,</span> <span class="n">tid</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：
上面这段代码中有一些对读者而言可能相对生疏的函数，在此稍作解释：<code class="docutils literal notranslate"><span class="pre">try</span></code> 的型别声明是 <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">e</span> <span class="pre">=&gt;</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">(Either</span> <span class="pre">e</span> <span class="pre">a)</span></code> ，它执行一个 IO 操作，若执行过程中发生异常则返回 <code class="docutils literal notranslate"><span class="pre">Left</span> <span class="pre">e</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">Right</span></code>。
<code class="docutils literal notranslate"><span class="pre">either</span></code> 的型别声明是 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>，如果 <code class="docutils literal notranslate"><span class="pre">try</span></code> 返回的是 <code class="docutils literal notranslate"><span class="pre">Left</span></code> 类型，<code class="docutils literal notranslate"><span class="pre">either</span></code> 会用 <code class="docutils literal notranslate"><span class="pre">Threw</span></code> 将异常值包裹，否则无论 <code class="docutils literal notranslate"><span class="pre">Right</span></code> 中包含的值是什么，都返回 <code class="docutils literal notranslate"><span class="pre">Finished</span></code> 的状态。
关于 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> ，请看下一节的介绍。它的返回值是一个 tuple，这个 tuple 的第一个元素将被放回到 <code class="docutils literal notranslate"><span class="pre">mgr</span></code> 中，而第二个元素会作为返回值。
]</p>
<section id="mvar">
<h3>安全的修改 MVar<a class="headerlink" href="#mvar" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">forkManaged</span></code> 中使用的 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 函数很实用：它将 <code class="docutils literal notranslate"><span class="pre">takeMVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putMVar</span></code> 安全的组合在一起。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">modifyMVar</span>
<span class="nf">modifyMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
</pre></div>
</div>
<p>其从一个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 中取出一个值，并传入一个函数。这个函数生成一个新的值，且返回一个结果。如果函数抛出一个异常， <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 会将初始值重新放回 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，否则其会写入新值。它还会返回另一个返回值。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 而非手动使用 <code class="docutils literal notranslate"><span class="pre">takeMVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putMVar</span></code> 管理 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ， 可以避免两类并发场景下的问题。</p>
<blockquote>
<div><ul class="simple">
<li><p>忘记将一个值放回 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。有的线程会一直等待 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 中被放回一个值，如果一致没有等到，就将导致死锁。</p></li>
<li><p>没有考虑可能出现的异常，扰乱了某端代码的控制流。这可能导致一个本应执行的 <code class="docutils literal notranslate"><span class="pre">putMVar</span></code> 没有执行，进而导致死锁。</p></li>
</ul>
</div></blockquote>
<p>因为这些美妙的安全特性，尽可能的使用 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 是明智的选择。</p>
</section>
<section id="id9">
<h3>安全资源管理：一个相对简单的好主意。<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 遵循的模式适用很多场景。下面是这些模式：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>获得一份资源。</p></li>
<li><p>将资源传入一个将处理它函数。</p></li>
<li><p>始终释放资源，即使函数抛出异常。如果发生异常，重新抛出异常，以便使其被程序捕获。</p></li>
</ol>
</div></blockquote>
<p>除了安全性，这个方法还有其他好处：可以是代码更简短且容易理解。正如前面的 <code class="docutils literal notranslate"><span class="pre">forkManaged</span></code> ， <code class="docutils literal notranslate"><span class="pre">Hakell</span></code> 的简洁语法和匿名函数使得这种风格的代码看起来一点都不刺眼。</p>
<p>下面是 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 的定义，从中可以了解这个模式的细节：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ModifyMVar.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="kt">MVar</span><span class="p">,</span> <span class="nf">putMVar</span><span class="p">,</span> <span class="nf">takeMVar</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">block</span><span class="p">,</span> <span class="nf">catch</span><span class="p">,</span> <span class="nf">throw</span><span class="p">,</span> <span class="nf">unblock</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">catch</span><span class="p">)</span> <span class="c1">-- use Control.Exception&#39;s version</span>

<span class="nf">modifyMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
<span class="nf">modifyMVar</span> <span class="n">m</span> <span class="n">io</span> <span class="ow">=</span>
  <span class="n">block</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">m</span>
    <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">unblock</span> <span class="p">(</span><span class="n">io</span> <span class="n">a</span><span class="p">)</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span>
             <span class="n">putMVar</span> <span class="n">m</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">throw</span> <span class="n">e</span>
    <span class="n">putMVar</span> <span class="n">m</span> <span class="n">b</span>
    <span class="n">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>这种模式很容易用于你的特定需求，无论是处理网络连接，数据库句柄，或者被 <code class="docutils literal notranslate"><span class="pre">C</span></code> 库函数管理的数据。</p>
<p>[Forec 译注：<code class="docutils literal notranslate"><span class="pre">block</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unblock</span></code> 在很久以前就已经被弃置了。最新 base 包中 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 的实现如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">modifyMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
<span class="nf">modifyMVar</span> <span class="n">m</span> <span class="n">io</span> <span class="ow">=</span>
  <span class="n">mask</span> <span class="o">$</span> <span class="nf">\</span><span class="n">restore</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
  <span class="n">a</span>      <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">m</span>
  <span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">restore</span> <span class="p">(</span><span class="n">io</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">evaluate</span><span class="p">)</span> <span class="p">`</span><span class="n">onException</span><span class="p">`</span> <span class="n">putMVar</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">putMVar</span> <span class="n">m</span> <span class="n">a&#39;</span>
  <span class="n">return</span> <span class="n">b</span>
</pre></div>
</div>
<p>]</p>
</section>
<section id="id10">
<h3>查看线程状态<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>我们编写的 <code class="docutils literal notranslate"><span class="pre">getStatus</span></code> 函数用于获取某个线程的当前状态。若某线程已经不被管理（或者未被管理），它返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="nf">getStatus</span> <span class="p">(</span><span class="kt">Mgr</span> <span class="n">mgr</span><span class="p">)</span> <span class="n">tid</span> <span class="ow">=</span>
  <span class="n">modifyMVar</span> <span class="n">mgr</span> <span class="o">$</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
    <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">tid</span> <span class="n">m</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">)</span>
      <span class="kt">Just</span> <span class="n">st</span> <span class="ow">-&gt;</span> <span class="n">tryTakeMVar</span> <span class="n">st</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">mst</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">mst</span> <span class="kr">of</span>
                   <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">Just</span> <span class="kt">Running</span><span class="p">)</span>
                   <span class="kt">Just</span> <span class="n">sth</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">delete</span> <span class="n">tid</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Just</span> <span class="n">sth</span><span class="p">)</span>
</pre></div>
</div>
<p>若线程仍在运行，它返回 <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">Running</span></code> 。 否则，它指出将线程为何被终止，并停止管理这个线程。</p>
<p>若 <code class="docutils literal notranslate"><span class="pre">tryTakeMVar</span></code> 函数发现 MVar 为空，它将立即返回 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 而非阻塞等待。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">tryTakeMVar</span>
<span class="nf">tryTakeMVar</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>否则，它将从 MVar 取到一个值。</p>
<p><code class="docutils literal notranslate"><span class="pre">waitFor</span></code> 函数的行为较简单，其会阻塞等待给定线程终止，而非立即返回。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="nf">waitFor</span> <span class="p">(</span><span class="kt">Mgr</span> <span class="n">mgr</span><span class="p">)</span> <span class="n">tid</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">maybeDone</span> <span class="ow">&lt;-</span> <span class="n">modifyMVar</span> <span class="n">mgr</span> <span class="o">$</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">updateLookupWithKey</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">tid</span> <span class="n">m</span> <span class="kr">of</span>
      <span class="p">(</span><span class="kt">Nothing</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">)</span>
      <span class="p">(</span><span class="n">done</span><span class="p">,</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">m&#39;</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
  <span class="kr">case</span> <span class="n">maybeDone</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="kt">Nothing</span>
    <span class="kt">Just</span> <span class="n">st</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">takeMVar</span> <span class="n">st</span>
</pre></div>
</div>
<p>首先读取保存线程状态的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，若其存在。 <code class="docutils literal notranslate"><span class="pre">Map</span></code> 类型的 <code class="docutils literal notranslate"><span class="pre">updateLookupWithKey</span></code> 函数很有用：它将查找某个值与更新或移除组合起来。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">updateLookupWithKey</span>
<span class="nf">updateLookupWithKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span>
                       <span class="p">(</span><span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>在此处，我们希望若保存线程状态的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 存在，则将其从 Map 中移除，这样线线程管理器将不在管理这个线程。若从其中取到了值，则从中取出线程的退出状态，并将其返回。</p>
<p>我们的最后一个实用函数简单的等待所有当前被管理的线程完成，且忽略他们的退出状态。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="nf">waitAll</span> <span class="p">(</span><span class="kt">Mgr</span> <span class="n">mgr</span><span class="p">)</span> <span class="ow">=</span> <span class="n">modifyMVar</span> <span class="n">mgr</span> <span class="n">elems</span> <span class="o">&gt;&gt;=</span> <span class="n">mapM_</span> <span class="n">takeMVar</span>
    <span class="kr">where</span> <span class="n">elems</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="kt">M</span><span class="o">.</span><span class="n">elems</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：注意 <code class="docutils literal notranslate"><span class="pre">waitAll</span></code> 函数其实是有缺陷的，它仅仅能够等待在执行 <code class="docutils literal notranslate"><span class="pre">waitAll</span></code> 之前创建的所有线程。如果在等待期间存在某个线程异步启动， <code class="docutils literal notranslate"><span class="pre">waitAll</span></code> 是无法获知其状态的。</p>
<p>至此，这个简单的 <code class="docutils literal notranslate"><span class="pre">ThreadManager</span></code> 基本可以运行了，你可以在 GHCI 中通过如下方式检测一下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">NiceFork</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">NiceFork</span>         <span class="p">(</span> <span class="kt">NiceFork</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">NiceFork</span><span class="o">.</span>
<span class="o">*</span><span class="kt">NiceFork</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">calc</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">calc</span><span class="p">;</span> <span class="n">return</span> <span class="nb">()</span><span class="p">}</span>
<span class="o">*</span><span class="kt">NiceFork</span><span class="o">&gt;</span> <span class="n">manager</span> <span class="ow">&lt;-</span> <span class="n">newManager</span>
<span class="o">*</span><span class="kt">NiceFork</span><span class="o">&gt;</span> <span class="n">tid</span> <span class="ow">&lt;-</span> <span class="n">forkManaged</span> <span class="n">manager</span> <span class="n">calc</span>
<span class="o">*</span><span class="kt">NiceFork</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="ow">&lt;-</span> <span class="n">getStatus</span> <span class="n">manager</span> <span class="n">tid</span>
<span class="o">*</span><span class="kt">NiceFork</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span>
<span class="o">*</span><span class="kt">NiceFork</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">fromJust</span> <span class="n">ans</span>
<span class="kt">Threw</span> <span class="n">stack</span> <span class="n">overflow</span>
</pre></div>
</div>
<p>我们通过一个反复调用自身的 <code class="docutils literal notranslate"><span class="pre">calc</span></code> 函数构造栈溢出，线程管理器成功地返回了这一结果。</p>
<p>]</p>
</section>
<section id="id11">
<h3>编写更紧凑的代码<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>我们在上面定义的 <code class="docutils literal notranslate"><span class="pre">waitFor</span></code> 函数有点不完善，因为或多或少执行了重复的模式分析：在 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 内部的回调函数，以及处理其返回值时。</p>
<p>当然，我们可以用一个函数消除这种重复。这是 <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> 模块中的 join 函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">join</span>
<span class="nf">join</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>这是个有趣的主意：可以创建一个 monadic 函数或纯代码中的 action ，然后一直带着它直到最终某处有个 monad 可以使用它。一旦我们了解这种写法适用的场景，就可以更灵活的编写代码。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NiceFork.hs</span>
<span class="nf">waitFor2</span> <span class="p">(</span><span class="kt">Mgr</span> <span class="n">mgr</span><span class="p">)</span> <span class="n">tid</span> <span class="ow">=</span>
  <span class="n">join</span> <span class="o">.</span> <span class="n">modifyMVar</span> <span class="n">mgr</span> <span class="o">$</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">updateLookupWithKey</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">tid</span> <span class="n">m</span> <span class="kr">of</span>
      <span class="p">(</span><span class="kt">Nothing</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">return</span> <span class="kt">Nothing</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">Just</span> <span class="n">st</span><span class="p">,</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">m&#39;</span><span class="p">,</span> <span class="kt">Just</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">takeMVar</span> <span class="n">st</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h2>使用频道通信<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>对于线程间的一次性通信， <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 已经足够好了。另一个类型， <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 提供了单向通信频道。此处有一个使用它的简单例子。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Chan.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent.Chan</span>

<span class="nf">chanExample</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ch</span> <span class="ow">&lt;-</span> <span class="n">newChan</span>
  <span class="n">forkIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">writeChan</span> <span class="n">ch</span> <span class="s">&quot;hello world&quot;</span>
    <span class="n">writeChan</span> <span class="n">ch</span> <span class="s">&quot;now i quit&quot;</span>
  <span class="n">readChan</span> <span class="n">ch</span> <span class="o">&gt;&gt;=</span> <span class="n">print</span>
  <span class="n">readChan</span> <span class="n">ch</span> <span class="o">&gt;&gt;=</span> <span class="n">print</span>
</pre></div>
</div>
<p>若一个 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 未空， <code class="docutils literal notranslate"><span class="pre">readChan</span></code> 将一直阻塞，直到读到一个值。 <code class="docutils literal notranslate"><span class="pre">writeChan</span></code> 函数从不阻塞：它会立即将一个值写入 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 。</p>
</section>
<section id="id13">
<h2>注意事项<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<section id="mvar-chan">
<h3>MVar 和 Chan 是非严格的<a class="headerlink" href="#mvar-chan" title="Permalink to this headline">¶</a></h3>
<p>正如大多数 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 容器类型， <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Char</span></code> 都是非严格的：从不对其内容求值。我们提到它，并非因为这是一个问题，而是因为这通常是一个盲点：人们倾向于假设这些类型是严格的，这大概是因为它们被用在 <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">monad</span></code> 中。</p>
<p>正如其他容器类型，误认为 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 是严格的会导致空间和性能的泄漏。考虑一下这个很可能发生的情况：</p>
<p>我们分离一个线程以在另一个核上执行一些开销较大的计算</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Expensive.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span>

<span class="nf">notQuiteRight</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">mv</span> <span class="ow">&lt;-</span> <span class="n">newEmptyMVar</span>
  <span class="n">forkIO</span> <span class="o">$</span> <span class="n">expensiveComputation_stricter</span> <span class="n">mv</span>
  <span class="n">someOtherActivity</span>
  <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">mv</span>
  <span class="n">print</span> <span class="n">result</span>
</pre></div>
</div>
<p>它看上去做了一些事情并将结果存入 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Expensive.hs</span>
<span class="nf">expensiveComputation</span> <span class="n">mv</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="s">&quot;this is &quot;</span>
      <span class="n">b</span> <span class="ow">=</span> <span class="s">&quot;not really &quot;</span>
      <span class="n">c</span> <span class="ow">=</span> <span class="s">&quot;all that expensive&quot;</span>
  <span class="n">putMVar</span> <span class="n">mv</span> <span class="p">(</span><span class="n">a</span> <span class="o">++</span> <span class="n">b</span> <span class="o">++</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们在父线程中从 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 获取结果并尝试用它做些事情时，我们的线程开始疯狂的计算，因为我们从未强制指定在其他线程中的计算真正发生。</p>
<p>照旧，一旦我们知道了有个潜在问题，解决方案就很简单：未分离的线程添加严格性，以确保计算确实发生。这个严格性最好加在一个位置，以避免我们忘记添加过它。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ModifyMVarStrict.hs</span>
<span class="cm">{-# LANGUAGE BangPatterns #-}</span>

<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="kt">MVar</span><span class="p">,</span> <span class="nf">putMVar</span><span class="p">,</span> <span class="nf">takeMVar</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">block</span><span class="p">,</span> <span class="nf">catch</span><span class="p">,</span> <span class="nf">throw</span><span class="p">,</span> <span class="nf">unblock</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">catch</span><span class="p">)</span> <span class="c1">-- 使用 Control.Exception&#39;s 中的 catch 而非 Prelude 中的。</span>

<span class="nf">modifyMVar_strict</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">modifyMVar_strict</span> <span class="n">m</span> <span class="n">io</span> <span class="ow">=</span> <span class="n">block</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">m</span>
  <span class="o">!</span><span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">unblock</span> <span class="p">(</span><span class="n">io</span> <span class="n">a</span><span class="p">)</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span>
        <span class="n">putMVar</span> <span class="n">m</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">throw</span> <span class="n">e</span>
  <span class="n">putMVar</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>[Forec 译注：<code class="docutils literal notranslate"><span class="pre">block</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unblock</span></code> 不被建议使用，更好的方式是使用 <code class="docutils literal notranslate"><span class="pre">mask</span></code> 。此外，上面的模式匹配仅仅将表达式求值为 WHNF（弱首范式），关于
弱首范式的内容将在本章后半部分讨论。你暂时可以简单地将其理解为 “剥去表达式的一层”，例如 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> 将被求值为 3，而 <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span> <span class="pre">++</span> <span class="pre">&quot;bc&quot;</span></code> 则仅仅被求值为
<code class="docutils literal notranslate"><span class="pre">('a':</span> <span class="pre">(&quot;b&quot;</span> <span class="pre">++</span> <span class="pre">&quot;bc&quot;))</span></code>。所以这里代码的 “严格” 是有缺陷的。
一个可行但不太符合工程应用的做法是使用 <code class="docutils literal notranslate"><span class="pre">Control.DeepSeq</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 方法，该方法将表达式求值为范式。建议将原著代码修改如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ModifyMVarStrict.hs</span>
<span class="cm">{-# LANGUAGE BangPatterns #-}</span>

<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="kt">MVar</span><span class="p">,</span> <span class="nf">putMVar</span><span class="p">,</span> <span class="nf">takeMVar</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">catch</span><span class="p">,</span> <span class="nf">throw</span><span class="p">,</span> <span class="nf">mask</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">catch</span><span class="p">)</span>

<span class="nf">modifyMVar_strict</span> <span class="ow">::</span> <span class="kt">MVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">modifyMVar_strict</span> <span class="n">m</span> <span class="n">io</span> <span class="ow">=</span> <span class="n">mask</span> <span class="o">$</span> <span class="nf">\</span><span class="n">restore</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">takeMVar</span> <span class="n">m</span>
  <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">restore</span> <span class="p">(</span><span class="n">io</span> <span class="n">a</span><span class="p">)</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span>
        <span class="n">putMVar</span> <span class="n">m</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">throw</span> <span class="n">e</span>
<span class="nf">rnf</span> <span class="n">b</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">putMVar</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>]</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>查看 <code class="docutils literal notranslate"><span class="pre">Hackage</span></code> 始终是值得的。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Hackage</span></code> 包数据库，你将发现一个库，<code class="docutils literal notranslate"><span class="pre">strict-concurrency</span></code> ，它提供了严格版本的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 类型</p>
</div>
<p>上面代码中的 <code class="docutils literal notranslate"><span class="pre">!</span></code> 模式用起来很简单，但是并不总是足以确保我们的数据已经被求值。更完整的方法，请查看下面的段落“从求值中分离算法”。</p>
</section>
<section id="chan">
<h3>Chan 是无边界的<a class="headerlink" href="#chan" title="Permalink to this headline">¶</a></h3>
<p>因为 <code class="docutils literal notranslate"><span class="pre">writeChan</span></code> 总是立即成功，所以在使用 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 时有潜在风险。若对某个 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 的写入多于其读取， <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 将用不检查的方法增长：对未读消息的读取将远远落后于其增长。</p>
</section>
</section>
<section id="id14">
<h2>共享状态的并发仍不容易<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>尽管 Haskell 拥有与其他语言不同的基础设施用于线程间共享数据，它仍需克服相同的基本问题：编写正确的并发程序极端困难。真的，一些其他语言中的并发编程陷阱也会在 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 中出现。其中为人熟知的两个是死锁和饥饿。</p>
<section id="id15">
<h3>死锁<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>死锁的情况下，两个或多个线程永远卡在争抢共享资源的访问权上。制造多线程程序死锁的一个经典方法是不按顺序加锁。这种类型的 bug 很常见，它有个名字：锁顺序倒置。 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 没有提供锁， 但 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 类型可能会有顺序倒置问题。这有一个简单例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/LockHierarchy.hs</span>
<span class="kr">import</span> <span class="nn">Control.Concurrent</span>

<span class="nf">nestedModification</span> <span class="n">outer</span> <span class="n">inner</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">modifyMVar_</span> <span class="n">outer</span> <span class="o">$</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">yield</span> <span class="c1">-- 强制当前线程让出 CPU</span>
        <span class="n">modifyMVar_</span> <span class="n">inner</span> <span class="o">$</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">putStrLn</span> <span class="s">&quot;done&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">newMVar</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">newMVar</span> <span class="mi">2</span>
    <span class="n">forkIO</span> <span class="o">$</span> <span class="n">nestedModification</span> <span class="n">a</span> <span class="n">b</span>
    <span class="n">forkIO</span> <span class="o">$</span> <span class="n">nestedModification</span> <span class="n">b</span> <span class="n">a</span>
</pre></div>
</div>
<p>在 ghci 中运行这段程序，它通常会（但不总是）不打印任何信息，表明两个线程已经卡住了。</p>
<p>容易看出 <code class="docutils literal notranslate"><span class="pre">nestedModification</span></code> 函数的问题。在第一个线程中，我们先取出 <code class="docutils literal notranslate"><span class="pre">MVar</span> <span class="pre">a</span></code> ，接着取出 <code class="docutils literal notranslate"><span class="pre">b</span></code> 。在第二个线程中，先取出 <code class="docutils literal notranslate"><span class="pre">b</span></code> 然后取出 <code class="docutils literal notranslate"><span class="pre">a</span></code> ，若第一个线程成功取出了 <code class="docutils literal notranslate"><span class="pre">a</span></code> 然后要取出 <code class="docutils literal notranslate"><span class="pre">b</span></code> ，这是两个线程都会阻塞：每个线程都尝试获取一个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，而这个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 已经被另一个线程取空了，所以二者都不能完成整个流程。</p>
<p>无论何种语言，通常解决倒序问题的方法是申请资源时一直遵循一致的顺序。因为这需要人工遵循编码规范，在实践中很容易遗忘。</p>
<p>更麻烦的是，这种倒序问题在实际代码中很难被发现。获取 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 的动作经常跨越不同文件中的不同函数，这使得通过观察源码检查时更加棘手。更糟糕的是，这类问题通常是间歇性的，这使得它们难于重现，更不要说隔离和修复了。</p>
</section>
<section id="id16">
<h3>饥饿<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>并发软件通常可能会导致饥饿问题，某个线程霸占了共享资源，阻止其他线程使用。很容易想象这是如何发生的：一个线程调用 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 执行一个 100 毫秒的代码段，稍后另外一个线程对同一个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">modifyMVar</span></code> 执行一个 1 毫秒的代码段。第二个线程在第一个线程完成前将无法执行。</p>
<p><code class="docutils literal notranslate"><span class="pre">MVar</span></code> 类型的非严格性质使会导致或恶化饥饿的问题。若我们将一个求值开销很大的 <code class="docutils literal notranslate"><span class="pre">thunk</span></code> 写入一个 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> ，在一个看上去开销较小的线程中取出并求值，这个线程的执行开销马上会变大。所以我们在 “MVar 和 Chan 是非严格的” 一章中特地给出了一些建议。</p>
</section>
<section id="id17">
<h3>没希望了吗？<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>幸运的是，我们已经提及的并发 <code class="docutils literal notranslate"><span class="pre">API</span></code> 并不是故事的全部。最近加入 Haskell 中的一个设施，软件事务内存，使用起来更加容易和安全。我们将在第 28 章，软件事务内存中介绍。</p>
</section>
</section>
<section id="id18">
<h2>练习<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Chan</span></code> 类型是使用 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 实现的。使用 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 来开发一个有边界的 <code class="docutils literal notranslate"><span class="pre">Chan</span></code> 库。</p></li>
<li><p>你开发的 newBoundedChanfunction 接受一个 <code class="docutils literal notranslate"><span class="pre">Int</span></code> 参数，限制单独 <code class="docutils literal notranslate"><span class="pre">BoundedChan</span></code> 中的未读消息数量。</p></li>
<li><p>达到限制是， 调用 <code class="docutils literal notranslate"><span class="pre">writeBoundedChanfunction</span></code> 要被阻塞，知道某个读取者使用 <code class="docutils literal notranslate"><span class="pre">readBoundedChan</span></code> 函数消费掉队列中的一个值。</p></li>
<li><p>尽管我们已经提到过 Hackage 库中的 <code class="docutils literal notranslate"><span class="pre">strict-concurrency</span></code> 包，试着自己开发一个，作为内置 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 类型的包装。按照经典的 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 实践，使你的库类型安全，让用户不会混淆严格和非严格的 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 。</p></li>
</ol>
</section>
<section id="ghc">
<h2>在 GHC 中使用多核<a class="headerlink" href="#ghc" title="Permalink to this headline">¶</a></h2>
<p>默认情况下， <code class="docutils literal notranslate"><span class="pre">GHC</span></code> 生成的程序只使用一个核，甚至在编写并发代码时也是如此。要使用多核，我们必须明确指定。当生成可执行程序时，要在链接阶段指定这一点。</p>
<blockquote>
<div><ul class="simple">
<li><p>“non-threaded” 运行时库在一个操作系统线程中运行所有 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 线程。这个运行时在创建线程和通过 MVar 传递数据时很高效。</p></li>
<li><p>“threaded” 库使用多个操作系统线程运行 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 线程。它在创建线程和使用 <code class="docutils literal notranslate"><span class="pre">MVar</span></code> 时具有更高的开销。</p></li>
</ul>
</div></blockquote>
<p>若我们在向编译器传递 <code class="docutils literal notranslate"><span class="pre">-threadedoption</span></code> 参数，它将使用 <code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时库链接我们的程序。在编译库和源码文件时无需指定 <code class="docutils literal notranslate"><span class="pre">-threaded</span></code> ，只是在最终生成可执行文件时需要指定。</p>
<p>即使为程序指定了 <code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时，默认情况下它仍将只使用一个核运行。必须明确告诉运行时使用多少个核。</p>
<section id="id19">
<h3>运行时选项<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>运行程序时可以向 GHC 的运行时系统传递命令行参数。在将控制权交给我们的代码前，运行时扫描程序的参数，看是否有命令行选项 <code class="docutils literal notranslate"><span class="pre">+RTS</span></code> 。其后跟随的所有选项都被运行时解释，直到特殊的选项 <code class="docutils literal notranslate"><span class="pre">-RTS</span></code> ，这些选项都是提供给运行时系统的，不为我们的程序。运行时会对我们的代码隐藏所有这些选项。当我们使用 <code class="docutils literal notranslate"><span class="pre">System.Environment</span></code> 模块的 <code class="docutils literal notranslate"><span class="pre">getArgsfunction</span></code> 来获得我们的命令行参数是，我们不会在其中获得运行时选项。</p>
<p><code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时接受参数 <code class="docutils literal notranslate"><span class="pre">-N</span></code> <a class="footnote-reference brackets" href="#id40" id="id20">55</a> 。 其接受一个参数，指定了 <code class="docutils literal notranslate"><span class="pre">GHC</span></code> 的运行时系统将使用的核数。这个选项对输入很挑剔： <code class="docutils literal notranslate"><span class="pre">-N</span></code> 和参数之间必须没有空格。 <code class="docutils literal notranslate"><span class="pre">-N4</span></code> 可被接受， <code class="docutils literal notranslate"><span class="pre">-N</span> <span class="pre">4</span></code> 则不被接受。</p>
</section>
<section id="haskell">
<h3>找出 Haskell 可以使用多少核<a class="headerlink" href="#haskell" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">GHC.Conc</span></code> 模块输出一个变量， <code class="docutils literal notranslate"><span class="pre">numCapabilities</span></code> ，它会告诉我们运行时系统被 <code class="docutils literal notranslate"><span class="pre">-NRTS</span></code> 选项指定了多少核。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/NumCapabilities.hs</span>
<span class="kr">import</span> <span class="nn">GHC.Conc</span> <span class="p">(</span><span class="nf">numCapabilities</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;command line arguments: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">args</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;number of cores: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">numCapabilitie</span>
</pre></div>
</div>
<p>若编译上面的程序，我们可以看到运行时系统的选项对于程序来说是不可见的，但是它可以看其运行在多少核上。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="n">c</span> <span class="kt">NumCapabilities</span><span class="o">.</span><span class="n">hs</span>
<span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="n">threaded</span> <span class="o">-</span><span class="n">o</span> <span class="kt">NumCapabilities</span> <span class="kt">NumCapabilities</span><span class="o">.</span><span class="n">o</span> <span class="o">$</span> <span class="o">./</span><span class="kt">NumCapabilities</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N4</span> <span class="o">-</span><span class="kt">RTS</span> <span class="n">foo</span>
<span class="nf">command</span> <span class="n">line</span> <span class="n">arguments</span><span class="kt">:</span> <span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">]</span>
<span class="nf">number</span> <span class="kr">of</span> <span class="n">cores</span><span class="kt">:</span> <span class="mi">4</span>
</pre></div>
</div>
</section>
<section id="id21">
<h3>选择正确的运行时<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>选择正确的运行时需要花点心思。 <code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时可以使用多核，但是也有相应的代价：线程间共享数据的成本比 <code class="docutils literal notranslate"><span class="pre">non-threaded</span></code> 运行时更大。</p>
<p>更关键的是，GHC 6.8.3 版本使用的还是单线程的垃圾收集器：它在执行时会暂停其他所有线程，然后在单个核上执行垃圾收集工作。这限制了我们在使用多核的时候希望看到的性能改进 <a class="footnote-reference brackets" href="#id41" id="id22">56</a> 。</p>
<p>很多真实世界中的并发程序中，一个单独的线程多数时间实在等待一个网络请求或响应。这些情况下，若以一个单独的 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 程序为数万并发客户端提供服务，使用低开销的 <code class="docutils literal notranslate"><span class="pre">non-threaded</span></code> 运行时很可能是合适的。例如，与其用 4 个核跑 threaded 运行时的单个服务器程序，可能同时跑 4 个 non-threaded 运行时的相同服务器程序性能更好。</p>
<p>我们的目的并不是阻止你使用 <code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时。相对于 <code class="docutils literal notranslate"><span class="pre">non-threaded</span></code> 运行时它并没有特别大的开销：相对于其他编程语言，线程依旧惊人的轻量。我们仅是希望说明 <code class="docutils literal notranslate"><span class="pre">threaded</span></code> 运行时并不是在所有场景都是最佳选择。</p>
</section>
</section>
<section id="id23">
<h2>Haskell 中的并行编程<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>现在让我们来关注一下并行编程。对很多计算密集型问题，可以通过分解问题，并在多个核上求值来更快的计算出结果。多核计算机已经普及，甚至在最新的笔记本上都有，但是很少有程序可以利用这一优势。</p>
<p>大部分原因是因为传统观念认为并行编程非常困难。在一门典型的编程语言中，我们将用处理并发程序相同的库和设施处理并发程序。这是我们的注意力集中在处理一些熟悉的问题比如死锁、竞争条件、饥饿和陡峭的复杂性。</p>
<p>但是我们可以确定，使用 <code class="docutils literal notranslate"><span class="pre">Haskell</span></code> 的并发特性开发并行代码时，有许多更简单的方法。在一个普通的 Haskell 函数上稍加变化，就可以并行求值。</p>
<section id="id24">
<h3>范式和首范式<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">seq</span></code> 函数将一个表达式求值为首范式（简称 HNF）。<code class="docutils literal notranslate"><span class="pre">seq</span></code> 一旦到达最外层的构造函数（也就是 “首部”）就会停止，这与范式不同（NF），
被称作范式的表达式必然是被完全求值的，而非仅仅 “剥离” 掉最外层的构造函数。</p>
<p>你可能会经常听到 Haskell 程序员提到弱首范式（WHNF）。对一般数据来说，弱首范式和首范式相同。它们仅仅在功能上有些许区别，
这里我们就不过多关注了。</p>
<p>[
Forec 译注：读者只需要记住范式和弱首范式这两个概念的区别，HNF 几乎可以忽略。以下两个链接可以帮助更好的理解，
这部分内容与并行编程关系不是非常紧密，因此不在此处过多叙述：
* Haskell Wiki: <a class="reference external" href="https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form">https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form</a>
* StackOverflow: <a class="reference external" href="http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form">http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form</a>
]</p>
</section>
<section id="id25">
<h3>排序<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>这是一个使用分治算法实现的 Haskell 排序函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Sorting.hs</span>
<span class="nf">sort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="kt">:</span><span class="n">greater</span>
  <span class="kr">where</span> <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">sort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">sort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="nf">sort</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sort</span></code> 函数实现了著名的快速排序算法，很多 Haskell 程序员将其视作经典：
在早期的 Haskell 教程中，用一行代码实现的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 经常作为示例向读者展示 Haskell 强大的表达能力。
这里我们将代码切分为几行以方便比较串行和并行版本。</p>
<p>下面是对 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 工作流程的简要介绍：</p>
<ol class="arabic simple">
<li><p>从列表中取出一个元素，这个元素被称为 “轴心”（或哨兵）。每个元素都要和轴心比较。上面的代码简单地通过模式匹配选取列表的第一个元素作为轴心；</p></li>
<li><p>使用原始列表中除轴心外的其它元素构造一个子列表，子列表中元素的值全部小于轴心，并递归地处理子列表；</p></li>
<li><p>与 2 类似，构造另一个子列表，但子列表中元素的值均大于或等于轴心的值，递归处理这个子列表；</p></li>
<li><p>将 2、3 两步中排序后的子列表通过轴心进行连接。</p></li>
</ol>
</section>
<section id="id26">
<h3>将代码变换为并行版本<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>并行版本的排序函数相对要复杂一些：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Sorting.hs</span>
<span class="kr">module</span> <span class="nn">Sorting</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Parallel</span> <span class="p">(</span><span class="nf">par</span><span class="p">,</span> <span class="nf">pseq</span><span class="p">)</span>

<span class="nf">parSort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parSort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>    <span class="ow">=</span> <span class="n">force</span> <span class="n">greater</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">force</span> <span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="kt">:</span><span class="n">greater</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">parSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">parSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="nf">parSort</span> <span class="kr">_</span>         <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>不过我们并没有改变代码的结构。<code class="docutils literal notranslate"><span class="pre">parSort</span></code> 仅仅多使用了三个函数： <code class="docutils literal notranslate"><span class="pre">par</span></code>、<code class="docutils literal notranslate"><span class="pre">pseq</span></code> 和 <code class="docutils literal notranslate"><span class="pre">force</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">par</span></code> 函数由 <code class="docutils literal notranslate"><span class="pre">Control.Parallel</span></code> 模块提供。它与 <code class="docutils literal notranslate"><span class="pre">seq</span></code> 目的类似：将左侧参数求值为弱首范式并返回右侧参数。
<code class="docutils literal notranslate"><span class="pre">par</span></code> 的名字很好地阐述了它的功能：<code class="docutils literal notranslate"><span class="pre">par</span></code> 能够在其它运算执行的同时并行地对其左侧参数求值。</p>
<p><code class="docutils literal notranslate"><span class="pre">pseq</span></code> 也和 <code class="docutils literal notranslate"><span class="pre">seq</span></code> 类似：它在返回右侧表达式之前将左侧表达式求值为弱首范式。这二者之间的区别很微妙，
但对于并行编程而言非常重要：编译器不保证 <code class="docutils literal notranslate"><span class="pre">seq</span></code> 的求值顺序，即如果编译器认为首先对右侧参数求值能够提高性能，则
它将先计算右侧参数。对于单核执行的程序来说，这种灵活性很有必要，但对多核代码而言不够健壮。
相比之下，编译器能够保证 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 左侧参数的求值过程早于右侧参数。</p>
<p>以上修改将对一些我们没有提到的方面产生巨大的影响，比如说：</p>
<ul class="simple">
<li><p>使用多少个核心</p></li>
<li><p>线程间如何通信</p></li>
<li><p>如何将工作分配给多个可用核心</p></li>
<li><p>明确哪些数据将在线程间共享，哪些属于线程私有</p></li>
<li><p>如何确定所有任务均已完成</p></li>
</ul>
</section>
<section id="id27">
<h3>明确在并行中执行什么<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>并行的 Haskell 代码之所以能够表现出更优秀的性能，是因为计算过程中有大量重复、独立、可并行计算的工作。
非严格求值会阻碍并行程序的执行，因此我们会在并行代码中使用 <code class="docutils literal notranslate"><span class="pre">force</span></code> 函数。下面通过一个错误的例子解释 <code class="docutils literal notranslate"><span class="pre">force</span></code> 函数的功能：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Sorting.hs</span>
<span class="nf">sillySort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">greater</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="kt">:</span><span class="n">greater</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">lesser</span>   <span class="ow">=</span> <span class="n">sillySort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
        <span class="n">greater</span>  <span class="ow">=</span> <span class="n">sillySort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="nf">sillySort</span> <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>注意，我们在 <code class="docutils literal notranslate"><span class="pre">par</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 两处用普通求值取代了 <code class="docutils literal notranslate"><span class="pre">force</span> <span class="pre">lesser</span></code> 和 <code class="docutils literal notranslate"><span class="pre">force</span> <span class="pre">greater</span></code>。</p>
<p>回忆一下，对弱首范式的求值会在 “看到” 表达式的外部构造器时停止。在错误的例子中，我们将每个有序的子列表求值为 WHNF。
因为最外层的构造器仅仅是一个列表构造器，上面的代码实际上仅仅强制对每个排序子列表的第一个元素做了求值，
每个排序子列表剩余的元素仍未被完全求值。换句话说，上面代码在并行部分执行时几乎没有做任何有效计算，
<code class="docutils literal notranslate"><span class="pre">sillySort</span></code> 的执行过程和完全顺序的代码没什么差别。</p>
<p>[Forec 译注：考虑此前译注给出的例子，<code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span> <span class="pre">++</span> <span class="pre">&quot;bc&quot;</span></code> 的弱首范式仅仅是 <code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">:</span> <span class="pre">(&quot;b&quot;</span> <span class="pre">++</span> <span class="pre">&quot;bc&quot;)</span></code>。
以待排序列表 <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">2,</span> <span class="pre">5,</span> <span class="pre">1,</span> <span class="pre">3]</span></code> 为例，<code class="docutils literal notranslate"><span class="pre">sillySort</span></code> 试图在 <code class="docutils literal notranslate"><span class="pre">par</span></code> 包装的并行操作中计算出排序好的两个子列表。
假设轴心元素为 3，则小于轴心的待排序子列表应为 <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">1]</span></code>，而 <code class="docutils literal notranslate"><span class="pre">par</span></code> 中的并行操作在计算出第一个满足条件的
元素 2 后，得到 <code class="docutils literal notranslate"><span class="pre">lesser</span> <span class="pre">=</span> <span class="pre">(2:</span> <span class="pre">_)</span></code>，已经遇到了最外层的列表构造器，因此停止计算。
真正求出完整待排序子列表是在后续顺序操作 <code class="docutils literal notranslate"><span class="pre">++</span></code> 时，因为需要列表中所有元素，这时程序才开始计算。</p>
<p>这里给出一个译者认为更容易理解弱首范式的例子：在 GHCI 中执行如下指令。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">list</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">whnfList</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">list</span>
<span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">whnfList</span>
<span class="nf">whnfList</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="o">&gt;</span> <span class="n">length</span> <span class="n">whnfList</span>
<span class="mi">10</span>
<span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">whnfList</span>
<span class="nf">whnfList</span> <span class="ow">=</span> <span class="p">[</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">]</span>
</pre></div>
</div>
<p>可以看出，<code class="docutils literal notranslate"><span class="pre">length</span></code> 操作仅需要 <code class="docutils literal notranslate"><span class="pre">whnfList</span></code> 中元素的数量，并没有对其中元素进行更深层次的求值。</p>
<p>]</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">force</span></code> 函数，在构造函数返回前遍历整个列表以避免这种情况出现。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Sorting.hs</span>
<span class="nf">force</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">force</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">xs</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="nb">()</span>
  <span class="kr">where</span> <span class="n">go</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">xs</span>
        <span class="n">go</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>注意，我们并不在乎列表中具体有什么，而是仅仅把列表遍历一遍，遍历之后再调用 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 。
因为我们会在 <code class="docutils literal notranslate"><span class="pre">par</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 的左侧使用 <code class="docutils literal notranslate"><span class="pre">force</span></code>，所以返回值无所谓。</p>
<p>当然，很多情况下我们会需要对列表中的个别元素强制求值。下面会介绍一个基于类型类的解决方案。</p>
</section>
<section id="par">
<h3>par 提供什么保证？<a class="headerlink" href="#par" title="Permalink to this headline">¶</a></h3>
<p>实际上，<code class="docutils literal notranslate"><span class="pre">par</span></code> 函数并不保证会将表达式并行求值，它只在对表达式并行求值有意义的时候才这么做。
在并行编程中，这种行为比保证并行执行更有效。它允许运行时系统遇到 <code class="docutils literal notranslate"><span class="pre">par</span></code> 时智能调度。</p>
<p>举个例子，运行时系统可能发现表达式过于简单，并行求值带来的性能提升远低于并行操作本身的额外开销。
或者，运行时系统发现所有的计算核心均正在工作，而启动一个新的并行运算仅仅会增加待运行线程的数量。</p>
<p>这个潜规则影响了我们如何编写并行代码。假设系统性能不会因为线程间争夺核心资源下降，
考虑到 par 在运行时可以智能调度，我们就可以将它应用到任何想应用的地方。</p>
</section>
<section id="id28">
<h3>运行并测试性能<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>将 <code class="docutils literal notranslate"><span class="pre">sort</span></code>、<code class="docutils literal notranslate"><span class="pre">parSort</span></code> 和 <code class="docutils literal notranslate"><span class="pre">parSort2</span></code> 保存到 <code class="docutils literal notranslate"><span class="pre">Sorting.hs</span></code> 中并封装为 <code class="docutils literal notranslate"><span class="pre">Sorting</span></code> 模块。
我们创建一个驱动程序以计算这些排序函数的性能：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/SortMain.hs</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Time.Clock</span> <span class="p">(</span><span class="nf">diffUTCTime</span><span class="p">,</span> <span class="nf">getCurrentTime</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Random</span> <span class="p">(</span><span class="kt">StdGen</span><span class="p">,</span> <span class="nf">getStdGen</span><span class="p">,</span> <span class="nf">randoms</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Sorting</span>

<span class="c1">-- testFunction = sort</span>
<span class="c1">-- testFunction = seqSort</span>
<span class="nf">testFunction</span> <span class="ow">=</span> <span class="n">parSort</span>
<span class="c1">-- testFunction = parSort2 2</span>

<span class="nf">randomInts</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">randomInts</span> <span class="n">k</span> <span class="n">g</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">k</span> <span class="p">(</span><span class="n">randoms</span> <span class="n">g</span><span class="p">)</span>
         <span class="kr">in</span> <span class="n">force</span> <span class="n">result</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">result</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
  <span class="kr">let</span> <span class="n">count</span> <span class="o">|</span> <span class="n">null</span> <span class="n">args</span> <span class="ow">=</span> <span class="mi">500000</span>
            <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">read</span> <span class="p">(</span><span class="n">head</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">randomInts</span> <span class="n">count</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">getStdGen</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;We have &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="n">input</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; elements to sort.&quot;</span>
  <span class="n">start</span> <span class="ow">&lt;-</span> <span class="n">getCurrentTime</span>
  <span class="kr">let</span> <span class="n">sorted</span> <span class="ow">=</span> <span class="n">testFunction</span> <span class="n">input</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Sorted all &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="n">sorted</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; elements.&quot;</span>
  <span class="n">end</span> <span class="ow">&lt;-</span> <span class="n">getCurrentTime</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="p">(</span><span class="n">end</span> <span class="p">`</span><span class="n">diffUTCTime</span><span class="p">`</span> <span class="n">start</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; elapsed.&quot;</span>
</pre></div>
</div>
<p>简单起见，我们使用 <code class="docutils literal notranslate"><span class="pre">testFunction</span></code> 变量选择用于基准测试的排序函数。</p>
<p>上面的程序接受一个可选的命令行参数，用于指定待排序随机数组的长度。</p>
<p>非严格求值是性能测量和分析中要注意的 “雷区”。下面是驱动程序中特别要避免的一些潜在问题：</p>
<ul class="simple">
<li><p><em>非严格求值会使测量单一行为变为测量多个行为。</em> Haskell 默认的随机数产生器（PRNG）很慢，而且 <code class="docutils literal notranslate"><span class="pre">random</span></code> 函数仅仅在需要的时候才产生下一个随机数。我们在记录开始时间之前对输入列表的每个元素进行了强制求值，并且打印了列表的长度：这保证了程序在计算之前就已经生成了全部的随机数。如果我们忽略了这一步，则并行计算的过程会包含随机数的生成，进而导致测量出的时间变为生成随机数和数据排序所用时间之和，而非数据排序本身的耗时。</p></li>
<li><p><em>隐含的数据依赖。</em> 在产生随机数列表时，只打印列表的长度并不会对列表完全求值。<code class="docutils literal notranslate"><span class="pre">length</span></code> 函数只会遍历列表的结构而非列表内的每个元素。因此，在排序操作执行前，列表中并没有生成好的随机数。这一行为可能严重拖慢性能。每个随机数的产生都取决于列表中前一个随机数的值，但并行的数据排序已经将列表元素分散到了不同的处理器内核中。如果排序前没有对输入的随机数列表完全求值，那么运行时就会遭遇可怕的 “乒乓” 效应：计算会在核心之间不停跳跃，导致性能的迅速下降。尝试删除 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中应用在随机数列表上的 <code class="docutils literal notranslate"><span class="pre">force</span></code> ：你会发现并行代码比顺序执行的程序慢了三倍。[Forec 译注：原著作者似乎忘记在代码中使用 <code class="docutils literal notranslate"><span class="pre">force</span></code>。可以在运算开始前加入 <code class="docutils literal notranslate"><span class="pre">force</span> <span class="pre">input</span></code>。]</p></li>
<li><p><em>让我们错误地认为代码执行了有意义的工作。</em> 为了保证数据排序的执行，我们在记录结束时间之前将结果列表的长度打印到了屏幕上。如果没有 <code class="docutils literal notranslate"><span class="pre">putStrLn</span></code> 强制要求列表长度，排序压根就不会执行。</p></li>
</ul>
<p>在构建程序时开启优化和 GHC 的运行时线程支持：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="n">threaded</span> <span class="o">-</span><span class="kt">O2</span> <span class="c1">--make SortMain</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Sorting</span>          <span class="p">(</span> <span class="kt">Sorting</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">Sorting</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">SortMain</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">SortMain</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="kt">Linking</span> <span class="kt">SortMain</span> <span class="o">...</span>
</pre></div>
</div>
<p>在程序运行时告知 GHC 的运行时系统使用多少核心。首先测试最原始的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 函数，看看基础性能如何：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N1</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">3.178941</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
</pre></div>
</div>
<p>启用两个核心并不会提升顺序执行代码的性能：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N2</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">3.259869</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
</pre></div>
</div>
<p>如果重新编译，测试 <code class="docutils literal notranslate"><span class="pre">parSort</span></code> 的性能，就会发现结果还不如顺序代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N1</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">3.915818</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
<span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N2</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">4.029781</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
</pre></div>
</div>
<p>性能上没有任何提升。这看起来是以下两个原因之一造成的：要么是 <code class="docutils literal notranslate"><span class="pre">par</span></code> 本身的开销过大，
要么是我们滥用了 <code class="docutils literal notranslate"><span class="pre">par</span></code> 。为了鉴别究竟哪个才是罪魁祸首，
我们编写了一个类似 <code class="docutils literal notranslate"><span class="pre">parSort</span></code> 的函数 <code class="docutils literal notranslate"><span class="pre">seqSort</span></code>，它使用 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">par</span></code> ：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">seqSort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">seqSort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="p">(</span><span class="n">greater</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="kt">:</span><span class="n">greater</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">seqSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">seqSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="nf">seqSort</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>我们还删去了 <code class="docutils literal notranslate"><span class="pre">parSort</span></code> 中对 <code class="docutils literal notranslate"><span class="pre">force</span></code> 的调用。所以将 <code class="docutils literal notranslate"><span class="pre">seqSort</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 比较就可以观察到只应用 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 的性能：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N1</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">3.848295</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
</pre></div>
</div>
<p>上面的运行结果说明 <code class="docutils literal notranslate"><span class="pre">par</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 耗时相似。我们该如何改进性能呢？</p>
</section>
<section id="id29">
<h3>性能调优<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">parSort</span></code> 中，调用 <code class="docutils literal notranslate"><span class="pre">par</span></code> 的次数是待排序数据数量的两倍。尽管 <code class="docutils literal notranslate"><span class="pre">par</span></code> 的开销很小，但它毕竟也不是 “免费” 的。
当递归调用 <code class="docutils literal notranslate"><span class="pre">parSort</span></code> 时，我们最终将 <code class="docutils literal notranslate"><span class="pre">par</span></code> 应用到了单个元素上。在这种细微的粒度下，使用 <code class="docutils literal notranslate"><span class="pre">par</span></code> 的成本远超其带来的增益。
为了减少这种影响，我们在待排序数据数量小于某个阈值时采用非并行排序。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Sorting.hs</span>
<span class="nf">parSort2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parSort2</span> <span class="n">d</span> <span class="n">list</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span>     <span class="ow">=</span> <span class="n">sort</span> <span class="n">list</span>
  <span class="o">|</span> <span class="n">otherwise</span>  <span class="ow">=</span> <span class="n">force</span> <span class="n">greater</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">force</span> <span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="kt">:</span><span class="n">greater</span><span class="p">))</span>
    <span class="kr">where</span> <span class="n">lesser</span>      <span class="ow">=</span> <span class="n">parSort2</span> <span class="n">d&#39;</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
          <span class="n">greater</span>     <span class="ow">=</span> <span class="n">parSort2</span> <span class="n">d&#39;</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
          <span class="n">d&#39;</span> <span class="ow">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>
<span class="nf">parSort2</span> <span class="kr">_</span> <span class="kr">_</span>              <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">parSort2</span></code> 在到达可控深度时停止递归以及创建新的并行计算。如果待处理数据的规模已知，程序就能在剩余工作数量足够少的时刻停止
并行计算并切换到非并行代码。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">Sorting</span> <span class="o">+</span><span class="kt">RTS</span> <span class="o">-</span><span class="kt">N2</span> <span class="o">-</span><span class="kt">RTS</span> <span class="mi">700000</span>
<span class="kt">We</span> <span class="n">have</span> <span class="mi">700000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">sort</span><span class="o">.</span>
<span class="kt">Sorted</span> <span class="n">all</span> <span class="mi">700000</span> <span class="n">elements</span><span class="o">.</span>
<span class="mf">2.947872</span><span class="n">s</span> <span class="n">elapsed</span><span class="o">.</span>
</pre></div>
</div>
<p>在双核系统中，这一改进将运行速度提升了大约 25%。性能的提升并不高，但想想我们对代码所做的改变：几句注解而已就让速度提升了四分之一。</p>
<p>上面的排序函数难以获得良好的并行性能。它执行了大量内存分配，导致垃圾回收器频繁运行。<code class="docutils literal notranslate"><span class="pre">-sstderr</span></code>
这一 RTS 选项能够将垃圾回收统计信息打印到屏幕，反馈信息显示程序大约有 40% 的时间用于回收垃圾。
由于 GHC 6.8 中的垃圾回收器会停止所有线程并运行在单个内核上，这一点也就成为了程序的瓶颈。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">par</span></code> 应用在内存分配不频繁的代码中可能会带来明显的性能改进。我们已经看到，相比单核运算，
上面的基准测试在双核系统上能够取得 1.8 倍加速。在这本书编写时，GHC 正在开发一个并行的垃圾回收器，
届时在多核系统上执行大量内存分配的代码也能获得令人满意的性能。</p>
<p>[Forec 译注：翻译此处时 GHC 的最新版本为 8.0.2，已支持多核系统的垃圾回收。实际测试表明，
即使支持多核 GC，并行编程的主要瓶颈在很多时候还是垃圾回收。]</p>
</section>
<section id="id30">
<h3>练习<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>决定什么时候从 <code class="docutils literal notranslate"><span class="pre">parSort2</span></code> 切换到 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 不是一件容易的事。我们上面实现的方法是根据递归的深度选择，另一种方法是根据待排序子列表的长度决定。重写 <code class="docutils literal notranslate"><span class="pre">parSort2</span></code> 使其在待排序子列表长度小于某个数的时候切换到 <code class="docutils literal notranslate"><span class="pre">sort</span></code>。</p></li>
<li><p>测试基于列表长度切换的 <code class="docutils literal notranslate"><span class="pre">parSort2</span></code> 的性能，并于基于递归深度的版本比较。哪一个性能更好？</p></li>
</ol>
</section>
</section>
<section id="map-reduce">
<h2>并行策略和 Map Reduce<a class="headerlink" href="#map-reduce" title="Permalink to this headline">¶</a></h2>
<p>在编程社区中，Google 用于并行处理海量数据的 MapReduce 框架是受函数式编程启发的著名软件系统之一。</p>
<p>我们可以用 Haskell 轻松构建一个简单而实用的 “山寨版” MapReduce。我们将把重点放在 Web 服务器日志文件的处理上，这些文件通常规模较大并且包含丰富的信息 <a class="footnote-reference brackets" href="#id42" id="id31">57</a> 。</p>
<p>下面这个例子是 Apache Web 服务器记录的一条访问日志。这条日志原本是一行，这里为了阅读方便将其切分成多行。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="mf">201.49</span><span class="o">.</span><span class="mf">94.87</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">08</span><span class="o">/</span><span class="kt">Jun</span><span class="o">/</span><span class="mi">2008</span><span class="kt">:</span><span class="mi">07</span><span class="kt">:</span><span class="mi">04</span><span class="kt">:</span><span class="mi">20</span> <span class="o">-</span><span class="mi">0500</span><span class="p">]</span> <span class="s">&quot;GET / HTTP/1.1&quot;</span>
<span class="mi">200</span> <span class="mi">2097</span> <span class="s">&quot;http://en.wikipedia.org/wiki/Mercurial_(software)&quot;</span>
<span class="s">&quot;Mozilla/5.0 (Windows; U; Windows XP 5.1; en-GB; rv:1.8.1.12)</span>
<span class="s">Gecko/20080201 Firefox/2.0.0.12&quot;</span> <span class="mi">0</span> <span class="n">hgbook</span><span class="o">.</span><span class="n">red</span><span class="o">-</span><span class="n">bean</span><span class="o">.</span><span class="n">com</span>
</pre></div>
</div>
<p>虽然直接处理这些日志文件的实现非常简单，但我们显然不能满足于此。如果换个思路，考虑解决一类问题而非一个问题，我们就可能得到适用范围更广的代码。</p>
<p>在开发并行程序时，无论使用何种底层语言，我们都总会遇到一些 “坏钱币” 问题：</p>
<p>[Forec 译注：坏钱币，原文为 “Bad penny”，意味着一个不好的东西总会一次接一次地出现。]</p>
<ul class="simple">
<li><p>算法很快就会被分区和通信的细节所掩盖，从而导致代码变得难以理解和修改；</p></li>
<li><p>对 “粒度” 的选择将变得困难 —— 我们将无法轻易地决定应该分配多少工作给每个核心。如果粒度太小了，那么核心将会在簿记工作上花费大量时间，导致并行程序跑得比串行程序还要慢；但如果粒度太大的话，某些核心又会因为糟糕的负载平衡而被闲置。</p></li>
</ul>
<section id="id32">
<h3>将算法和求值分离<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>并行 Haskell 代码不存在传统语言中通信部分代码产生的混乱，取而代之的，是 <code class="docutils literal notranslate"><span class="pre">par</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pseq</span></code> 对应的繁杂注释。举个例子，下面这个函数的操作方式与 <code class="docutils literal notranslate"><span class="pre">map</span></code> 类似，但会以并行方式将每个元素求值为弱首范式（WHNF）。[Forec 译注：弱首范式的概念在上文的译注中已经介绍过。]</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ParMap.hs</span>
<span class="kr">import</span> <span class="nn">Control.Parallel</span> <span class="p">(</span><span class="nf">par</span><span class="p">)</span>

<span class="nf">parallelMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parallelMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
                       <span class="kr">in</span> <span class="n">r</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="n">r</span> <span class="kt">:</span> <span class="n">parallelMap</span> <span class="n">f</span> <span class="n">xs</span>
<span class="nf">parallelMap</span> <span class="kr">_</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>类型 <code class="docutils literal notranslate"><span class="pre">b</span></code> 可以是一个列表，或者是其它容易求值为弱首范式的类型。我们希望得到万精油式的解法，而不必为列表或者其他任何特殊类型编写定制的 <code class="docutils literal notranslate"><span class="pre">parallelMap</span></code> 。</p>
<p>要解决这个问题，首先需要考虑如何强制求值。下面这个函数将列表中的每个元素强制求值为弱首范式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ParMap.hs</span>
<span class="nf">forceList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">forceList</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="n">forceList</span> <span class="n">xs</span>
<span class="nf">forceList</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>上面的函数并不对列表做任何计算（实际上，该函数的类型签名就已经说明它无法做任何计算，因为它并不知晓列表中的具体元素）。这个函数的唯一目的是确保列表被求值为首范式，它仅能作为 <code class="docutils literal notranslate"><span class="pre">seq</span></code> 或 <code class="docutils literal notranslate"><span class="pre">par</span></code> 函数的第一个参数，例如：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ParMap.hs</span>
<span class="nf">stricterMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">stricterMap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">forceList</span> <span class="n">xs</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div>
</div>
<p>上面的 <code class="docutils literal notranslate"><span class="pre">stricterMap</span></code> 仅仅使列表中的元素被求值为弱首范式。我们可以添加一个函数作为参数，从而强制每个元素被求值至更深的层次：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/ParMap.hs</span>
<span class="nf">forceListAndElts</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">forceListAndElts</span> <span class="n">forceElt</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="n">forceElt</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">forceListAndElts</span> <span class="n">forceElt</span> <span class="n">xs</span>
<span class="nf">forceListAndElts</span> <span class="kr">_</span>        <span class="kr">_</span>      <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>模块 <code class="docutils literal notranslate"><span class="pre">Control.Parallel.Strategies</span></code> 将这个想法浓缩为一个库，它引入了 “求值策略”（Evaluation Strategy） 这个概念：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="kr">type</span> <span class="kt">Done</span> <span class="ow">=</span> <span class="nb">()</span>
<span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Done</span>
</pre></div>
</div>
<p>一个求值策略不会执行任何计算操作，它仅仅保证求值的程度。最简单的策略是 <code class="docutils literal notranslate"><span class="pre">r0</span></code>，也就是什么都不做：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">r0</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">r0</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>下面是 <code class="docutils literal notranslate"><span class="pre">rwhnf</span></code> ，它会将参数求值为弱首范式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">rwhnf</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rwhnf</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>
</pre></div>
</div>
<p>这个模块还提供了一个类型类 <code class="docutils literal notranslate"><span class="pre">NFData</span></code>，它提供了方法 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> ，该方法能够将一个值求值为范式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">rnf</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
  <span class="n">rnf</span> <span class="ow">=</span> <span class="n">rwhnf</span>
</pre></div>
</div>
<p>[Forec 译注： <code class="docutils literal notranslate"><span class="pre">NFData</span></code> 类型类已经被迁移至 <code class="docutils literal notranslate"><span class="pre">Control.DeepSeq</span></code> ， <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 现在已经不再是策略，取而代之的是 <code class="docutils literal notranslate"><span class="pre">rdeepseq</span></code> 。]</p>
<p>对于基本的类型（如 <code class="docutils literal notranslate"><span class="pre">Int</span></code> ），弱首范式和范式完全相同，这也是 <code class="docutils literal notranslate"><span class="pre">NFData</span></code> 类型类将 <code class="docutils literal notranslate"><span class="pre">rwhnf</span></code> 用作 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 默认实现的原因。 <code class="docutils literal notranslate"><span class="pre">Control.Parallel.Strategies</span></code> 模块也为许多常见类型提供了 <code class="docutils literal notranslate"><span class="pre">NFData</span></code> 的实例。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="kr">instance</span> <span class="kt">NFData</span> <span class="kt">Char</span>
<span class="kr">instance</span> <span class="kt">NFData</span> <span class="kt">Int</span>

<span class="kr">instance</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">rnf</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="nb">()</span>
    <span class="n">rnf</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">rnf</span> <span class="n">x</span>

<span class="cm">{- ... and so on ... -}</span>
</pre></div>
</div>
<p>通过这些例子，你应该已经大致清楚如何为自定义类型编写 <code class="docutils literal notranslate"><span class="pre">NFData</span></code> 实例了。你的 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 应当能够处理每个构造器，并且将 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 应用到构造器的每个字段上。</p>
</section>
<section id="id33">
<h3>将算法和策略分离<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>我们可以通过这些基本策略构造更多复杂策略。 <code class="docutils literal notranslate"><span class="pre">Control.Parallel.Strategies</span></code> 提供了很多更复杂的策略。比如说， <code class="docutils literal notranslate"><span class="pre">parList</span></code> 会将一个求值策略并行地应用到列表的每个元素上：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">parList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parList</span> <span class="n">strat</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="nb">()</span>
<span class="nf">parList</span> <span class="n">strat</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">strat</span> <span class="n">x</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">parList</span> <span class="n">strat</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>该模块用 <code class="docutils literal notranslate"><span class="pre">parList</span></code> 定义了并行的 <code class="docutils literal notranslate"><span class="pre">map</span></code> 函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">parMap</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">strat</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">strat</span>
</pre></div>
</div>
<p>这正是代码的有趣之处。在 <code class="docutils literal notranslate"><span class="pre">using</span></code> 的左边是普通形式的 <code class="docutils literal notranslate"><span class="pre">map</span></code> ，而右侧是求值策略。组合器 <code class="docutils literal notranslate"><span class="pre">using</span></code> 告诉我们如何对一个值使用策略，从而使代码和具体的求值方式分离：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">using</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">using</span> <span class="n">x</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">s</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Control.Parallel.Strategies</span></code> 还包含了许多其它函数，它们可以更精确地求值。例如，<code class="docutils literal notranslate"><span class="pre">parZipWith</span></code> 通过求值策略并行地应用 <code class="docutils literal notranslate"><span class="pre">zipWith</span></code> ：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/Strat.hs</span>
<span class="nf">vectorSum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">vectorSum&#39;</span> <span class="ow">=</span> <span class="n">parZipWith</span> <span class="n">rnf</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：函数 <code class="docutils literal notranslate"><span class="pre">parZipWith</span></code> 似乎并不存在，也许这里是原作自己实现的某个函数。]</p>
</section>
<section id="mapreduce">
<h3>编写简单的 MapReduce 定义<a class="headerlink" href="#mapreduce" title="Permalink to this headline">¶</a></h3>
<p>只需要考虑一下 <code class="docutils literal notranslate"><span class="pre">mapReduce</span></code> 函数需要做什么，就能推导出它的类型。首先，<code class="docutils literal notranslate"><span class="pre">map</span></code> 部件是必须的，因此有类型 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> ；其次需要 <code class="docutils literal notranslate"><span class="pre">reduce</span></code> ，也就是 <code class="docutils literal notranslate"><span class="pre">fold</span></code> 的同义词，这里我们使用更普适的类型 <code class="docutils literal notranslate"><span class="pre">[b]</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code> 。这个类型同时兼容左/右 <code class="docutils literal notranslate"><span class="pre">fold</span></code>，因此我们可以根据数据和处理过程灵活地选择。</p>
<p>把这些类型整合到一起，就得到了以下这个完整的类型：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/MapReduce.hs</span>
<span class="nf">simpleMapReduce</span>
    <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>      <span class="c1">-- map function</span>
    <span class="ow">-&gt;</span> <span class="p">([</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>    <span class="c1">-- reduce function</span>
    <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>           <span class="c1">-- list to map over</span>
    <span class="ow">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>代码非常简单：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">simpleMapReduce</span> <span class="n">mapFunc</span> <span class="n">reduceFunc</span> <span class="ow">=</span> <span class="n">reduceFunc</span> <span class="o">.</span> <span class="n">map</span> <span class="n">mapFunc</span>
</pre></div>
</div>
</section>
<section id="id34">
<h3>MapReduce 和策略<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>上面定义的 <code class="docutils literal notranslate"><span class="pre">simpleMapReduce</span></code> 实在太简单了。我们希望能够指定一些并行执行的工作，让它变得更加实用。这一目标可以通过分别在 map 和 reduce 阶段传入策略实现。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/MapReduce.hs</span>
<span class="nf">mapReduce</span>
    <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">b</span>    <span class="c1">-- evaluation strategy for mapping</span>
    <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>      <span class="c1">-- map function</span>
    <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">c</span>    <span class="c1">-- evaluation strategy for reduction</span>
    <span class="ow">-&gt;</span> <span class="p">([</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>    <span class="c1">-- reduce function</span>
    <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>           <span class="c1">-- list to map over</span>
    <span class="ow">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>修改后的类型和函数体大小都有所增长。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/MapReduce.hs</span>
<span class="nf">mapReduce</span> <span class="n">mapStrat</span> <span class="n">mapFunc</span> <span class="n">reduceStrat</span> <span class="n">reduceFunc</span> <span class="n">input</span> <span class="ow">=</span>
    <span class="n">mapResult</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="n">reduceResult</span>
  <span class="kr">where</span> <span class="n">mapResult</span>    <span class="ow">=</span> <span class="n">parMap</span> <span class="n">mapStrat</span> <span class="n">mapFunc</span> <span class="n">input</span>
        <span class="n">reduceResult</span> <span class="ow">=</span> <span class="n">reduceFunc</span> <span class="n">mapResult</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">reduceStrat</span>
</pre></div>
</div>
</section>
<section id="id35">
<h3>适当调整工作量<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>要取得更好的性能，必须保证 <code class="docutils literal notranslate"><span class="pre">par</span></code> 中每个应用所做的工作量远大于维护并行计算所需额外数据的开销。例如处理一个巨大的文件时，若按行切割，那么真正有意义的工作将远小于切割、合并的额外开销。</p>
<p>我们将在后面的章节开发一种处理大块文件的方式。这些大块会由什么组成？由于 Web 服务器日志文件应该只包含 ASCII 文本，我们将会看到 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 的出色性能：这种类型极其高效，并且以流方式传输时仅消耗非常少的内存。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/LineChunks.hs</span>
<span class="kr">module</span> <span class="nn">LineChunks</span>
    <span class="p">(</span>
      <span class="nf">chunkedReadWith</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Exception</span> <span class="p">(</span><span class="nf">bracket</span><span class="p">,</span> <span class="nf">finally</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM</span><span class="p">,</span> <span class="nf">liftM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span> <span class="p">(</span><span class="kt">NFData</span><span class="p">,</span> <span class="nf">rnf</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Int</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy.Char8</span> <span class="k">as</span> <span class="n">LB</span>
<span class="kr">import</span> <span class="nn">GHC.Conc</span> <span class="p">(</span><span class="nf">numCapabilities</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.IO</span>

<span class="kr">data</span> <span class="kt">ChunkSpec</span> <span class="ow">=</span> <span class="kt">CS</span> <span class="p">{</span>
      <span class="n">chunkOffset</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Int64</span>
    <span class="p">,</span> <span class="n">chunkLength</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Int64</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="nf">withChunks</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span>
              <span class="p">(</span><span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">ChunkSpec</span><span class="p">])</span>
           <span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
           <span class="ow">-&gt;</span> <span class="kt">FilePath</span>
           <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">withChunks</span> <span class="n">chunkFunc</span> <span class="n">process</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">handles</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">chunkedRead</span> <span class="n">chunkFunc</span> <span class="n">path</span>
  <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">process</span> <span class="n">chunks</span>
  <span class="p">(</span><span class="n">rnf</span> <span class="n">r</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">return</span> <span class="n">r</span><span class="p">)</span> <span class="p">`</span><span class="n">finally</span><span class="p">`</span> <span class="n">mapM_</span> <span class="n">hClose</span> <span class="n">handles</span>

<span class="nf">chunkedReadWith</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span>
                   <span class="p">([</span><span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">chunkedReadWith</span> <span class="n">func</span> <span class="n">path</span> <span class="ow">=</span>
    <span class="n">withChunks</span> <span class="p">(</span><span class="n">lineChunks</span> <span class="p">(</span><span class="n">numCapabilities</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="n">func</span> <span class="n">path</span>
</pre></div>
</div>
<p>这个程序会以并行的方式处理各个块，并谨慎地利用惰性 I/O 的优势以便确保程序可以安全地传输这些块。</p>
</section>
<section id="i-o">
<h3>减轻惰性 I/O 的风险<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>惰性 I/O 带来了一些众所周知的风险，以下是一些我们需要避免的地方：</p>
<ul class="simple">
<li><p>如果不强制要求程序从文件中拉取数据并计算，那么惰性 I/O 的特性会隐式地延长文件句柄打开的时间。操作系统会限制同时打开的文件数量，这个限制的数量较小且固定。如果这个风险不解决，可能会导致程序中使用到文件句柄的其他部分发生饥饿现象。</p></li>
<li><p>如果程序没有显式地关闭文件句柄，那么文件句柄将由垃圾回收器负责自动关闭，但等到 GC 注意到这个泄漏的文件句柄可能需要很长的时间。这与上面的饥饿风险同理。</p></li>
<li><p>显式关闭句柄能够避免饥饿，但如果关闭得太早，惰性计算可能还需要从这个被关闭的句柄中读取更多数据，这将导致该计算的失败。</p></li>
</ul>
<p>除了这些常见的风险外，我们无法通过单个文件句柄为多个线程提供数据。一个文件句柄只有一个 “寻址指针”，它指明了当前应当读取的位置。如果我们想要读取多个块，那么每一块都需要从文件中的不同位置读取，而单个句柄显然是无法满足这种要求的。</p>
<p>把上面这些思考都整合到一起，我们就得到了以下的惰性 I/O 解决方案：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/LineChunks.hs</span>
<span class="nf">chunkedRead</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">ChunkSpec</span><span class="p">])</span>
            <span class="ow">-&gt;</span> <span class="kt">FilePath</span>
            <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">([</span><span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">],</span> <span class="p">[</span><span class="kt">Handle</span><span class="p">])</span>
<span class="nf">chunkedRead</span> <span class="n">chunkFunc</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">chunks</span> <span class="ow">&lt;-</span> <span class="n">chunkFunc</span> <span class="n">path</span>
  <span class="n">liftM</span> <span class="n">unzip</span> <span class="o">.</span> <span class="n">forM</span> <span class="n">chunks</span> <span class="o">$</span> <span class="nf">\</span><span class="n">spec</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="n">path</span> <span class="kt">ReadMode</span>
    <span class="n">hSeek</span> <span class="n">h</span> <span class="kt">AbsoluteSeek</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">chunkOffset</span> <span class="n">spec</span><span class="p">))</span>
    <span class="n">chunk</span> <span class="ow">&lt;-</span> <span class="kt">LB</span><span class="o">.</span><span class="n">take</span> <span class="p">(</span><span class="n">chunkLength</span> <span class="n">spec</span><span class="p">)</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="kt">LB</span><span class="o">.</span><span class="n">hGetContents</span> <span class="n">h</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的代码通过显式关闭文件句柄来避免饥饿问题。程序会为读取同一个文件的多个线程分别提供独立的句柄，从而允许这些线程同时读取该文件的不同块。</p>
<p>我们要解决的最后一个问题，就是如何防止句柄在计算结束之前被关闭。程序使用 <code class="docutils literal notranslate"><span class="pre">rnf</span></code> 保证所有的处理过程在 <code class="docutils literal notranslate"><span class="pre">withChunks</span></code> 函数返回前完成，从而可以显式关闭文件句柄（可以确保这些句柄不会再被读取）。如果你必须在程序中使用惰性 I/O，那么最好用这种方式构建一道 “防火墙”，从而避免在意想不到的位置发生错误。</p>
</section>
<section id="id36">
<h3>高效寻找行对齐的块<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<p>由于服务器的日志文件是面向行的，所以需要寻找一种高效的方式，保证在文件切分为大块后，每块均在行的边界上结束。我们不想通过扫描一个块的所有数据来确定边界，因为每一块数据可能达到几十兆字节。</p>
<p>无论是固定块的大小还是固定块的数量，我们的方法都能奏效，这里选择后者。首先寻求一个大块结尾的大致位置，之后向前扫描直到换行符，然后在换行符后开始寻找下一个块，并重复该过程。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/LineChunks.hs</span>
<span class="nf">lineChunks</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">ChunkSpec</span><span class="p">]</span>
<span class="nf">lineChunks</span> <span class="n">numChunks</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">bracket</span> <span class="p">(</span><span class="n">openFile</span> <span class="n">path</span> <span class="kt">ReadMode</span><span class="p">)</span> <span class="n">hClose</span> <span class="o">$</span> <span class="nf">\</span><span class="n">h</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">totalSize</span> <span class="ow">&lt;-</span> <span class="n">fromIntegral</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">hFileSize</span> <span class="n">h</span>
    <span class="kr">let</span> <span class="n">chunkSize</span> <span class="ow">=</span> <span class="n">totalSize</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">fromIntegral</span> <span class="n">numChunks</span>
        <span class="n">findChunks</span> <span class="n">offset</span> <span class="ow">=</span> <span class="kr">do</span>
          <span class="kr">let</span> <span class="n">newOffset</span> <span class="ow">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">chunkSize</span>
          <span class="n">hSeek</span> <span class="n">h</span> <span class="kt">AbsoluteSeek</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">newOffset</span><span class="p">)</span>
          <span class="kr">let</span> <span class="n">findNewline</span> <span class="n">off</span> <span class="ow">=</span> <span class="kr">do</span>
                <span class="n">eof</span> <span class="ow">&lt;-</span> <span class="n">hIsEOF</span> <span class="n">h</span>
                <span class="kr">if</span> <span class="n">eof</span>
                  <span class="kr">then</span> <span class="n">return</span> <span class="p">[</span><span class="kt">CS</span> <span class="n">offset</span> <span class="p">(</span><span class="n">totalSize</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)]</span>
                  <span class="kr">else</span> <span class="kr">do</span>
                    <span class="n">bytes</span> <span class="ow">&lt;-</span> <span class="kt">LB</span><span class="o">.</span><span class="n">hGet</span> <span class="n">h</span> <span class="mi">4096</span>
                    <span class="kr">case</span> <span class="kt">LB</span><span class="o">.</span><span class="n">elemIndex</span> <span class="kt">&#39;\</span><span class="n">n&#39;</span> <span class="n">bytes</span> <span class="kr">of</span>
                      <span class="kt">Just</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                        <span class="n">chunks</span><span class="o">@</span><span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">findChunks</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="kr">let</span> <span class="n">coff</span> <span class="ow">=</span> <span class="n">chunkOffset</span> <span class="n">c</span>
                        <span class="n">return</span> <span class="p">(</span><span class="kt">CS</span> <span class="n">offset</span> <span class="p">(</span><span class="n">coff</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span><span class="kt">:</span><span class="n">chunks</span><span class="p">)</span>
                      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">findNewline</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="kt">LB</span><span class="o">.</span><span class="n">length</span> <span class="n">bytes</span><span class="p">)</span>
          <span class="n">findNewline</span> <span class="n">newOffset</span>
    <span class="n">findChunks</span> <span class="mi">0</span>
</pre></div>
</div>
<p>最后一块的大小会比前面的块稍小一些，但这种差异在实际应用中无关紧要。</p>
</section>
<section id="id37">
<h3>计算行数<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<p>下面这个简单的例子展示了如何使用我们构建的 “脚手架”。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/LineCount.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM_</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Int</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy.Char8</span> <span class="k">as</span> <span class="n">LB</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">LineChunks</span> <span class="p">(</span><span class="nf">chunkedReadWith</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">MapReduce</span> <span class="p">(</span><span class="nf">mapReduce</span><span class="p">,</span> <span class="nf">rnf</span><span class="p">)</span>

<span class="nf">lineCount</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int64</span>
<span class="nf">lineCount</span> <span class="ow">=</span> <span class="n">mapReduce</span> <span class="n">rnf</span> <span class="p">(</span><span class="kt">LB</span><span class="o">.</span><span class="n">count</span> <span class="kt">&#39;\</span><span class="n">n&#39;</span><span class="p">)</span>
                      <span class="n">rnf</span> <span class="n">sum</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
  <span class="n">forM_</span> <span class="n">args</span> <span class="o">$</span> <span class="nf">\</span><span class="n">path</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">numLines</span> <span class="ow">&lt;-</span> <span class="n">chunkedReadWith</span> <span class="n">lineCount</span> <span class="n">path</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">path</span> <span class="o">++</span> <span class="s">&quot;: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">numLines</span>
</pre></div>
</div>
<p>若使用 <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-O2</span> <span class="pre">--make-threaded</span></code> 命令编译此程序，它在运行过一次后性能会更好（文件系统已缓存数据）。在双核笔记本上，处理 248MB （110 万行）的数据只需要 0.361 秒（加上 <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-N2</span></code> 参数），单核需要 0.576 秒。</p>
</section>
<section id="url">
<h3>找到最受欢迎的 URL<a class="headerlink" href="#url" title="Permalink to this headline">¶</a></h3>
<p>下面这个例子将计算每个 URL 被访问的次数，它来自 <a class="reference external" href="https://research.google.com/archive/mapreduce.html">[Google08]</a> （Google 讨论 MapReduce 的原始论文）。在 <code class="docutils literal notranslate"><span class="pre">map</span></code> 阶段，我们为每个数据块创建从 URL 映射到访问次数的 <code class="docutils literal notranslate"><span class="pre">Map</span></code> 。在 <code class="docutils literal notranslate"><span class="pre">reduce</span></code> 阶段，合并这些映射。</p>
<p>[Forec 译注：该链接需科学上网后访问。]</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch24/CommonURLs.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span> <span class="p">(</span><span class="kt">NFData</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="nf">rwhnf</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM_</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">,</span> <span class="nf">sortBy</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy.Char8</span> <span class="k">as</span> <span class="n">L</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Char8</span> <span class="k">as</span> <span class="n">S</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
<span class="kr">import</span> <span class="nn">Text.Regex.PCRE.Light</span> <span class="p">(</span><span class="nf">compile</span><span class="p">,</span> <span class="nf">match</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">LineChunks</span> <span class="p">(</span><span class="nf">chunkedReadWith</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">MapReduce</span> <span class="p">(</span><span class="nf">mapReduce</span><span class="p">)</span>

<span class="nf">countURLs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Int</span>
<span class="nf">countURLs</span> <span class="ow">=</span> <span class="n">mapReduce</span> <span class="n">rwhnf</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="n">augment</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span> <span class="o">.</span> <span class="kt">L</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>
                      <span class="n">rwhnf</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">unionsWith</span> <span class="p">(</span><span class="o">+</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">augment</span> <span class="n">map</span> <span class="n">line</span> <span class="ow">=</span>
            <span class="kr">case</span> <span class="n">match</span> <span class="p">(</span><span class="n">compile</span> <span class="n">pattern</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">strict</span> <span class="n">line</span><span class="p">)</span> <span class="kt">[]</span> <span class="kr">of</span>
              <span class="kt">Just</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">url</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">insertWith&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">url</span> <span class="mi">1</span> <span class="n">map</span>
              <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">map</span>
        <span class="n">strict</span>  <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="n">concat</span> <span class="o">.</span> <span class="kt">L</span><span class="o">.</span><span class="n">toChunks</span>
        <span class="n">pattern</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="n">pack</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">(?:GET|POST|HEAD) ([^ ]+) HTTP/&quot;</span>
</pre></div>
</div>
<p>为了从日志文件的每一行中提取出 URL，我们使用了在 <span class="xref std std-ref">chapter_17</span> 中开发的 PCRE 正则表达式库。</p>
<p>驱动程序打印了十条最受欢迎的 URL。与统计行数的例子类似，这个程序在双核上的速度是单核的 1.8 倍，处理 110 万条日志只需要 1.7 秒。</p>
</section>
<section id="id38">
<h3>总结<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<p>给定一个适合 MapReduce 模型的问题，MapReduce 编程模型可以帮助我们使用 Haskell 以极小的工作量编写 “临时” 但高效的并行程序。此外，这个想法可以轻松扩展到其它数据源，比如文件集以及网络上的数据资源。</p>
<p>在许多情况下，为了跟上计算核心的处理速度，数据流的速度必须足够快，这一点将成为性能瓶颈。例如，若我们尝试将上述某个示例程序应用于一个没有缓存在主存的文件，或者是一个通过高带宽存储阵列传输的文件，那么大部分时间都将浪费在等待磁盘 I/O 上，而无法利用多核的优势。</p>
<dl class="footnote brackets">
<dt class="label" id="id39"><span class="brackets"><a class="fn-backref" href="#id7">54</a></span></dt>
<dd><p>在稍后将展示，GHC 的线程异常轻量。如果运行时提供检查每个线程状态的方法，每个线程的开销将增加，哪怕永远不会用到这些信息。</p>
</dd>
<dt class="label" id="id40"><span class="brackets"><a class="fn-backref" href="#id20">55</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">non-threaded</span></code> 运行时不接受这个选项，会用一条错误信息拒绝它。</p>
</dd>
<dt class="label" id="id41"><span class="brackets"><a class="fn-backref" href="#id22">56</a></span></dt>
<dd><p>此书撰写时，垃圾收集器已经开始重新编写以利用多核，但是我们不确定它在未来的效果。</p>
</dd>
<dt class="label" id="id42"><span class="brackets"><a class="fn-backref" href="#id31">57</a></span></dt>
<dd><p>这个想法是 Tim Bray 提出的。</p>
</dd>
</dl>
</section>
</section>
</section>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="23.html">第 23 章：用 gtk2hs 进行图形界面编程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="25.html">第 25 章：性能剖析与优化</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, huangz1990.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>